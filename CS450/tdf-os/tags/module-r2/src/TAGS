
DATE.C,98
int date(char* argstr)date13,202
int validDate(int day, int month, int year){validDate73,1737

DISPLAY.C,42
int display (char *folder)display15,292

HELP.C,33
int help(char *argstr)help6,82

HISTORY.C,98
int history ( char *args )history12,244
int append_history ( char *args )append_history37,578

MPX_SUPT.C,871728
/***********************************************************************	MPX: The MultiProgramming eXecutive	Project to Accompany	A Practical Approach to Operating Systems	Malcolm G. Lane & James D. Mooney	Copyright 1993, P.W.S. Kent Publishing Co., Boston, MA.		File Name: mpx_supt.c	Authors: J.J. Patnesky, A. Ghosal, M. Lane, J. Mooney	Version: 2.1b	Date: 01/31/08	Purpose: Support routines for MPX-PC		Modules: all	Environment:      IBM-PC (XT, AT or PS/2)			MS-DOS 3.3 or later			TURBO-C 3.0 or TURBO-C++ 1.0 or later	Compile using the LARGE MODEL and SS NOT equal to DS.	All addresses and pointers are "far", and	CS, DS and SS are independent.	Procedures in this file:		sys_init		sys_exit		sys_set_vec		sys_req		sys_alloc_mem		sys_free_mem		sys_get_date		sys_set_date		sys_open_dir		sys_get_entry		sys_close_dir	       sys_check_program	       sys_load_program************************************************************************Change Log:	07/16/88  akg	added comments	02/25/92  jdm	full revision, UNIX version	04/14/92  jdm	Macintosh version	05/15/92  jdm	cleanup and documentation	07/14/92  jdm	update for revised specs        08/13/92  jdm 	revised IBM version; added private heap        10/14/92  jdm 	added check and load procedures        10/18/92  jdm 	revised sys_alloc_mem for alignment	11/17/92  jdm	true heap mgt, aligned, using calloc & free	11/19/92  jdm	enable device handling for final module	12/31/92  jdm	revised sys_req parameters	01/02/93  jdm	return count value after I/O	01/03/93  jdm	revised error names and codes	01/27/93  jdm	corrected count for line input in sys_req			fixed open_dir to handle null lines	02/24/93  jdm	changed sys_set_vec param to interrupt	03/08/93  jdm	corrections to sys_check & sys_load	03/20/93  jdm	stack switch in free, check, and load	04/22/93  jdm	corrected index conflict in sys_free_mem			added safety escape in alloc table search	07/28/93  jdm	conversion to large model	09/01/93  jdm	fixed allocation bug;  made date private	09/14/93  jdm	cleaned up memory allocation        09/16/93  jdm	adjusted program load for large model        09/30/93  jdm	modified for correct list of root directory	11/01/94  jdm	changed load file read to binary	09/18/95  jdm	fixed get_entry to default to current, not root	01/31/08  jdm   fixed possible overflow problem in get_entry************************************************************************/#include "mpx_supt.h"#include <stdlib.h>#include <dos.h>#include <dir.h>#include <errno.h>#include <conio.h>#include <alloc.h>#define VEC_ADDR (0x60L*4)#define MAX_ALLOC 200#define MAX_XPOS 79#define MAX_YPOS 24#define MAX_PATH_SIZE 50/*	System-dependent type definitions*/typedef unsigned char byte;typedef unsigned int word;typedef unsigned long longword;typedef byte *address;typedef struct params {	int      op_code;	int      device_id;	char     *buf_p;	int      *count_p;	} params;/*	Global variables accessed only by support routines*/	static longword vec_save;  /* saved interrupt vector */	static int mod_code;                /* module code */                                           	static struct date sys_date;        /* MPX system date */	/* data structures for directory access */        static char current_path[MAX_PATH_SIZE+1];        static int num_entries;        static struct ffblk file_block;        /* handler presence flags */	static flag sysc_hand;	static flag trm_hand;	static flag prt_hand;	static flag com_hand;        /* memory allocation table */	static struct {		void* original;		void* aligned;	} alloc_table[MAX_ALLOC];	static int alloc_ix;                /* current index */	static int num_alloc;               /* no. of allocated blocks *//*	Procedure: sys_init	Purpose: initialize mpx	Parameters: see prototype  	Return value: error code, or OK if no error	Calls: getdate    	Globals: mod_code		vec_save		sys_date		alloc_table, alloc_ix, num_alloc		sysc_hand, term_hand, prt_hand, com_hand	Errors: none*/int sys_init (    int      modules  /* module code */	     ){	mod_code = modules;        vec_save = 0L;        /* no handlers detected yet */	sysc_hand = FALSE;	trm_hand = FALSE;	prt_hand = FALSE;	com_hand = FALSE;	/* initialize allocation table */	for (alloc_ix=0; alloc_ix < MAX_ALLOC; alloc_ix++) {		alloc_table[alloc_ix].original = NULL;		alloc_table[alloc_ix].aligned = NULL;	}	alloc_ix = 0;	num_alloc = 0;	/* if we have reached Module R3, enable system call handling */	if (modules >= MODULE_R3) sysc_hand = TRUE;	/* if we have reached the final module, enable device handlers */	if (modules >= MODULE_F) {		trm_hand = TRUE;		prt_hand = TRUE;		com_hand = TRUE;	}	/* get system date */        getdate(&sys_date);	return (OK);}/*	Procedure: sys_exit	Purpose: terminate mpx	Parameters: none  	Return value: none	Calls: none       	Globals: vec_save*/void sys_exit(void){	longword *vec_p;	/* if trap vector changed, restore it */	if (vec_save != 0L) {		vec_p = (longword*) VEC_ADDR;		*vec_p = vec_save;	}	/* return to host with null error code */	exit(0);}/*	Procedure: sys_set_vec	Purpose: link trap vector to MPX system call handler	Parameters: handler: addr of handler         	Return value: error code; OK if no error	Calls: none       	Globals: vec_save	Errors: none*/int sys_set_vec   ( void interrupt (*handler)() /* system call handler */		){	longword *vec_p;			vec_p = (longword*) VEC_ADDR;		vec_save = *vec_p;		*vec_p = (longword) handler;	return (0);}/*	Procedure: sys_req	Purpose: Request a system service	Inputs:		op_code           operation code		device_id         device identifier		buf_p             addresso f data buffer		count_p           address of size of buffer	Returns: Result or error code, depending on service		Services supported:	IDLE     null operation				READ     input from a device				WRITE    output to a device				CLEAR    clear terminal screen				GOTOXY   absolute cursor position				EXIT     terminate the caller	Calls:   fgets		strlen			Globals: none		Errors:  ERR_SUP_INVDEV    invalid device		ERR_SUP_INVOPC    invalid operation code		ERR_SUP_INVPOS    invalid character position		ERR_SUP_RDFAIL    read failed		ERR_SUP_WRFAIL    write failed	Description:	For Modules R1 through R4,	this procedure is used only for terminal I/O.	Later modules support both reading and	writing for several devices.	For Modules R1 through R4,	sys_req uses the ANSI C function "fgets."	Later modules may use alternate functions and device drivers.*/int sys_req (   int      op_code, /* operation code */		int      device_id,        /* device id */		char*    buf_p,            /* I/O buffer */		int*     count_p           /* address of count */		){	int      rval;    /* result or error code */	char     *rp;     /* return pointer for fgets */	char     rc;      /* return char for fputc */        params    *param_p; /* pointer to parameter record in stack */	flag     docall;  /* true if system call interrupt wanted */	int      ix;      /* temporary index */	docall = FALSE;	rval = OK;	switch (op_code) {		case IDLE:		if (sysc_hand) docall = TRUE;		break; 				case READ:		switch (device_id) {				case TERMINAL:			if (trm_hand) docall = TRUE;			else {				rp = fgets(buf_p,*count_p,stdin);				if (rp==NULL) rval = ERR_SUP_RDFAIL;				else rval = strlen(buf_p);			}			break;					case COM_PORT:			if (com_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					default:			rval = ERR_SUP_INVDEV;					}		break;	case WRITE:		switch (device_id) {				case TERMINAL:			if (trm_hand) docall = TRUE;			else {				rval = *count_p;				for (ix=0; ix<*count_p; ix++) {					rc = fputc(buf_p[ix],stdout);					if (rc == EOF) {						rval = ERR_SUP_WRFAIL;						break;					}				}			}			break;					case COM_PORT:			if (com_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					case PRINTER:			if (prt_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					default:			rval = ERR_SUP_INVDEV;					}		break;	case CLEAR:		if (device_id==TERMINAL) {			if (trm_hand) docall = TRUE;			else {			     clrscr();				rval = 0;			}		}		else rval = ERR_SUP_INVDEV;		break;			case GOTOXY:		if (device_id==TERMINAL) {			if (trm_hand) docall = TRUE;			else {				if (*count_p != 2) rval = ERR_SUP_WRFAIL;				else if ((*buf_p<0)					|| (*buf_p > MAX_XPOS))					rval = ERR_SUP_WRFAIL;				else if ((*(buf_p+1)<0)					|| (*(buf_p+1) > MAX_YPOS))					rval = ERR_SUP_WRFAIL;				else {					gotoxy(*buf_p + 1,						*(buf_p+1) + 1);					rval = 0;				}			}		}		else rval = ERR_SUP_INVDEV;		break;			/* EXIT - terminate the calling process */	/* legal only when a system call handler is present */	case EXIT:		if (sysc_hand) docall = TRUE;		else rval = ERR_SUP_INVOPC;		break; 	default:		rval = ERR_SUP_INVOPC;			}		/* Invoke user's call handler if present.	   If the call is an IO request, return will occur	   only after the request is complete.	*/	if (docall && (rval==OK)) {		/* invoke the call handler */	_SP = _SP - sizeof(params);		param_p = (params*) MK_FP(_SS,_SP);	       param_p->op_code = op_code;	       param_p->device_id = device_id;	       param_p->buf_p = buf_p;	       param_p->count_p = count_p;	       geninterrupt(0x60);	       rval = _AX;	       _SP = _SP + sizeof(params);		/* for I/O operations, return count value */		switch(op_code) {		case READ:		case WRITE:		case CLEAR:		case GOTOXY:			rval = *count_p;		}	}	return(rval);}/*	Procedure: sys_alloc_mem	Purpose: Allocate a memory block	Parameters:			size_t size       No. of bytes to allocate	Returns: void* pointer to allocated block;		 null pointer in case of error		 	Calls: calloc		Globals: alloc_table, alloc_ix, num_alloc	For program loading (Module R-4), the blocks must be aligned.	This is achieved by requesting one extra paragraph and	returning the lowest aligned address as the base.  It is	necessary to keep a table of allocated address, original and	aligned, to support correct freeing.	It would seem simpler to use the Turbo-C function allocmem,	which always allocates aligned blocks.  However, allocmem	appears to conflict with the internal allocation of fopen	and other C library routines.*/void *sys_alloc_mem (      size_t   size     /* size in bytes to allocate */		    ){	int ix_save;      /* temp copy of table index */        void *addr;        /* addr returned by calloc (*void) */	word offset;      /* offset of unaligned address */	word seg;         /* segment addr of unaligned address */	void *addr_alig; /* aligned address */	int rem; /* temp for alignment computation */	/* ensure that allocation table is not full */	if (num_alloc >= MAX_ALLOC) {		return(NULL);	}	/* find free entry in allocation table */	ix_save = alloc_ix;	while (alloc_table[alloc_ix].original != NULL) {		alloc_ix++;		if (alloc_ix >= MAX_ALLOC) alloc_ix = 0;		/* safety check -- should never happen! */		if (alloc_ix == ix_save) return(NULL);	}	/* call allocation routine */	/* request 15 extra bytes to ensure alignment is possible */	addr = calloc(size + 15,1);	/* compute aligned base */	offset = FP_OFF(addr);        seg = FP_SEG(addr);	rem = offset % 16;	if (rem > 0) offset = offset + 16 - rem;	addr_alig = MK_FP(seg,offset);	/* insert entries in table */	alloc_table[alloc_ix].original = addr;	alloc_table[alloc_ix].aligned = addr_alig;	/* increment count */	num_alloc++;	return(addr_alig);}/*	Procedure: sys_free_mem	Purpose: free a memory block	Parameters:		void *ptr         ptr to block to allocate	Returns: integer error code; zero if OK		Calls:   free	Globals: alloc_table, num_alloc	Errors:  ERR_SUP_INVMEM    invalid memory block	This procedure receives an aligned address; it must	find and free the corresponding non-aligned one.*/int sys_free_mem (         void     *ptr     /* pointer to block */		 ){	void *free_addr;  /* true (unaligned) block address */	int free_ix;               /* temp table index */	/* ensure valid pointer */	if (ptr==NULL) return(ERR_SUP_INVMEM);	/* Look for the block in the allocation table */	free_addr = NULL;	for (free_ix=0; free_ix<MAX_ALLOC; free_ix++) {		if (alloc_table[free_ix].aligned == ptr) {			free_addr = alloc_table[free_ix].original;			break;		}	}	/* If the block wasn't found, report error */	if (free_addr == NULL) return(ERR_SUP_INVMEM);	/* free the block & clear the table entry */	alloc_table[free_ix].original = NULL;	alloc_table[free_ix].aligned = NULL;        free(free_addr);	/* decrement count */	num_alloc--;	return(OK);}        /*	Procedure: sys_get_date	Purpose: Returns the system date (month, day, year)	Parameters:		date_rec *date_p Pointer to structure of type date	Returns: void		Calls: none		Globals: sys_date        Errors: none*/void sys_get_date (  date_rec*      date_p   /* ptr to date record */		){	date_p->month = sys_date.da_mon;	date_p->day = sys_date.da_day;	date_p->year = sys_date.da_year;}/*	Procedure: sys_set_date	Purpose: Sets the system date (month, day, year)	Parameters:		date_rec *date_p ptr to structure of type date	Returns: error code; OK if no error	Calls:   none        Globals: sys_date	Errors: none*/int sys_set_date (  date_rec*       date_p   /* ptr to date record */		 ){	sys_date.da_mon = date_p->month;        sys_date.da_day = date_p->day;        sys_date.da_year = date_p->year;	return(OK);}/*	Procedure: sys_open_dir	Purpose: open a specified directory	Parameters: char dir_name[]            directory name	Returns: error code; zero if OK	Calls:   findfirst		strncpy  	Globals: current_path, file_block, num_entries	Errors:  ERR_SUP_DIROPN    directory open error		ERR_SUP_INVDIR    invalid directory*/int sys_open_dir (  char  path_name[]        /* directory name */		 ){        char temp_path[MAX_PATH_SIZE];	int res;        int len;        /* ensure there is no directory currently open */	if (current_path[0]!=NULCH) return(ERR_SUP_DIROPN);        /* check pathname for validity */        /* construct temporary search path name */	temp_path[0] = NULCH;	if (path_name != NULL) {		strncpy(temp_path,path_name,MAX_PATH_SIZE-4);	}	/* build wildcard search string */        len = strlen(temp_path);	/* if path is null, use current directory */        if (len==0) strcpy(temp_path,"*.*");	/* handle paths ending in backslash, including root */        else if (temp_path[len-1]=='\\') strcat(temp_path,"*.*");	/* handle paths not ending in backslash */        else strcat(temp_path,"\\*.*");	/* validate the directory by searching for either an ordinary	   file or a directory in it.  This should never fail; even	   empty directories contain the directories "." and ".."	*/		res = findfirst(temp_path, &file_block, FA_DIREC);	if (res!=0)  return(ERR_SUP_INVDIR);        /* save pathname as current, clear entry count */	current_path[0] = NULCH;	if (path_name != NULL) {		strncpy(current_path,path_name,MAX_PATH_SIZE-6);	}	num_entries = 0;	return(OK);}/*	Procedure: sys_get_entry	Purpose: get the next directory entry;	Parameters: char name_buf[]	name buffer		    int buf_size  	buffer capacity		    long *file_size_p	file length buffer         	Returns: error code, or zero if ok	Calls:	findfirst		findnext		strncpy, strcpy, strrchr, strcat    	Globals: current_path, num_entries, file_block	Errors:  ERR_SUP_NOENTR    no such entry*/int sys_get_entry (char    name_buf[],       /* buffer for entry */		   int   buf_size,         /* buffer size */		   long* file_size_p       /* buffer for size value */		  ){	char filename[MAX_PATH_SIZE+1];	int err;        int len;        char *cp;        /* find next MPX file entry, if any */        /* if this is the first call */	if (num_entries==0) {	       /* construct complete search path name */	       len = strlen(current_path);	       if (len==0) strcpy(current_path,"*.MPX");	       else if (current_path[len-1]=='\\') strcat(current_path,"*.MPX");	       else strcat(current_path,"\\*.MPX");	       /* find first entry */		err = findfirst (current_path,&file_block,0);        }        /* otherwise, find next entry */        else err = findnext(&file_block);        if (err<0) return(ERR_SUP_NOENTR);		/* ensure buf_size is not too large */		if (buf_size > MAX_PATH_SIZE) buf_size = MAX_PATH_SIZE;		      /* copy filename to buffer */	filename[buf_size] = NULCH;	strncpy (filename,file_block.ff_name,			 (size_t) buf_size);	/* remove ".MPX" from name */	cp = strrchr(filename, (int) '.');        *cp = NULCH;	/* copy name and size to caller's buffer */        strcpy (name_buf,filename);	*file_size_p = file_block.ff_fsize;        /* count entry */	num_entries++;	return(OK);}/*	Procedure: sys_close_dir	Purpose: close an open directory	Parameters: none	Returns: error code; zero if OK	Calls:   none	Globals: current_path	Errors:  none*/int sys_close_dir (void){	current_path[0] = NULCH;	return(OK);}/*	Procedure: sys_check_program	Purpose: locate and measure a program file	Parameters: see prototype	Returns: program size or error code	Calls:   strlen, strcat		fopen, fread	Globals: none	Errors:  ERR_SUP_NAMLNG    pathname too long		ERR_SUP_FILNFD    file not found		ERR_SUP_FILINV    file invalid*/#define HEADER_SIZE 32int sys_check_program(     char     dir_name[],       /* directory name */			char     prog_name[],      /* program name */			int*     prog_len_p,       /* ptr to prog length */			int*     start_offset_p    /* ptr to start offset */			){        /* buffer for full pathname */	char file_name[MAX_PATH_SIZE+1];        /* buffer for file header */        byte header[HEADER_SIZE];	FILE *file_p;     /* file pointer for C file routines */        int num_read;      /* number of header bytes read */	int file_size;    /* size of complete file */        int header_size;/* size of header */        int code_size;     /* size of program code */        int data_size;     /* size of program data */        int errcode;       /* error code */        /* ensure that path name is not too long */        if ((strlen(dir_name) + strlen(prog_name) + 5)		 > MAX_PATH_SIZE) return(ERR_SUP_NAMLNG);	/* construct path name */	file_name[0] = NULCH;	if (dir_name[0] != NULCH) {		strcat(file_name, dir_name);	        strcat(file_name, "\\");	}        strcat(file_name, prog_name);	strcat(file_name, ".MPX");        /* try to open the file */	errcode = OK;        file_p = fopen(file_name, "rb");        if (file_p == NULL) return(ERR_SUP_FILNFD);	/* read the header, check for EXE signature */        num_read = fread( (void*) header, 1, HEADER_SIZE, file_p);        if (num_read != HEADER_SIZE) {		errcode = ERR_SUP_FILINV;	}        else if ((header[0] != 0x4D) || (header[1] != 0x5A)) {		errcode = ERR_SUP_FILINV;	}        /* close the file, then return if error occurred */        fclose(file_p);	if (errcode!=OK) return(errcode);        /* compute allocation size needed */        file_size = (header[5]*256 + header[4] -1) * 512		+ (header[3]*256 + header[2]);        header_size =(header[9]*256 + header[8])*16;        code_size = file_size - header_size;        data_size = (header[11]*256 + header[10])*16;        /* return total length and starting offset */        *prog_len_p = code_size + data_size;	*start_offset_p = (header[23]*256 + header[22]) * 16;	return(OK);}/*	Procedure: sys_load_program	Purpose: load a program file	Parameters: see prototype	Returns: error code; zero if OK	Calls:   intdosx		segread		strlen, strcat	Globals: none 	Errors:  ERR_SUP_NAMLNG    name too long		ERR_SUP_FILNFD    file not found	       ERR_SUP_FILINV      file invalid		ERR_SUP_PROGSZ    program too large	       ERR_SUP_LDADDR      address not aligned		ERR_SUP_LDFAIL    load failed*/int sys_load_program (     void*    load_addr,        /* address for loading */			int      max_size,         /* memory size */			char     dir_name[],       /* directory name */			char     prog_name[]       /* program name */		      ){	int errcode;      /* error code */        int prog_len;      /* program length */	int offset;       /* offset for starting */	word norm_seg;    /* normalized load address segment */        word norm_off;     /* normalized load address offset */        /* full pathname for file to be loaded */	char file_name[MAX_PATH_SIZE+1];        /* parameter block for MSDOS EXEC function */	struct {		word load_seg;    /* segment address for loading */	       word reloc_seg;     /* segment address for relocation */        }p_block;	union REGS inregs;            /* input register structure */	union REGS outregs;           /* output register structure */	struct SREGS segregs;         /* segment register structure */        /* check program, get length and offset */	errcode = sys_check_program(dir_name, prog_name,					&prog_len, &offset);        if (errcode < 0) return(errcode);        /* ensure that allocated memory is large enough */        if (max_size < prog_len) return(ERR_SUP_PROGSZ);        /* get normalized segment and offset, check alignment */	norm_seg = FP_SEG(load_addr);	norm_off = FP_OFF(load_addr);	norm_seg += norm_off / 16;        norm_off %= 16;	if (norm_off != 0) return(ERR_SUP_LDADDR);        /* ensure that path name is not too long */        if ((strlen(dir_name) + strlen(prog_name) + 5)		 > MAX_PATH_SIZE) return(ERR_SUP_NAMLNG);	/* construct path name */	file_name[0] = NULCH;	if (dir_name[0] != NULCH) {		strcat(file_name, dir_name);	        strcat(file_name, "\\");	}        strcat(file_name, prog_name);	strcat(file_name, ".MPX");        /* get current segment regs */	segread(&segregs);        /* setup function codes */	inregs.h.ah = 0x4B;        /* EXEC function */	inregs.h.al = 0x03;        /* load only */        /* setup parameter block and name pointers */        segregs.ds = FP_SEG(&file_name);	inregs.x.dx = FP_OFF(&file_name);        segregs.es = FP_SEG(&p_block);	inregs.x.bx = FP_OFF(&p_block);        /* setup load segment -- must be normalized */	p_block.load_seg = norm_seg;	p_block.reloc_seg = p_block.load_seg;        /* call the MS-DOS loader */	errcode = intdosx(&inregs,&outregs,&segregs);        errcode = errcode;        /* check for error */	if (outregs.x.cflag) return(ERR_SUP_LDFAIL);	/* load successful */	return(OK);}/* END OF FILE */byte1,0
/***********************************************************************	MPX: The MultiProgramming eXecutive	Project to Accompany	A Practical Approach to Operating Systems	Malcolm G. Lane & James D. Mooney	Copyright 1993, P.W.S. Kent Publishing Co., Boston, MA.		File Name: mpx_supt.c	Authors: J.J. Patnesky, A. Ghosal, M. Lane, J. Mooney	Version: 2.1b	Date: 01/31/08	Purpose: Support routines for MPX-PC		Modules: all	Environment:      IBM-PC (XT, AT or PS/2)			MS-DOS 3.3 or later			TURBO-C 3.0 or TURBO-C++ 1.0 or later	Compile using the LARGE MODEL and SS NOT equal to DS.	All addresses and pointers are "far", and	CS, DS and SS are independent.	Procedures in this file:		sys_init		sys_exit		sys_set_vec		sys_req		sys_alloc_mem		sys_free_mem		sys_get_date		sys_set_date		sys_open_dir		sys_get_entry		sys_close_dir	       sys_check_program	       sys_load_program************************************************************************Change Log:	07/16/88  akg	added comments	02/25/92  jdm	full revision, UNIX version	04/14/92  jdm	Macintosh version	05/15/92  jdm	cleanup and documentation	07/14/92  jdm	update for revised specs        08/13/92  jdm 	revised IBM version; added private heap        10/14/92  jdm 	added check and load procedures        10/18/92  jdm 	revised sys_alloc_mem for alignment	11/17/92  jdm	true heap mgt, aligned, using calloc & free	11/19/92  jdm	enable device handling for final module	12/31/92  jdm	revised sys_req parameters	01/02/93  jdm	return count value after I/O	01/03/93  jdm	revised error names and codes	01/27/93  jdm	corrected count for line input in sys_req			fixed open_dir to handle null lines	02/24/93  jdm	changed sys_set_vec param to interrupt	03/08/93  jdm	corrections to sys_check & sys_load	03/20/93  jdm	stack switch in free, check, and load	04/22/93  jdm	corrected index conflict in sys_free_mem			added safety escape in alloc table search	07/28/93  jdm	conversion to large model	09/01/93  jdm	fixed allocation bug;  made date private	09/14/93  jdm	cleaned up memory allocation        09/16/93  jdm	adjusted program load for large model        09/30/93  jdm	modified for correct list of root directory	11/01/94  jdm	changed load file read to binary	09/18/95  jdm	fixed get_entry to default to current, not root	01/31/08  jdm   fixed possible overflow problem in get_entry************************************************************************/#include "mpx_supt.h"#include <stdlib.h>#include <dos.h>#include <dir.h>#include <errno.h>#include <conio.h>#include <alloc.h>#define VEC_ADDR (0x60L*4)#define MAX_ALLOC 200#define MAX_XPOS 79#define MAX_YPOS 24#define MAX_PATH_SIZE 50/*	System-dependent type definitions*/typedef unsigned char byte;typedef unsigned int word;typedef unsigned long longword;typedef byte *address;typedef struct params {	int      op_code;	int      device_id;	char     *buf_p;	int      *count_p;	} params;/*	Global variables accessed only by support routines*/	static longword vec_save;  /* saved interrupt vector */	static int mod_code;                /* module code */                                           	static struct date sys_date;        /* MPX system date */	/* data structures for directory access */        static char current_path[MAX_PATH_SIZE+1];        static int num_entries;        static struct ffblk file_block;        /* handler presence flags */	static flag sysc_hand;	static flag trm_hand;	static flag prt_hand;	static flag com_hand;        /* memory allocation table */	static struct {		void* original;		void* aligned;	} alloc_table[MAX_ALLOC];	static int alloc_ix;                /* current index */	static int num_alloc;               /* no. of allocated blocks *//*	Procedure: sys_init	Purpose: initialize mpx	Parameters: see prototype  	Return value: error code, or OK if no error	Calls: getdate    	Globals: mod_code		vec_save		sys_date		alloc_table, alloc_ix, num_alloc		sysc_hand, term_hand, prt_hand, com_hand	Errors: none*/int sys_init (    int      modules  /* module code */	     ){	mod_code = modules;        vec_save = 0L;        /* no handlers detected yet */	sysc_hand = FALSE;	trm_hand = FALSE;	prt_hand = FALSE;	com_hand = FALSE;	/* initialize allocation table */	for (alloc_ix=0; alloc_ix < MAX_ALLOC; alloc_ix++) {		alloc_table[alloc_ix].original = NULL;		alloc_table[alloc_ix].aligned = NULL;	}	alloc_ix = 0;	num_alloc = 0;	/* if we have reached Module R3, enable system call handling */	if (modules >= MODULE_R3) sysc_hand = TRUE;	/* if we have reached the final module, enable device handlers */	if (modules >= MODULE_F) {		trm_hand = TRUE;		prt_hand = TRUE;		com_hand = TRUE;	}	/* get system date */        getdate(&sys_date);	return (OK);}/*	Procedure: sys_exit	Purpose: terminate mpx	Parameters: none  	Return value: none	Calls: none       	Globals: vec_save*/void sys_exit(void){	longword *vec_p;	/* if trap vector changed, restore it */	if (vec_save != 0L) {		vec_p = (longword*) VEC_ADDR;		*vec_p = vec_save;	}	/* return to host with null error code */	exit(0);}/*	Procedure: sys_set_vec	Purpose: link trap vector to MPX system call handler	Parameters: handler: addr of handler         	Return value: error code; OK if no error	Calls: none       	Globals: vec_save	Errors: none*/int sys_set_vec   ( void interrupt (*handler)() /* system call handler */		){	longword *vec_p;			vec_p = (longword*) VEC_ADDR;		vec_save = *vec_p;		*vec_p = (longword) handler;	return (0);}/*	Procedure: sys_req	Purpose: Request a system service	Inputs:		op_code           operation code		device_id         device identifier		buf_p             addresso f data buffer		count_p           address of size of buffer	Returns: Result or error code, depending on service		Services supported:	IDLE     null operation				READ     input from a device				WRITE    output to a device				CLEAR    clear terminal screen				GOTOXY   absolute cursor position				EXIT     terminate the caller	Calls:   fgets		strlen			Globals: none		Errors:  ERR_SUP_INVDEV    invalid device		ERR_SUP_INVOPC    invalid operation code		ERR_SUP_INVPOS    invalid character position		ERR_SUP_RDFAIL    read failed		ERR_SUP_WRFAIL    write failed	Description:	For Modules R1 through R4,	this procedure is used only for terminal I/O.	Later modules support both reading and	writing for several devices.	For Modules R1 through R4,	sys_req uses the ANSI C function "fgets."	Later modules may use alternate functions and device drivers.*/int sys_req (   int      op_code, /* operation code */		int      device_id,        /* device id */		char*    buf_p,            /* I/O buffer */		int*     count_p           /* address of count */		){	int      rval;    /* result or error code */	char     *rp;     /* return pointer for fgets */	char     rc;      /* return char for fputc */        params    *param_p; /* pointer to parameter record in stack */	flag     docall;  /* true if system call interrupt wanted */	int      ix;      /* temporary index */	docall = FALSE;	rval = OK;	switch (op_code) {		case IDLE:		if (sysc_hand) docall = TRUE;		break; 				case READ:		switch (device_id) {				case TERMINAL:			if (trm_hand) docall = TRUE;			else {				rp = fgets(buf_p,*count_p,stdin);				if (rp==NULL) rval = ERR_SUP_RDFAIL;				else rval = strlen(buf_p);			}			break;					case COM_PORT:			if (com_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					default:			rval = ERR_SUP_INVDEV;					}		break;	case WRITE:		switch (device_id) {				case TERMINAL:			if (trm_hand) docall = TRUE;			else {				rval = *count_p;				for (ix=0; ix<*count_p; ix++) {					rc = fputc(buf_p[ix],stdout);					if (rc == EOF) {						rval = ERR_SUP_WRFAIL;						break;					}				}			}			break;					case COM_PORT:			if (com_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					case PRINTER:			if (prt_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					default:			rval = ERR_SUP_INVDEV;					}		break;	case CLEAR:		if (device_id==TERMINAL) {			if (trm_hand) docall = TRUE;			else {			     clrscr();				rval = 0;			}		}		else rval = ERR_SUP_INVDEV;		break;			case GOTOXY:		if (device_id==TERMINAL) {			if (trm_hand) docall = TRUE;			else {				if (*count_p != 2) rval = ERR_SUP_WRFAIL;				else if ((*buf_p<0)					|| (*buf_p > MAX_XPOS))					rval = ERR_SUP_WRFAIL;				else if ((*(buf_p+1)<0)					|| (*(buf_p+1) > MAX_YPOS))					rval = ERR_SUP_WRFAIL;				else {					gotoxy(*buf_p + 1,						*(buf_p+1) + 1);					rval = 0;				}			}		}		else rval = ERR_SUP_INVDEV;		break;			/* EXIT - terminate the calling process */	/* legal only when a system call handler is present */	case EXIT:		if (sysc_hand) docall = TRUE;		else rval = ERR_SUP_INVOPC;		break; 	default:		rval = ERR_SUP_INVOPC;			}		/* Invoke user's call handler if present.	   If the call is an IO request, return will occur	   only after the request is complete.	*/	if (docall && (rval==OK)) {		/* invoke the call handler */	_SP = _SP - sizeof(params);		param_p = (params*) MK_FP(_SS,_SP);	       param_p->op_code = op_code;	       param_p->device_id = device_id;	       param_p->buf_p = buf_p;	       param_p->count_p = count_p;	       geninterrupt(0x60);	       rval = _AX;	       _SP = _SP + sizeof(params);		/* for I/O operations, return count value */		switch(op_code) {		case READ:		case WRITE:		case CLEAR:		case GOTOXY:			rval = *count_p;		}	}	return(rval);}/*	Procedure: sys_alloc_mem	Purpose: Allocate a memory block	Parameters:			size_t size       No. of bytes to allocate	Returns: void* pointer to allocated block;		 null pointer in case of error		 	Calls: calloc		Globals: alloc_table, alloc_ix, num_alloc	For program loading (Module R-4), the blocks must be aligned.	This is achieved by requesting one extra paragraph and	returning the lowest aligned address as the base.  It is	necessary to keep a table of allocated address, original and	aligned, to support correct freeing.	It would seem simpler to use the Turbo-C function allocmem,	which always allocates aligned blocks.  However, allocmem	appears to conflict with the internal allocation of fopen	and other C library routines.*/void *sys_alloc_mem (      size_t   size     /* size in bytes to allocate */		    ){	int ix_save;      /* temp copy of table index */        void *addr;        /* addr returned by calloc (*void) */	word offset;      /* offset of unaligned address */	word seg;         /* segment addr of unaligned address */	void *addr_alig; /* aligned address */	int rem; /* temp for alignment computation */	/* ensure that allocation table is not full */	if (num_alloc >= MAX_ALLOC) {		return(NULL);	}	/* find free entry in allocation table */	ix_save = alloc_ix;	while (alloc_table[alloc_ix].original != NULL) {		alloc_ix++;		if (alloc_ix >= MAX_ALLOC) alloc_ix = 0;		/* safety check -- should never happen! */		if (alloc_ix == ix_save) return(NULL);	}	/* call allocation routine */	/* request 15 extra bytes to ensure alignment is possible */	addr = calloc(size + 15,1);	/* compute aligned base */	offset = FP_OFF(addr);        seg = FP_SEG(addr);	rem = offset % 16;	if (rem > 0) offset = offset + 16 - rem;	addr_alig = MK_FP(seg,offset);	/* insert entries in table */	alloc_table[alloc_ix].original = addr;	alloc_table[alloc_ix].aligned = addr_alig;	/* increment count */	num_alloc++;	return(addr_alig);}/*	Procedure: sys_free_mem	Purpose: free a memory block	Parameters:		void *ptr         ptr to block to allocate	Returns: integer error code; zero if OK		Calls:   free	Globals: alloc_table, num_alloc	Errors:  ERR_SUP_INVMEM    invalid memory block	This procedure receives an aligned address; it must	find and free the corresponding non-aligned one.*/int sys_free_mem (         void     *ptr     /* pointer to block */		 ){	void *free_addr;  /* true (unaligned) block address */	int free_ix;               /* temp table index */	/* ensure valid pointer */	if (ptr==NULL) return(ERR_SUP_INVMEM);	/* Look for the block in the allocation table */	free_addr = NULL;	for (free_ix=0; free_ix<MAX_ALLOC; free_ix++) {		if (alloc_table[free_ix].aligned == ptr) {			free_addr = alloc_table[free_ix].original;			break;		}	}	/* If the block wasn't found, report error */	if (free_addr == NULL) return(ERR_SUP_INVMEM);	/* free the block & clear the table entry */	alloc_table[free_ix].original = NULL;	alloc_table[free_ix].aligned = NULL;        free(free_addr);	/* decrement count */	num_alloc--;	return(OK);}        /*	Procedure: sys_get_date	Purpose: Returns the system date (month, day, year)	Parameters:		date_rec *date_p Pointer to structure of type date	Returns: void		Calls: none		Globals: sys_date        Errors: none*/void sys_get_date (  date_rec*      date_p   /* ptr to date record */		){	date_p->month = sys_date.da_mon;	date_p->day = sys_date.da_day;	date_p->year = sys_date.da_year;}/*	Procedure: sys_set_date	Purpose: Sets the system date (month, day, year)	Parameters:		date_rec *date_p ptr to structure of type date	Returns: error code; OK if no error	Calls:   none        Globals: sys_date	Errors: none*/int sys_set_date (  date_rec*       date_p   /* ptr to date record */		 ){	sys_date.da_mon = date_p->month;        sys_date.da_day = date_p->day;        sys_date.da_year = date_p->year;	return(OK);}/*	Procedure: sys_open_dir	Purpose: open a specified directory	Parameters: char dir_name[]            directory name	Returns: error code; zero if OK	Calls:   findfirst		strncpy  	Globals: current_path, file_block, num_entries	Errors:  ERR_SUP_DIROPN    directory open error		ERR_SUP_INVDIR    invalid directory*/int sys_open_dir (  char  path_name[]        /* directory name */		 ){        char temp_path[MAX_PATH_SIZE];	int res;        int len;        /* ensure there is no directory currently open */	if (current_path[0]!=NULCH) return(ERR_SUP_DIROPN);        /* check pathname for validity */        /* construct temporary search path name */	temp_path[0] = NULCH;	if (path_name != NULL) {		strncpy(temp_path,path_name,MAX_PATH_SIZE-4);	}	/* build wildcard search string */        len = strlen(temp_path);	/* if path is null, use current directory */        if (len==0) strcpy(temp_path,"*.*");	/* handle paths ending in backslash, including root */        else if (temp_path[len-1]=='\\') strcat(temp_path,"*.*");	/* handle paths not ending in backslash */        else strcat(temp_path,"\\*.*");	/* validate the directory by searching for either an ordinary	   file or a directory in it.  This should never fail; even	   empty directories contain the directories "." and ".."	*/		res = findfirst(temp_path, &file_block, FA_DIREC);	if (res!=0)  return(ERR_SUP_INVDIR);        /* save pathname as current, clear entry count */	current_path[0] = NULCH;	if (path_name != NULL) {		strncpy(current_path,path_name,MAX_PATH_SIZE-6);	}	num_entries = 0;	return(OK);}/*	Procedure: sys_get_entry	Purpose: get the next directory entry;	Parameters: char name_buf[]	name buffer		    int buf_size  	buffer capacity		    long *file_size_p	file length buffer         	Returns: error code, or zero if ok	Calls:	findfirst		findnext		strncpy, strcpy, strrchr, strcat    	Globals: current_path, num_entries, file_block	Errors:  ERR_SUP_NOENTR    no such entry*/int sys_get_entry (char    name_buf[],       /* buffer for entry */		   int   buf_size,         /* buffer size */		   long* file_size_p       /* buffer for size value */		  ){	char filename[MAX_PATH_SIZE+1];	int err;        int len;        char *cp;        /* find next MPX file entry, if any */        /* if this is the first call */	if (num_entries==0) {	       /* construct complete search path name */	       len = strlen(current_path);	       if (len==0) strcpy(current_path,"*.MPX");	       else if (current_path[len-1]=='\\') strcat(current_path,"*.MPX");	       else strcat(current_path,"\\*.MPX");	       /* find first entry */		err = findfirst (current_path,&file_block,0);        }        /* otherwise, find next entry */        else err = findnext(&file_block);        if (err<0) return(ERR_SUP_NOENTR);		/* ensure buf_size is not too large */		if (buf_size > MAX_PATH_SIZE) buf_size = MAX_PATH_SIZE;		      /* copy filename to buffer */	filename[buf_size] = NULCH;	strncpy (filename,file_block.ff_name,			 (size_t) buf_size);	/* remove ".MPX" from name */	cp = strrchr(filename, (int) '.');        *cp = NULCH;	/* copy name and size to caller's buffer */        strcpy (name_buf,filename);	*file_size_p = file_block.ff_fsize;        /* count entry */	num_entries++;	return(OK);}/*	Procedure: sys_close_dir	Purpose: close an open directory	Parameters: none	Returns: error code; zero if OK	Calls:   none	Globals: current_path	Errors:  none*/int sys_close_dir (void){	current_path[0] = NULCH;	return(OK);}/*	Procedure: sys_check_program	Purpose: locate and measure a program file	Parameters: see prototype	Returns: program size or error code	Calls:   strlen, strcat		fopen, fread	Globals: none	Errors:  ERR_SUP_NAMLNG    pathname too long		ERR_SUP_FILNFD    file not found		ERR_SUP_FILINV    file invalid*/#define HEADER_SIZE 32int sys_check_program(     char     dir_name[],       /* directory name */			char     prog_name[],      /* program name */			int*     prog_len_p,       /* ptr to prog length */			int*     start_offset_p    /* ptr to start offset */			){        /* buffer for full pathname */	char file_name[MAX_PATH_SIZE+1];        /* buffer for file header */        byte header[HEADER_SIZE];	FILE *file_p;     /* file pointer for C file routines */        int num_read;      /* number of header bytes read */	int file_size;    /* size of complete file */        int header_size;/* size of header */        int code_size;     /* size of program code */        int data_size;     /* size of program data */        int errcode;       /* error code */        /* ensure that path name is not too long */        if ((strlen(dir_name) + strlen(prog_name) + 5)		 > MAX_PATH_SIZE) return(ERR_SUP_NAMLNG);	/* construct path name */	file_name[0] = NULCH;	if (dir_name[0] != NULCH) {		strcat(file_name, dir_name);	        strcat(file_name, "\\");	}        strcat(file_name, prog_name);	strcat(file_name, ".MPX");        /* try to open the file */	errcode = OK;        file_p = fopen(file_name, "rb");        if (file_p == NULL) return(ERR_SUP_FILNFD);	/* read the header, check for EXE signature */        num_read = fread( (void*) header, 1, HEADER_SIZE, file_p);        if (num_read != HEADER_SIZE) {		errcode = ERR_SUP_FILINV;	}        else if ((header[0] != 0x4D) || (header[1] != 0x5A)) {		errcode = ERR_SUP_FILINV;	}        /* close the file, then return if error occurred */        fclose(file_p);	if (errcode!=OK) return(errcode);        /* compute allocation size needed */        file_size = (header[5]*256 + header[4] -1) * 512		+ (header[3]*256 + header[2]);        header_size =(header[9]*256 + header[8])*16;        code_size = file_size - header_size;        data_size = (header[11]*256 + header[10])*16;        /* return total length and starting offset */        *prog_len_p = code_size + data_size;	*start_offset_p = (header[23]*256 + header[22]) * 16;	return(OK);}/*	Procedure: sys_load_program	Purpose: load a program file	Parameters: see prototype	Returns: error code; zero if OK	Calls:   intdosx		segread		strlen, strcat	Globals: none 	Errors:  ERR_SUP_NAMLNG    name too long		ERR_SUP_FILNFD    file not found	       ERR_SUP_FILINV      file invalid		ERR_SUP_PROGSZ    program too large	       ERR_SUP_LDADDR      address not aligned		ERR_SUP_LDFAIL    load failed*/int sys_load_program (     void*    load_addr,        /* address for loading */			int      max_size,         /* memory size */			char     dir_name[],       /* directory name */			char     prog_name[]       /* program name */		      ){	int errcode;      /* error code */        int prog_len;      /* program length */	int offset;       /* offset for starting */	word norm_seg;    /* normalized load address segment */        word norm_off;     /* normalized load address offset */        /* full pathname for file to be loaded */	char file_name[MAX_PATH_SIZE+1];        /* parameter block for MSDOS EXEC function */	struct {		word load_seg;    /* segment address for loading */	       word reloc_seg;     /* segment address for relocation */        }p_block;	union REGS inregs;            /* input register structure */	union REGS outregs;           /* output register structure */	struct SREGS segregs;         /* segment register structure */        /* check program, get length and offset */	errcode = sys_check_program(dir_name, prog_name,					&prog_len, &offset);        if (errcode < 0) return(errcode);        /* ensure that allocated memory is large enough */        if (max_size < prog_len) return(ERR_SUP_PROGSZ);        /* get normalized segment and offset, check alignment */	norm_seg = FP_SEG(load_addr);	norm_off = FP_OFF(load_addr);	norm_seg += norm_off / 16;        norm_off %= 16;	if (norm_off != 0) return(ERR_SUP_LDADDR);        /* ensure that path name is not too long */        if ((strlen(dir_name) + strlen(prog_name) + 5)		 > MAX_PATH_SIZE) return(ERR_SUP_NAMLNG);	/* construct path name */	file_name[0] = NULCH;	if (dir_name[0] != NULCH) {		strcat(file_name, dir_name);	        strcat(file_name, "\\");	}        strcat(file_name, prog_name);	strcat(file_name, ".MPX");        /* get current segment regs */	segread(&segregs);        /* setup function codes */	inregs.h.ah = 0x4B;        /* EXEC function */	inregs.h.al = 0x03;        /* load only */        /* setup parameter block and name pointers */        segregs.ds = FP_SEG(&file_name);	inregs.x.dx = FP_OFF(&file_name);        segregs.es = FP_SEG(&p_block);	inregs.x.bx = FP_OFF(&p_block);        /* setup load segment -- must be normalized */	p_block.load_seg = norm_seg;	p_block.reloc_seg = p_block.load_seg;        /* call the MS-DOS loader */	errcode = intdosx(&inregs,&outregs,&segregs);        errcode = errcode;        /* check for error */	if (outregs.x.cflag) return(ERR_SUP_LDFAIL);	/* load successful */	return(OK);}/* END OF FILE */word1,0
/***********************************************************************	MPX: The MultiProgramming eXecutive	Project to Accompany	A Practical Approach to Operating Systems	Malcolm G. Lane & James D. Mooney	Copyright 1993, P.W.S. Kent Publishing Co., Boston, MA.		File Name: mpx_supt.c	Authors: J.J. Patnesky, A. Ghosal, M. Lane, J. Mooney	Version: 2.1b	Date: 01/31/08	Purpose: Support routines for MPX-PC		Modules: all	Environment:      IBM-PC (XT, AT or PS/2)			MS-DOS 3.3 or later			TURBO-C 3.0 or TURBO-C++ 1.0 or later	Compile using the LARGE MODEL and SS NOT equal to DS.	All addresses and pointers are "far", and	CS, DS and SS are independent.	Procedures in this file:		sys_init		sys_exit		sys_set_vec		sys_req		sys_alloc_mem		sys_free_mem		sys_get_date		sys_set_date		sys_open_dir		sys_get_entry		sys_close_dir	       sys_check_program	       sys_load_program************************************************************************Change Log:	07/16/88  akg	added comments	02/25/92  jdm	full revision, UNIX version	04/14/92  jdm	Macintosh version	05/15/92  jdm	cleanup and documentation	07/14/92  jdm	update for revised specs        08/13/92  jdm 	revised IBM version; added private heap        10/14/92  jdm 	added check and load procedures        10/18/92  jdm 	revised sys_alloc_mem for alignment	11/17/92  jdm	true heap mgt, aligned, using calloc & free	11/19/92  jdm	enable device handling for final module	12/31/92  jdm	revised sys_req parameters	01/02/93  jdm	return count value after I/O	01/03/93  jdm	revised error names and codes	01/27/93  jdm	corrected count for line input in sys_req			fixed open_dir to handle null lines	02/24/93  jdm	changed sys_set_vec param to interrupt	03/08/93  jdm	corrections to sys_check & sys_load	03/20/93  jdm	stack switch in free, check, and load	04/22/93  jdm	corrected index conflict in sys_free_mem			added safety escape in alloc table search	07/28/93  jdm	conversion to large model	09/01/93  jdm	fixed allocation bug;  made date private	09/14/93  jdm	cleaned up memory allocation        09/16/93  jdm	adjusted program load for large model        09/30/93  jdm	modified for correct list of root directory	11/01/94  jdm	changed load file read to binary	09/18/95  jdm	fixed get_entry to default to current, not root	01/31/08  jdm   fixed possible overflow problem in get_entry************************************************************************/#include "mpx_supt.h"#include <stdlib.h>#include <dos.h>#include <dir.h>#include <errno.h>#include <conio.h>#include <alloc.h>#define VEC_ADDR (0x60L*4)#define MAX_ALLOC 200#define MAX_XPOS 79#define MAX_YPOS 24#define MAX_PATH_SIZE 50/*	System-dependent type definitions*/typedef unsigned char byte;typedef unsigned int word;typedef unsigned long longword;typedef byte *address;typedef struct params {	int      op_code;	int      device_id;	char     *buf_p;	int      *count_p;	} params;/*	Global variables accessed only by support routines*/	static longword vec_save;  /* saved interrupt vector */	static int mod_code;                /* module code */                                           	static struct date sys_date;        /* MPX system date */	/* data structures for directory access */        static char current_path[MAX_PATH_SIZE+1];        static int num_entries;        static struct ffblk file_block;        /* handler presence flags */	static flag sysc_hand;	static flag trm_hand;	static flag prt_hand;	static flag com_hand;        /* memory allocation table */	static struct {		void* original;		void* aligned;	} alloc_table[MAX_ALLOC];	static int alloc_ix;                /* current index */	static int num_alloc;               /* no. of allocated blocks *//*	Procedure: sys_init	Purpose: initialize mpx	Parameters: see prototype  	Return value: error code, or OK if no error	Calls: getdate    	Globals: mod_code		vec_save		sys_date		alloc_table, alloc_ix, num_alloc		sysc_hand, term_hand, prt_hand, com_hand	Errors: none*/int sys_init (    int      modules  /* module code */	     ){	mod_code = modules;        vec_save = 0L;        /* no handlers detected yet */	sysc_hand = FALSE;	trm_hand = FALSE;	prt_hand = FALSE;	com_hand = FALSE;	/* initialize allocation table */	for (alloc_ix=0; alloc_ix < MAX_ALLOC; alloc_ix++) {		alloc_table[alloc_ix].original = NULL;		alloc_table[alloc_ix].aligned = NULL;	}	alloc_ix = 0;	num_alloc = 0;	/* if we have reached Module R3, enable system call handling */	if (modules >= MODULE_R3) sysc_hand = TRUE;	/* if we have reached the final module, enable device handlers */	if (modules >= MODULE_F) {		trm_hand = TRUE;		prt_hand = TRUE;		com_hand = TRUE;	}	/* get system date */        getdate(&sys_date);	return (OK);}/*	Procedure: sys_exit	Purpose: terminate mpx	Parameters: none  	Return value: none	Calls: none       	Globals: vec_save*/void sys_exit(void){	longword *vec_p;	/* if trap vector changed, restore it */	if (vec_save != 0L) {		vec_p = (longword*) VEC_ADDR;		*vec_p = vec_save;	}	/* return to host with null error code */	exit(0);}/*	Procedure: sys_set_vec	Purpose: link trap vector to MPX system call handler	Parameters: handler: addr of handler         	Return value: error code; OK if no error	Calls: none       	Globals: vec_save	Errors: none*/int sys_set_vec   ( void interrupt (*handler)() /* system call handler */		){	longword *vec_p;			vec_p = (longword*) VEC_ADDR;		vec_save = *vec_p;		*vec_p = (longword) handler;	return (0);}/*	Procedure: sys_req	Purpose: Request a system service	Inputs:		op_code           operation code		device_id         device identifier		buf_p             addresso f data buffer		count_p           address of size of buffer	Returns: Result or error code, depending on service		Services supported:	IDLE     null operation				READ     input from a device				WRITE    output to a device				CLEAR    clear terminal screen				GOTOXY   absolute cursor position				EXIT     terminate the caller	Calls:   fgets		strlen			Globals: none		Errors:  ERR_SUP_INVDEV    invalid device		ERR_SUP_INVOPC    invalid operation code		ERR_SUP_INVPOS    invalid character position		ERR_SUP_RDFAIL    read failed		ERR_SUP_WRFAIL    write failed	Description:	For Modules R1 through R4,	this procedure is used only for terminal I/O.	Later modules support both reading and	writing for several devices.	For Modules R1 through R4,	sys_req uses the ANSI C function "fgets."	Later modules may use alternate functions and device drivers.*/int sys_req (   int      op_code, /* operation code */		int      device_id,        /* device id */		char*    buf_p,            /* I/O buffer */		int*     count_p           /* address of count */		){	int      rval;    /* result or error code */	char     *rp;     /* return pointer for fgets */	char     rc;      /* return char for fputc */        params    *param_p; /* pointer to parameter record in stack */	flag     docall;  /* true if system call interrupt wanted */	int      ix;      /* temporary index */	docall = FALSE;	rval = OK;	switch (op_code) {		case IDLE:		if (sysc_hand) docall = TRUE;		break; 				case READ:		switch (device_id) {				case TERMINAL:			if (trm_hand) docall = TRUE;			else {				rp = fgets(buf_p,*count_p,stdin);				if (rp==NULL) rval = ERR_SUP_RDFAIL;				else rval = strlen(buf_p);			}			break;					case COM_PORT:			if (com_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					default:			rval = ERR_SUP_INVDEV;					}		break;	case WRITE:		switch (device_id) {				case TERMINAL:			if (trm_hand) docall = TRUE;			else {				rval = *count_p;				for (ix=0; ix<*count_p; ix++) {					rc = fputc(buf_p[ix],stdout);					if (rc == EOF) {						rval = ERR_SUP_WRFAIL;						break;					}				}			}			break;					case COM_PORT:			if (com_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					case PRINTER:			if (prt_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					default:			rval = ERR_SUP_INVDEV;					}		break;	case CLEAR:		if (device_id==TERMINAL) {			if (trm_hand) docall = TRUE;			else {			     clrscr();				rval = 0;			}		}		else rval = ERR_SUP_INVDEV;		break;			case GOTOXY:		if (device_id==TERMINAL) {			if (trm_hand) docall = TRUE;			else {				if (*count_p != 2) rval = ERR_SUP_WRFAIL;				else if ((*buf_p<0)					|| (*buf_p > MAX_XPOS))					rval = ERR_SUP_WRFAIL;				else if ((*(buf_p+1)<0)					|| (*(buf_p+1) > MAX_YPOS))					rval = ERR_SUP_WRFAIL;				else {					gotoxy(*buf_p + 1,						*(buf_p+1) + 1);					rval = 0;				}			}		}		else rval = ERR_SUP_INVDEV;		break;			/* EXIT - terminate the calling process */	/* legal only when a system call handler is present */	case EXIT:		if (sysc_hand) docall = TRUE;		else rval = ERR_SUP_INVOPC;		break; 	default:		rval = ERR_SUP_INVOPC;			}		/* Invoke user's call handler if present.	   If the call is an IO request, return will occur	   only after the request is complete.	*/	if (docall && (rval==OK)) {		/* invoke the call handler */	_SP = _SP - sizeof(params);		param_p = (params*) MK_FP(_SS,_SP);	       param_p->op_code = op_code;	       param_p->device_id = device_id;	       param_p->buf_p = buf_p;	       param_p->count_p = count_p;	       geninterrupt(0x60);	       rval = _AX;	       _SP = _SP + sizeof(params);		/* for I/O operations, return count value */		switch(op_code) {		case READ:		case WRITE:		case CLEAR:		case GOTOXY:			rval = *count_p;		}	}	return(rval);}/*	Procedure: sys_alloc_mem	Purpose: Allocate a memory block	Parameters:			size_t size       No. of bytes to allocate	Returns: void* pointer to allocated block;		 null pointer in case of error		 	Calls: calloc		Globals: alloc_table, alloc_ix, num_alloc	For program loading (Module R-4), the blocks must be aligned.	This is achieved by requesting one extra paragraph and	returning the lowest aligned address as the base.  It is	necessary to keep a table of allocated address, original and	aligned, to support correct freeing.	It would seem simpler to use the Turbo-C function allocmem,	which always allocates aligned blocks.  However, allocmem	appears to conflict with the internal allocation of fopen	and other C library routines.*/void *sys_alloc_mem (      size_t   size     /* size in bytes to allocate */		    ){	int ix_save;      /* temp copy of table index */        void *addr;        /* addr returned by calloc (*void) */	word offset;      /* offset of unaligned address */	word seg;         /* segment addr of unaligned address */	void *addr_alig; /* aligned address */	int rem; /* temp for alignment computation */	/* ensure that allocation table is not full */	if (num_alloc >= MAX_ALLOC) {		return(NULL);	}	/* find free entry in allocation table */	ix_save = alloc_ix;	while (alloc_table[alloc_ix].original != NULL) {		alloc_ix++;		if (alloc_ix >= MAX_ALLOC) alloc_ix = 0;		/* safety check -- should never happen! */		if (alloc_ix == ix_save) return(NULL);	}	/* call allocation routine */	/* request 15 extra bytes to ensure alignment is possible */	addr = calloc(size + 15,1);	/* compute aligned base */	offset = FP_OFF(addr);        seg = FP_SEG(addr);	rem = offset % 16;	if (rem > 0) offset = offset + 16 - rem;	addr_alig = MK_FP(seg,offset);	/* insert entries in table */	alloc_table[alloc_ix].original = addr;	alloc_table[alloc_ix].aligned = addr_alig;	/* increment count */	num_alloc++;	return(addr_alig);}/*	Procedure: sys_free_mem	Purpose: free a memory block	Parameters:		void *ptr         ptr to block to allocate	Returns: integer error code; zero if OK		Calls:   free	Globals: alloc_table, num_alloc	Errors:  ERR_SUP_INVMEM    invalid memory block	This procedure receives an aligned address; it must	find and free the corresponding non-aligned one.*/int sys_free_mem (         void     *ptr     /* pointer to block */		 ){	void *free_addr;  /* true (unaligned) block address */	int free_ix;               /* temp table index */	/* ensure valid pointer */	if (ptr==NULL) return(ERR_SUP_INVMEM);	/* Look for the block in the allocation table */	free_addr = NULL;	for (free_ix=0; free_ix<MAX_ALLOC; free_ix++) {		if (alloc_table[free_ix].aligned == ptr) {			free_addr = alloc_table[free_ix].original;			break;		}	}	/* If the block wasn't found, report error */	if (free_addr == NULL) return(ERR_SUP_INVMEM);	/* free the block & clear the table entry */	alloc_table[free_ix].original = NULL;	alloc_table[free_ix].aligned = NULL;        free(free_addr);	/* decrement count */	num_alloc--;	return(OK);}        /*	Procedure: sys_get_date	Purpose: Returns the system date (month, day, year)	Parameters:		date_rec *date_p Pointer to structure of type date	Returns: void		Calls: none		Globals: sys_date        Errors: none*/void sys_get_date (  date_rec*      date_p   /* ptr to date record */		){	date_p->month = sys_date.da_mon;	date_p->day = sys_date.da_day;	date_p->year = sys_date.da_year;}/*	Procedure: sys_set_date	Purpose: Sets the system date (month, day, year)	Parameters:		date_rec *date_p ptr to structure of type date	Returns: error code; OK if no error	Calls:   none        Globals: sys_date	Errors: none*/int sys_set_date (  date_rec*       date_p   /* ptr to date record */		 ){	sys_date.da_mon = date_p->month;        sys_date.da_day = date_p->day;        sys_date.da_year = date_p->year;	return(OK);}/*	Procedure: sys_open_dir	Purpose: open a specified directory	Parameters: char dir_name[]            directory name	Returns: error code; zero if OK	Calls:   findfirst		strncpy  	Globals: current_path, file_block, num_entries	Errors:  ERR_SUP_DIROPN    directory open error		ERR_SUP_INVDIR    invalid directory*/int sys_open_dir (  char  path_name[]        /* directory name */		 ){        char temp_path[MAX_PATH_SIZE];	int res;        int len;        /* ensure there is no directory currently open */	if (current_path[0]!=NULCH) return(ERR_SUP_DIROPN);        /* check pathname for validity */        /* construct temporary search path name */	temp_path[0] = NULCH;	if (path_name != NULL) {		strncpy(temp_path,path_name,MAX_PATH_SIZE-4);	}	/* build wildcard search string */        len = strlen(temp_path);	/* if path is null, use current directory */        if (len==0) strcpy(temp_path,"*.*");	/* handle paths ending in backslash, including root */        else if (temp_path[len-1]=='\\') strcat(temp_path,"*.*");	/* handle paths not ending in backslash */        else strcat(temp_path,"\\*.*");	/* validate the directory by searching for either an ordinary	   file or a directory in it.  This should never fail; even	   empty directories contain the directories "." and ".."	*/		res = findfirst(temp_path, &file_block, FA_DIREC);	if (res!=0)  return(ERR_SUP_INVDIR);        /* save pathname as current, clear entry count */	current_path[0] = NULCH;	if (path_name != NULL) {		strncpy(current_path,path_name,MAX_PATH_SIZE-6);	}	num_entries = 0;	return(OK);}/*	Procedure: sys_get_entry	Purpose: get the next directory entry;	Parameters: char name_buf[]	name buffer		    int buf_size  	buffer capacity		    long *file_size_p	file length buffer         	Returns: error code, or zero if ok	Calls:	findfirst		findnext		strncpy, strcpy, strrchr, strcat    	Globals: current_path, num_entries, file_block	Errors:  ERR_SUP_NOENTR    no such entry*/int sys_get_entry (char    name_buf[],       /* buffer for entry */		   int   buf_size,         /* buffer size */		   long* file_size_p       /* buffer for size value */		  ){	char filename[MAX_PATH_SIZE+1];	int err;        int len;        char *cp;        /* find next MPX file entry, if any */        /* if this is the first call */	if (num_entries==0) {	       /* construct complete search path name */	       len = strlen(current_path);	       if (len==0) strcpy(current_path,"*.MPX");	       else if (current_path[len-1]=='\\') strcat(current_path,"*.MPX");	       else strcat(current_path,"\\*.MPX");	       /* find first entry */		err = findfirst (current_path,&file_block,0);        }        /* otherwise, find next entry */        else err = findnext(&file_block);        if (err<0) return(ERR_SUP_NOENTR);		/* ensure buf_size is not too large */		if (buf_size > MAX_PATH_SIZE) buf_size = MAX_PATH_SIZE;		      /* copy filename to buffer */	filename[buf_size] = NULCH;	strncpy (filename,file_block.ff_name,			 (size_t) buf_size);	/* remove ".MPX" from name */	cp = strrchr(filename, (int) '.');        *cp = NULCH;	/* copy name and size to caller's buffer */        strcpy (name_buf,filename);	*file_size_p = file_block.ff_fsize;        /* count entry */	num_entries++;	return(OK);}/*	Procedure: sys_close_dir	Purpose: close an open directory	Parameters: none	Returns: error code; zero if OK	Calls:   none	Globals: current_path	Errors:  none*/int sys_close_dir (void){	current_path[0] = NULCH;	return(OK);}/*	Procedure: sys_check_program	Purpose: locate and measure a program file	Parameters: see prototype	Returns: program size or error code	Calls:   strlen, strcat		fopen, fread	Globals: none	Errors:  ERR_SUP_NAMLNG    pathname too long		ERR_SUP_FILNFD    file not found		ERR_SUP_FILINV    file invalid*/#define HEADER_SIZE 32int sys_check_program(     char     dir_name[],       /* directory name */			char     prog_name[],      /* program name */			int*     prog_len_p,       /* ptr to prog length */			int*     start_offset_p    /* ptr to start offset */			){        /* buffer for full pathname */	char file_name[MAX_PATH_SIZE+1];        /* buffer for file header */        byte header[HEADER_SIZE];	FILE *file_p;     /* file pointer for C file routines */        int num_read;      /* number of header bytes read */	int file_size;    /* size of complete file */        int header_size;/* size of header */        int code_size;     /* size of program code */        int data_size;     /* size of program data */        int errcode;       /* error code */        /* ensure that path name is not too long */        if ((strlen(dir_name) + strlen(prog_name) + 5)		 > MAX_PATH_SIZE) return(ERR_SUP_NAMLNG);	/* construct path name */	file_name[0] = NULCH;	if (dir_name[0] != NULCH) {		strcat(file_name, dir_name);	        strcat(file_name, "\\");	}        strcat(file_name, prog_name);	strcat(file_name, ".MPX");        /* try to open the file */	errcode = OK;        file_p = fopen(file_name, "rb");        if (file_p == NULL) return(ERR_SUP_FILNFD);	/* read the header, check for EXE signature */        num_read = fread( (void*) header, 1, HEADER_SIZE, file_p);        if (num_read != HEADER_SIZE) {		errcode = ERR_SUP_FILINV;	}        else if ((header[0] != 0x4D) || (header[1] != 0x5A)) {		errcode = ERR_SUP_FILINV;	}        /* close the file, then return if error occurred */        fclose(file_p);	if (errcode!=OK) return(errcode);        /* compute allocation size needed */        file_size = (header[5]*256 + header[4] -1) * 512		+ (header[3]*256 + header[2]);        header_size =(header[9]*256 + header[8])*16;        code_size = file_size - header_size;        data_size = (header[11]*256 + header[10])*16;        /* return total length and starting offset */        *prog_len_p = code_size + data_size;	*start_offset_p = (header[23]*256 + header[22]) * 16;	return(OK);}/*	Procedure: sys_load_program	Purpose: load a program file	Parameters: see prototype	Returns: error code; zero if OK	Calls:   intdosx		segread		strlen, strcat	Globals: none 	Errors:  ERR_SUP_NAMLNG    name too long		ERR_SUP_FILNFD    file not found	       ERR_SUP_FILINV      file invalid		ERR_SUP_PROGSZ    program too large	       ERR_SUP_LDADDR      address not aligned		ERR_SUP_LDFAIL    load failed*/int sys_load_program (     void*    load_addr,        /* address for loading */			int      max_size,         /* memory size */			char     dir_name[],       /* directory name */			char     prog_name[]       /* program name */		      ){	int errcode;      /* error code */        int prog_len;      /* program length */	int offset;       /* offset for starting */	word norm_seg;    /* normalized load address segment */        word norm_off;     /* normalized load address offset */        /* full pathname for file to be loaded */	char file_name[MAX_PATH_SIZE+1];        /* parameter block for MSDOS EXEC function */	struct {		word load_seg;    /* segment address for loading */	       word reloc_seg;     /* segment address for relocation */        }p_block;	union REGS inregs;            /* input register structure */	union REGS outregs;           /* output register structure */	struct SREGS segregs;         /* segment register structure */        /* check program, get length and offset */	errcode = sys_check_program(dir_name, prog_name,					&prog_len, &offset);        if (errcode < 0) return(errcode);        /* ensure that allocated memory is large enough */        if (max_size < prog_len) return(ERR_SUP_PROGSZ);        /* get normalized segment and offset, check alignment */	norm_seg = FP_SEG(load_addr);	norm_off = FP_OFF(load_addr);	norm_seg += norm_off / 16;        norm_off %= 16;	if (norm_off != 0) return(ERR_SUP_LDADDR);        /* ensure that path name is not too long */        if ((strlen(dir_name) + strlen(prog_name) + 5)		 > MAX_PATH_SIZE) return(ERR_SUP_NAMLNG);	/* construct path name */	file_name[0] = NULCH;	if (dir_name[0] != NULCH) {		strcat(file_name, dir_name);	        strcat(file_name, "\\");	}        strcat(file_name, prog_name);	strcat(file_name, ".MPX");        /* get current segment regs */	segread(&segregs);        /* setup function codes */	inregs.h.ah = 0x4B;        /* EXEC function */	inregs.h.al = 0x03;        /* load only */        /* setup parameter block and name pointers */        segregs.ds = FP_SEG(&file_name);	inregs.x.dx = FP_OFF(&file_name);        segregs.es = FP_SEG(&p_block);	inregs.x.bx = FP_OFF(&p_block);        /* setup load segment -- must be normalized */	p_block.load_seg = norm_seg;	p_block.reloc_seg = p_block.load_seg;        /* call the MS-DOS loader */	errcode = intdosx(&inregs,&outregs,&segregs);        errcode = errcode;        /* check for error */	if (outregs.x.cflag) return(ERR_SUP_LDFAIL);	/* load successful */	return(OK);}/* END OF FILE */longword1,0
/***********************************************************************	MPX: The MultiProgramming eXecutive	Project to Accompany	A Practical Approach to Operating Systems	Malcolm G. Lane & James D. Mooney	Copyright 1993, P.W.S. Kent Publishing Co., Boston, MA.		File Name: mpx_supt.c	Authors: J.J. Patnesky, A. Ghosal, M. Lane, J. Mooney	Version: 2.1b	Date: 01/31/08	Purpose: Support routines for MPX-PC		Modules: all	Environment:      IBM-PC (XT, AT or PS/2)			MS-DOS 3.3 or later			TURBO-C 3.0 or TURBO-C++ 1.0 or later	Compile using the LARGE MODEL and SS NOT equal to DS.	All addresses and pointers are "far", and	CS, DS and SS are independent.	Procedures in this file:		sys_init		sys_exit		sys_set_vec		sys_req		sys_alloc_mem		sys_free_mem		sys_get_date		sys_set_date		sys_open_dir		sys_get_entry		sys_close_dir	       sys_check_program	       sys_load_program************************************************************************Change Log:	07/16/88  akg	added comments	02/25/92  jdm	full revision, UNIX version	04/14/92  jdm	Macintosh version	05/15/92  jdm	cleanup and documentation	07/14/92  jdm	update for revised specs        08/13/92  jdm 	revised IBM version; added private heap        10/14/92  jdm 	added check and load procedures        10/18/92  jdm 	revised sys_alloc_mem for alignment	11/17/92  jdm	true heap mgt, aligned, using calloc & free	11/19/92  jdm	enable device handling for final module	12/31/92  jdm	revised sys_req parameters	01/02/93  jdm	return count value after I/O	01/03/93  jdm	revised error names and codes	01/27/93  jdm	corrected count for line input in sys_req			fixed open_dir to handle null lines	02/24/93  jdm	changed sys_set_vec param to interrupt	03/08/93  jdm	corrections to sys_check & sys_load	03/20/93  jdm	stack switch in free, check, and load	04/22/93  jdm	corrected index conflict in sys_free_mem			added safety escape in alloc table search	07/28/93  jdm	conversion to large model	09/01/93  jdm	fixed allocation bug;  made date private	09/14/93  jdm	cleaned up memory allocation        09/16/93  jdm	adjusted program load for large model        09/30/93  jdm	modified for correct list of root directory	11/01/94  jdm	changed load file read to binary	09/18/95  jdm	fixed get_entry to default to current, not root	01/31/08  jdm   fixed possible overflow problem in get_entry************************************************************************/#include "mpx_supt.h"#include <stdlib.h>#include <dos.h>#include <dir.h>#include <errno.h>#include <conio.h>#include <alloc.h>#define VEC_ADDR (0x60L*4)#define MAX_ALLOC 200#define MAX_XPOS 79#define MAX_YPOS 24#define MAX_PATH_SIZE 50/*	System-dependent type definitions*/typedef unsigned char byte;typedef unsigned int word;typedef unsigned long longword;typedef byte *address;typedef struct params {	int      op_code;	int      device_id;	char     *buf_p;	int      *count_p;	} params;/*	Global variables accessed only by support routines*/	static longword vec_save;  /* saved interrupt vector */	static int mod_code;                /* module code */                                           	static struct date sys_date;        /* MPX system date */	/* data structures for directory access */        static char current_path[MAX_PATH_SIZE+1];        static int num_entries;        static struct ffblk file_block;        /* handler presence flags */	static flag sysc_hand;	static flag trm_hand;	static flag prt_hand;	static flag com_hand;        /* memory allocation table */	static struct {		void* original;		void* aligned;	} alloc_table[MAX_ALLOC];	static int alloc_ix;                /* current index */	static int num_alloc;               /* no. of allocated blocks *//*	Procedure: sys_init	Purpose: initialize mpx	Parameters: see prototype  	Return value: error code, or OK if no error	Calls: getdate    	Globals: mod_code		vec_save		sys_date		alloc_table, alloc_ix, num_alloc		sysc_hand, term_hand, prt_hand, com_hand	Errors: none*/int sys_init (    int      modules  /* module code */	     ){	mod_code = modules;        vec_save = 0L;        /* no handlers detected yet */	sysc_hand = FALSE;	trm_hand = FALSE;	prt_hand = FALSE;	com_hand = FALSE;	/* initialize allocation table */	for (alloc_ix=0; alloc_ix < MAX_ALLOC; alloc_ix++) {		alloc_table[alloc_ix].original = NULL;		alloc_table[alloc_ix].aligned = NULL;	}	alloc_ix = 0;	num_alloc = 0;	/* if we have reached Module R3, enable system call handling */	if (modules >= MODULE_R3) sysc_hand = TRUE;	/* if we have reached the final module, enable device handlers */	if (modules >= MODULE_F) {		trm_hand = TRUE;		prt_hand = TRUE;		com_hand = TRUE;	}	/* get system date */        getdate(&sys_date);	return (OK);}/*	Procedure: sys_exit	Purpose: terminate mpx	Parameters: none  	Return value: none	Calls: none       	Globals: vec_save*/void sys_exit(void){	longword *vec_p;	/* if trap vector changed, restore it */	if (vec_save != 0L) {		vec_p = (longword*) VEC_ADDR;		*vec_p = vec_save;	}	/* return to host with null error code */	exit(0);}/*	Procedure: sys_set_vec	Purpose: link trap vector to MPX system call handler	Parameters: handler: addr of handler         	Return value: error code; OK if no error	Calls: none       	Globals: vec_save	Errors: none*/int sys_set_vec   ( void interrupt (*handler)() /* system call handler */		){	longword *vec_p;			vec_p = (longword*) VEC_ADDR;		vec_save = *vec_p;		*vec_p = (longword) handler;	return (0);}/*	Procedure: sys_req	Purpose: Request a system service	Inputs:		op_code           operation code		device_id         device identifier		buf_p             addresso f data buffer		count_p           address of size of buffer	Returns: Result or error code, depending on service		Services supported:	IDLE     null operation				READ     input from a device				WRITE    output to a device				CLEAR    clear terminal screen				GOTOXY   absolute cursor position				EXIT     terminate the caller	Calls:   fgets		strlen			Globals: none		Errors:  ERR_SUP_INVDEV    invalid device		ERR_SUP_INVOPC    invalid operation code		ERR_SUP_INVPOS    invalid character position		ERR_SUP_RDFAIL    read failed		ERR_SUP_WRFAIL    write failed	Description:	For Modules R1 through R4,	this procedure is used only for terminal I/O.	Later modules support both reading and	writing for several devices.	For Modules R1 through R4,	sys_req uses the ANSI C function "fgets."	Later modules may use alternate functions and device drivers.*/int sys_req (   int      op_code, /* operation code */		int      device_id,        /* device id */		char*    buf_p,            /* I/O buffer */		int*     count_p           /* address of count */		){	int      rval;    /* result or error code */	char     *rp;     /* return pointer for fgets */	char     rc;      /* return char for fputc */        params    *param_p; /* pointer to parameter record in stack */	flag     docall;  /* true if system call interrupt wanted */	int      ix;      /* temporary index */	docall = FALSE;	rval = OK;	switch (op_code) {		case IDLE:		if (sysc_hand) docall = TRUE;		break; 				case READ:		switch (device_id) {				case TERMINAL:			if (trm_hand) docall = TRUE;			else {				rp = fgets(buf_p,*count_p,stdin);				if (rp==NULL) rval = ERR_SUP_RDFAIL;				else rval = strlen(buf_p);			}			break;					case COM_PORT:			if (com_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					default:			rval = ERR_SUP_INVDEV;					}		break;	case WRITE:		switch (device_id) {				case TERMINAL:			if (trm_hand) docall = TRUE;			else {				rval = *count_p;				for (ix=0; ix<*count_p; ix++) {					rc = fputc(buf_p[ix],stdout);					if (rc == EOF) {						rval = ERR_SUP_WRFAIL;						break;					}				}			}			break;					case COM_PORT:			if (com_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					case PRINTER:			if (prt_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					default:			rval = ERR_SUP_INVDEV;					}		break;	case CLEAR:		if (device_id==TERMINAL) {			if (trm_hand) docall = TRUE;			else {			     clrscr();				rval = 0;			}		}		else rval = ERR_SUP_INVDEV;		break;			case GOTOXY:		if (device_id==TERMINAL) {			if (trm_hand) docall = TRUE;			else {				if (*count_p != 2) rval = ERR_SUP_WRFAIL;				else if ((*buf_p<0)					|| (*buf_p > MAX_XPOS))					rval = ERR_SUP_WRFAIL;				else if ((*(buf_p+1)<0)					|| (*(buf_p+1) > MAX_YPOS))					rval = ERR_SUP_WRFAIL;				else {					gotoxy(*buf_p + 1,						*(buf_p+1) + 1);					rval = 0;				}			}		}		else rval = ERR_SUP_INVDEV;		break;			/* EXIT - terminate the calling process */	/* legal only when a system call handler is present */	case EXIT:		if (sysc_hand) docall = TRUE;		else rval = ERR_SUP_INVOPC;		break; 	default:		rval = ERR_SUP_INVOPC;			}		/* Invoke user's call handler if present.	   If the call is an IO request, return will occur	   only after the request is complete.	*/	if (docall && (rval==OK)) {		/* invoke the call handler */	_SP = _SP - sizeof(params);		param_p = (params*) MK_FP(_SS,_SP);	       param_p->op_code = op_code;	       param_p->device_id = device_id;	       param_p->buf_p = buf_p;	       param_p->count_p = count_p;	       geninterrupt(0x60);	       rval = _AX;	       _SP = _SP + sizeof(params);		/* for I/O operations, return count value */		switch(op_code) {		case READ:		case WRITE:		case CLEAR:		case GOTOXY:			rval = *count_p;		}	}	return(rval);}/*	Procedure: sys_alloc_mem	Purpose: Allocate a memory block	Parameters:			size_t size       No. of bytes to allocate	Returns: void* pointer to allocated block;		 null pointer in case of error		 	Calls: calloc		Globals: alloc_table, alloc_ix, num_alloc	For program loading (Module R-4), the blocks must be aligned.	This is achieved by requesting one extra paragraph and	returning the lowest aligned address as the base.  It is	necessary to keep a table of allocated address, original and	aligned, to support correct freeing.	It would seem simpler to use the Turbo-C function allocmem,	which always allocates aligned blocks.  However, allocmem	appears to conflict with the internal allocation of fopen	and other C library routines.*/void *sys_alloc_mem (      size_t   size     /* size in bytes to allocate */		    ){	int ix_save;      /* temp copy of table index */        void *addr;        /* addr returned by calloc (*void) */	word offset;      /* offset of unaligned address */	word seg;         /* segment addr of unaligned address */	void *addr_alig; /* aligned address */	int rem; /* temp for alignment computation */	/* ensure that allocation table is not full */	if (num_alloc >= MAX_ALLOC) {		return(NULL);	}	/* find free entry in allocation table */	ix_save = alloc_ix;	while (alloc_table[alloc_ix].original != NULL) {		alloc_ix++;		if (alloc_ix >= MAX_ALLOC) alloc_ix = 0;		/* safety check -- should never happen! */		if (alloc_ix == ix_save) return(NULL);	}	/* call allocation routine */	/* request 15 extra bytes to ensure alignment is possible */	addr = calloc(size + 15,1);	/* compute aligned base */	offset = FP_OFF(addr);        seg = FP_SEG(addr);	rem = offset % 16;	if (rem > 0) offset = offset + 16 - rem;	addr_alig = MK_FP(seg,offset);	/* insert entries in table */	alloc_table[alloc_ix].original = addr;	alloc_table[alloc_ix].aligned = addr_alig;	/* increment count */	num_alloc++;	return(addr_alig);}/*	Procedure: sys_free_mem	Purpose: free a memory block	Parameters:		void *ptr         ptr to block to allocate	Returns: integer error code; zero if OK		Calls:   free	Globals: alloc_table, num_alloc	Errors:  ERR_SUP_INVMEM    invalid memory block	This procedure receives an aligned address; it must	find and free the corresponding non-aligned one.*/int sys_free_mem (         void     *ptr     /* pointer to block */		 ){	void *free_addr;  /* true (unaligned) block address */	int free_ix;               /* temp table index */	/* ensure valid pointer */	if (ptr==NULL) return(ERR_SUP_INVMEM);	/* Look for the block in the allocation table */	free_addr = NULL;	for (free_ix=0; free_ix<MAX_ALLOC; free_ix++) {		if (alloc_table[free_ix].aligned == ptr) {			free_addr = alloc_table[free_ix].original;			break;		}	}	/* If the block wasn't found, report error */	if (free_addr == NULL) return(ERR_SUP_INVMEM);	/* free the block & clear the table entry */	alloc_table[free_ix].original = NULL;	alloc_table[free_ix].aligned = NULL;        free(free_addr);	/* decrement count */	num_alloc--;	return(OK);}        /*	Procedure: sys_get_date	Purpose: Returns the system date (month, day, year)	Parameters:		date_rec *date_p Pointer to structure of type date	Returns: void		Calls: none		Globals: sys_date        Errors: none*/void sys_get_date (  date_rec*      date_p   /* ptr to date record */		){	date_p->month = sys_date.da_mon;	date_p->day = sys_date.da_day;	date_p->year = sys_date.da_year;}/*	Procedure: sys_set_date	Purpose: Sets the system date (month, day, year)	Parameters:		date_rec *date_p ptr to structure of type date	Returns: error code; OK if no error	Calls:   none        Globals: sys_date	Errors: none*/int sys_set_date (  date_rec*       date_p   /* ptr to date record */		 ){	sys_date.da_mon = date_p->month;        sys_date.da_day = date_p->day;        sys_date.da_year = date_p->year;	return(OK);}/*	Procedure: sys_open_dir	Purpose: open a specified directory	Parameters: char dir_name[]            directory name	Returns: error code; zero if OK	Calls:   findfirst		strncpy  	Globals: current_path, file_block, num_entries	Errors:  ERR_SUP_DIROPN    directory open error		ERR_SUP_INVDIR    invalid directory*/int sys_open_dir (  char  path_name[]        /* directory name */		 ){        char temp_path[MAX_PATH_SIZE];	int res;        int len;        /* ensure there is no directory currently open */	if (current_path[0]!=NULCH) return(ERR_SUP_DIROPN);        /* check pathname for validity */        /* construct temporary search path name */	temp_path[0] = NULCH;	if (path_name != NULL) {		strncpy(temp_path,path_name,MAX_PATH_SIZE-4);	}	/* build wildcard search string */        len = strlen(temp_path);	/* if path is null, use current directory */        if (len==0) strcpy(temp_path,"*.*");	/* handle paths ending in backslash, including root */        else if (temp_path[len-1]=='\\') strcat(temp_path,"*.*");	/* handle paths not ending in backslash */        else strcat(temp_path,"\\*.*");	/* validate the directory by searching for either an ordinary	   file or a directory in it.  This should never fail; even	   empty directories contain the directories "." and ".."	*/		res = findfirst(temp_path, &file_block, FA_DIREC);	if (res!=0)  return(ERR_SUP_INVDIR);        /* save pathname as current, clear entry count */	current_path[0] = NULCH;	if (path_name != NULL) {		strncpy(current_path,path_name,MAX_PATH_SIZE-6);	}	num_entries = 0;	return(OK);}/*	Procedure: sys_get_entry	Purpose: get the next directory entry;	Parameters: char name_buf[]	name buffer		    int buf_size  	buffer capacity		    long *file_size_p	file length buffer         	Returns: error code, or zero if ok	Calls:	findfirst		findnext		strncpy, strcpy, strrchr, strcat    	Globals: current_path, num_entries, file_block	Errors:  ERR_SUP_NOENTR    no such entry*/int sys_get_entry (char    name_buf[],       /* buffer for entry */		   int   buf_size,         /* buffer size */		   long* file_size_p       /* buffer for size value */		  ){	char filename[MAX_PATH_SIZE+1];	int err;        int len;        char *cp;        /* find next MPX file entry, if any */        /* if this is the first call */	if (num_entries==0) {	       /* construct complete search path name */	       len = strlen(current_path);	       if (len==0) strcpy(current_path,"*.MPX");	       else if (current_path[len-1]=='\\') strcat(current_path,"*.MPX");	       else strcat(current_path,"\\*.MPX");	       /* find first entry */		err = findfirst (current_path,&file_block,0);        }        /* otherwise, find next entry */        else err = findnext(&file_block);        if (err<0) return(ERR_SUP_NOENTR);		/* ensure buf_size is not too large */		if (buf_size > MAX_PATH_SIZE) buf_size = MAX_PATH_SIZE;		      /* copy filename to buffer */	filename[buf_size] = NULCH;	strncpy (filename,file_block.ff_name,			 (size_t) buf_size);	/* remove ".MPX" from name */	cp = strrchr(filename, (int) '.');        *cp = NULCH;	/* copy name and size to caller's buffer */        strcpy (name_buf,filename);	*file_size_p = file_block.ff_fsize;        /* count entry */	num_entries++;	return(OK);}/*	Procedure: sys_close_dir	Purpose: close an open directory	Parameters: none	Returns: error code; zero if OK	Calls:   none	Globals: current_path	Errors:  none*/int sys_close_dir (void){	current_path[0] = NULCH;	return(OK);}/*	Procedure: sys_check_program	Purpose: locate and measure a program file	Parameters: see prototype	Returns: program size or error code	Calls:   strlen, strcat		fopen, fread	Globals: none	Errors:  ERR_SUP_NAMLNG    pathname too long		ERR_SUP_FILNFD    file not found		ERR_SUP_FILINV    file invalid*/#define HEADER_SIZE 32int sys_check_program(     char     dir_name[],       /* directory name */			char     prog_name[],      /* program name */			int*     prog_len_p,       /* ptr to prog length */			int*     start_offset_p    /* ptr to start offset */			){        /* buffer for full pathname */	char file_name[MAX_PATH_SIZE+1];        /* buffer for file header */        byte header[HEADER_SIZE];	FILE *file_p;     /* file pointer for C file routines */        int num_read;      /* number of header bytes read */	int file_size;    /* size of complete file */        int header_size;/* size of header */        int code_size;     /* size of program code */        int data_size;     /* size of program data */        int errcode;       /* error code */        /* ensure that path name is not too long */        if ((strlen(dir_name) + strlen(prog_name) + 5)		 > MAX_PATH_SIZE) return(ERR_SUP_NAMLNG);	/* construct path name */	file_name[0] = NULCH;	if (dir_name[0] != NULCH) {		strcat(file_name, dir_name);	        strcat(file_name, "\\");	}        strcat(file_name, prog_name);	strcat(file_name, ".MPX");        /* try to open the file */	errcode = OK;        file_p = fopen(file_name, "rb");        if (file_p == NULL) return(ERR_SUP_FILNFD);	/* read the header, check for EXE signature */        num_read = fread( (void*) header, 1, HEADER_SIZE, file_p);        if (num_read != HEADER_SIZE) {		errcode = ERR_SUP_FILINV;	}        else if ((header[0] != 0x4D) || (header[1] != 0x5A)) {		errcode = ERR_SUP_FILINV;	}        /* close the file, then return if error occurred */        fclose(file_p);	if (errcode!=OK) return(errcode);        /* compute allocation size needed */        file_size = (header[5]*256 + header[4] -1) * 512		+ (header[3]*256 + header[2]);        header_size =(header[9]*256 + header[8])*16;        code_size = file_size - header_size;        data_size = (header[11]*256 + header[10])*16;        /* return total length and starting offset */        *prog_len_p = code_size + data_size;	*start_offset_p = (header[23]*256 + header[22]) * 16;	return(OK);}/*	Procedure: sys_load_program	Purpose: load a program file	Parameters: see prototype	Returns: error code; zero if OK	Calls:   intdosx		segread		strlen, strcat	Globals: none 	Errors:  ERR_SUP_NAMLNG    name too long		ERR_SUP_FILNFD    file not found	       ERR_SUP_FILINV      file invalid		ERR_SUP_PROGSZ    program too large	       ERR_SUP_LDADDR      address not aligned		ERR_SUP_LDFAIL    load failed*/int sys_load_program (     void*    load_addr,        /* address for loading */			int      max_size,         /* memory size */			char     dir_name[],       /* directory name */			char     prog_name[]       /* program name */		      ){	int errcode;      /* error code */        int prog_len;      /* program length */	int offset;       /* offset for starting */	word norm_seg;    /* normalized load address segment */        word norm_off;     /* normalized load address offset */        /* full pathname for file to be loaded */	char file_name[MAX_PATH_SIZE+1];        /* parameter block for MSDOS EXEC function */	struct {		word load_seg;    /* segment address for loading */	       word reloc_seg;     /* segment address for relocation */        }p_block;	union REGS inregs;            /* input register structure */	union REGS outregs;           /* output register structure */	struct SREGS segregs;         /* segment register structure */        /* check program, get length and offset */	errcode = sys_check_program(dir_name, prog_name,					&prog_len, &offset);        if (errcode < 0) return(errcode);        /* ensure that allocated memory is large enough */        if (max_size < prog_len) return(ERR_SUP_PROGSZ);        /* get normalized segment and offset, check alignment */	norm_seg = FP_SEG(load_addr);	norm_off = FP_OFF(load_addr);	norm_seg += norm_off / 16;        norm_off %= 16;	if (norm_off != 0) return(ERR_SUP_LDADDR);        /* ensure that path name is not too long */        if ((strlen(dir_name) + strlen(prog_name) + 5)		 > MAX_PATH_SIZE) return(ERR_SUP_NAMLNG);	/* construct path name */	file_name[0] = NULCH;	if (dir_name[0] != NULCH) {		strcat(file_name, dir_name);	        strcat(file_name, "\\");	}        strcat(file_name, prog_name);	strcat(file_name, ".MPX");        /* get current segment regs */	segread(&segregs);        /* setup function codes */	inregs.h.ah = 0x4B;        /* EXEC function */	inregs.h.al = 0x03;        /* load only */        /* setup parameter block and name pointers */        segregs.ds = FP_SEG(&file_name);	inregs.x.dx = FP_OFF(&file_name);        segregs.es = FP_SEG(&p_block);	inregs.x.bx = FP_OFF(&p_block);        /* setup load segment -- must be normalized */	p_block.load_seg = norm_seg;	p_block.reloc_seg = p_block.load_seg;        /* call the MS-DOS loader */	errcode = intdosx(&inregs,&outregs,&segregs);        errcode = errcode;        /* check for error */	if (outregs.x.cflag) return(ERR_SUP_LDFAIL);	/* load successful */	return(OK);}/* END OF FILE */address1,0
/***********************************************************************	MPX: The MultiProgramming eXecutive	Project to Accompany	A Practical Approach to Operating Systems	Malcolm G. Lane & James D. Mooney	Copyright 1993, P.W.S. Kent Publishing Co., Boston, MA.		File Name: mpx_supt.c	Authors: J.J. Patnesky, A. Ghosal, M. Lane, J. Mooney	Version: 2.1b	Date: 01/31/08	Purpose: Support routines for MPX-PC		Modules: all	Environment:      IBM-PC (XT, AT or PS/2)			MS-DOS 3.3 or later			TURBO-C 3.0 or TURBO-C++ 1.0 or later	Compile using the LARGE MODEL and SS NOT equal to DS.	All addresses and pointers are "far", and	CS, DS and SS are independent.	Procedures in this file:		sys_init		sys_exit		sys_set_vec		sys_req		sys_alloc_mem		sys_free_mem		sys_get_date		sys_set_date		sys_open_dir		sys_get_entry		sys_close_dir	       sys_check_program	       sys_load_program************************************************************************Change Log:	07/16/88  akg	added comments	02/25/92  jdm	full revision, UNIX version	04/14/92  jdm	Macintosh version	05/15/92  jdm	cleanup and documentation	07/14/92  jdm	update for revised specs        08/13/92  jdm 	revised IBM version; added private heap        10/14/92  jdm 	added check and load procedures        10/18/92  jdm 	revised sys_alloc_mem for alignment	11/17/92  jdm	true heap mgt, aligned, using calloc & free	11/19/92  jdm	enable device handling for final module	12/31/92  jdm	revised sys_req parameters	01/02/93  jdm	return count value after I/O	01/03/93  jdm	revised error names and codes	01/27/93  jdm	corrected count for line input in sys_req			fixed open_dir to handle null lines	02/24/93  jdm	changed sys_set_vec param to interrupt	03/08/93  jdm	corrections to sys_check & sys_load	03/20/93  jdm	stack switch in free, check, and load	04/22/93  jdm	corrected index conflict in sys_free_mem			added safety escape in alloc table search	07/28/93  jdm	conversion to large model	09/01/93  jdm	fixed allocation bug;  made date private	09/14/93  jdm	cleaned up memory allocation        09/16/93  jdm	adjusted program load for large model        09/30/93  jdm	modified for correct list of root directory	11/01/94  jdm	changed load file read to binary	09/18/95  jdm	fixed get_entry to default to current, not root	01/31/08  jdm   fixed possible overflow problem in get_entry************************************************************************/#include "mpx_supt.h"#include <stdlib.h>#include <dos.h>#include <dir.h>#include <errno.h>#include <conio.h>#include <alloc.h>#define VEC_ADDR (0x60L*4)#define MAX_ALLOC 200#define MAX_XPOS 79#define MAX_YPOS 24#define MAX_PATH_SIZE 50/*	System-dependent type definitions*/typedef unsigned char byte;typedef unsigned int word;typedef unsigned long longword;typedef byte *address;typedef struct params {	int      op_code;	int      device_id;	char     *buf_p;	int      *count_p;	} params;/*	Global variables accessed only by support routines*/	static longword vec_save;  /* saved interrupt vector */	static int mod_code;                /* module code */                                           	static struct date sys_date;        /* MPX system date */	/* data structures for directory access */        static char current_path[MAX_PATH_SIZE+1];        static int num_entries;        static struct ffblk file_block;        /* handler presence flags */	static flag sysc_hand;	static flag trm_hand;	static flag prt_hand;	static flag com_hand;        /* memory allocation table */	static struct {		void* original;		void* aligned;	} alloc_table[MAX_ALLOC];	static int alloc_ix;                /* current index */	static int num_alloc;               /* no. of allocated blocks *//*	Procedure: sys_init	Purpose: initialize mpx	Parameters: see prototype  	Return value: error code, or OK if no error	Calls: getdate    	Globals: mod_code		vec_save		sys_date		alloc_table, alloc_ix, num_alloc		sysc_hand, term_hand, prt_hand, com_hand	Errors: none*/int sys_init (    int      modules  /* module code */	     ){	mod_code = modules;        vec_save = 0L;        /* no handlers detected yet */	sysc_hand = FALSE;	trm_hand = FALSE;	prt_hand = FALSE;	com_hand = FALSE;	/* initialize allocation table */	for (alloc_ix=0; alloc_ix < MAX_ALLOC; alloc_ix++) {		alloc_table[alloc_ix].original = NULL;		alloc_table[alloc_ix].aligned = NULL;	}	alloc_ix = 0;	num_alloc = 0;	/* if we have reached Module R3, enable system call handling */	if (modules >= MODULE_R3) sysc_hand = TRUE;	/* if we have reached the final module, enable device handlers */	if (modules >= MODULE_F) {		trm_hand = TRUE;		prt_hand = TRUE;		com_hand = TRUE;	}	/* get system date */        getdate(&sys_date);	return (OK);}/*	Procedure: sys_exit	Purpose: terminate mpx	Parameters: none  	Return value: none	Calls: none       	Globals: vec_save*/void sys_exit(void){	longword *vec_p;	/* if trap vector changed, restore it */	if (vec_save != 0L) {		vec_p = (longword*) VEC_ADDR;		*vec_p = vec_save;	}	/* return to host with null error code */	exit(0);}/*	Procedure: sys_set_vec	Purpose: link trap vector to MPX system call handler	Parameters: handler: addr of handler         	Return value: error code; OK if no error	Calls: none       	Globals: vec_save	Errors: none*/int sys_set_vec   ( void interrupt (*handler)() /* system call handler */		){	longword *vec_p;			vec_p = (longword*) VEC_ADDR;		vec_save = *vec_p;		*vec_p = (longword) handler;	return (0);}/*	Procedure: sys_req	Purpose: Request a system service	Inputs:		op_code           operation code		device_id         device identifier		buf_p             addresso f data buffer		count_p           address of size of buffer	Returns: Result or error code, depending on service		Services supported:	IDLE     null operation				READ     input from a device				WRITE    output to a device				CLEAR    clear terminal screen				GOTOXY   absolute cursor position				EXIT     terminate the caller	Calls:   fgets		strlen			Globals: none		Errors:  ERR_SUP_INVDEV    invalid device		ERR_SUP_INVOPC    invalid operation code		ERR_SUP_INVPOS    invalid character position		ERR_SUP_RDFAIL    read failed		ERR_SUP_WRFAIL    write failed	Description:	For Modules R1 through R4,	this procedure is used only for terminal I/O.	Later modules support both reading and	writing for several devices.	For Modules R1 through R4,	sys_req uses the ANSI C function "fgets."	Later modules may use alternate functions and device drivers.*/int sys_req (   int      op_code, /* operation code */		int      device_id,        /* device id */		char*    buf_p,            /* I/O buffer */		int*     count_p           /* address of count */		){	int      rval;    /* result or error code */	char     *rp;     /* return pointer for fgets */	char     rc;      /* return char for fputc */        params    *param_p; /* pointer to parameter record in stack */	flag     docall;  /* true if system call interrupt wanted */	int      ix;      /* temporary index */	docall = FALSE;	rval = OK;	switch (op_code) {		case IDLE:		if (sysc_hand) docall = TRUE;		break; 				case READ:		switch (device_id) {				case TERMINAL:			if (trm_hand) docall = TRUE;			else {				rp = fgets(buf_p,*count_p,stdin);				if (rp==NULL) rval = ERR_SUP_RDFAIL;				else rval = strlen(buf_p);			}			break;					case COM_PORT:			if (com_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					default:			rval = ERR_SUP_INVDEV;					}		break;	case WRITE:		switch (device_id) {				case TERMINAL:			if (trm_hand) docall = TRUE;			else {				rval = *count_p;				for (ix=0; ix<*count_p; ix++) {					rc = fputc(buf_p[ix],stdout);					if (rc == EOF) {						rval = ERR_SUP_WRFAIL;						break;					}				}			}			break;					case COM_PORT:			if (com_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					case PRINTER:			if (prt_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					default:			rval = ERR_SUP_INVDEV;					}		break;	case CLEAR:		if (device_id==TERMINAL) {			if (trm_hand) docall = TRUE;			else {			     clrscr();				rval = 0;			}		}		else rval = ERR_SUP_INVDEV;		break;			case GOTOXY:		if (device_id==TERMINAL) {			if (trm_hand) docall = TRUE;			else {				if (*count_p != 2) rval = ERR_SUP_WRFAIL;				else if ((*buf_p<0)					|| (*buf_p > MAX_XPOS))					rval = ERR_SUP_WRFAIL;				else if ((*(buf_p+1)<0)					|| (*(buf_p+1) > MAX_YPOS))					rval = ERR_SUP_WRFAIL;				else {					gotoxy(*buf_p + 1,						*(buf_p+1) + 1);					rval = 0;				}			}		}		else rval = ERR_SUP_INVDEV;		break;			/* EXIT - terminate the calling process */	/* legal only when a system call handler is present */	case EXIT:		if (sysc_hand) docall = TRUE;		else rval = ERR_SUP_INVOPC;		break; 	default:		rval = ERR_SUP_INVOPC;			}		/* Invoke user's call handler if present.	   If the call is an IO request, return will occur	   only after the request is complete.	*/	if (docall && (rval==OK)) {		/* invoke the call handler */	_SP = _SP - sizeof(params);		param_p = (params*) MK_FP(_SS,_SP);	       param_p->op_code = op_code;	       param_p->device_id = device_id;	       param_p->buf_p = buf_p;	       param_p->count_p = count_p;	       geninterrupt(0x60);	       rval = _AX;	       _SP = _SP + sizeof(params);		/* for I/O operations, return count value */		switch(op_code) {		case READ:		case WRITE:		case CLEAR:		case GOTOXY:			rval = *count_p;		}	}	return(rval);}/*	Procedure: sys_alloc_mem	Purpose: Allocate a memory block	Parameters:			size_t size       No. of bytes to allocate	Returns: void* pointer to allocated block;		 null pointer in case of error		 	Calls: calloc		Globals: alloc_table, alloc_ix, num_alloc	For program loading (Module R-4), the blocks must be aligned.	This is achieved by requesting one extra paragraph and	returning the lowest aligned address as the base.  It is	necessary to keep a table of allocated address, original and	aligned, to support correct freeing.	It would seem simpler to use the Turbo-C function allocmem,	which always allocates aligned blocks.  However, allocmem	appears to conflict with the internal allocation of fopen	and other C library routines.*/void *sys_alloc_mem (      size_t   size     /* size in bytes to allocate */		    ){	int ix_save;      /* temp copy of table index */        void *addr;        /* addr returned by calloc (*void) */	word offset;      /* offset of unaligned address */	word seg;         /* segment addr of unaligned address */	void *addr_alig; /* aligned address */	int rem; /* temp for alignment computation */	/* ensure that allocation table is not full */	if (num_alloc >= MAX_ALLOC) {		return(NULL);	}	/* find free entry in allocation table */	ix_save = alloc_ix;	while (alloc_table[alloc_ix].original != NULL) {		alloc_ix++;		if (alloc_ix >= MAX_ALLOC) alloc_ix = 0;		/* safety check -- should never happen! */		if (alloc_ix == ix_save) return(NULL);	}	/* call allocation routine */	/* request 15 extra bytes to ensure alignment is possible */	addr = calloc(size + 15,1);	/* compute aligned base */	offset = FP_OFF(addr);        seg = FP_SEG(addr);	rem = offset % 16;	if (rem > 0) offset = offset + 16 - rem;	addr_alig = MK_FP(seg,offset);	/* insert entries in table */	alloc_table[alloc_ix].original = addr;	alloc_table[alloc_ix].aligned = addr_alig;	/* increment count */	num_alloc++;	return(addr_alig);}/*	Procedure: sys_free_mem	Purpose: free a memory block	Parameters:		void *ptr         ptr to block to allocate	Returns: integer error code; zero if OK		Calls:   free	Globals: alloc_table, num_alloc	Errors:  ERR_SUP_INVMEM    invalid memory block	This procedure receives an aligned address; it must	find and free the corresponding non-aligned one.*/int sys_free_mem (         void     *ptr     /* pointer to block */		 ){	void *free_addr;  /* true (unaligned) block address */	int free_ix;               /* temp table index */	/* ensure valid pointer */	if (ptr==NULL) return(ERR_SUP_INVMEM);	/* Look for the block in the allocation table */	free_addr = NULL;	for (free_ix=0; free_ix<MAX_ALLOC; free_ix++) {		if (alloc_table[free_ix].aligned == ptr) {			free_addr = alloc_table[free_ix].original;			break;		}	}	/* If the block wasn't found, report error */	if (free_addr == NULL) return(ERR_SUP_INVMEM);	/* free the block & clear the table entry */	alloc_table[free_ix].original = NULL;	alloc_table[free_ix].aligned = NULL;        free(free_addr);	/* decrement count */	num_alloc--;	return(OK);}        /*	Procedure: sys_get_date	Purpose: Returns the system date (month, day, year)	Parameters:		date_rec *date_p Pointer to structure of type date	Returns: void		Calls: none		Globals: sys_date        Errors: none*/void sys_get_date (  date_rec*      date_p   /* ptr to date record */		){	date_p->month = sys_date.da_mon;	date_p->day = sys_date.da_day;	date_p->year = sys_date.da_year;}/*	Procedure: sys_set_date	Purpose: Sets the system date (month, day, year)	Parameters:		date_rec *date_p ptr to structure of type date	Returns: error code; OK if no error	Calls:   none        Globals: sys_date	Errors: none*/int sys_set_date (  date_rec*       date_p   /* ptr to date record */		 ){	sys_date.da_mon = date_p->month;        sys_date.da_day = date_p->day;        sys_date.da_year = date_p->year;	return(OK);}/*	Procedure: sys_open_dir	Purpose: open a specified directory	Parameters: char dir_name[]            directory name	Returns: error code; zero if OK	Calls:   findfirst		strncpy  	Globals: current_path, file_block, num_entries	Errors:  ERR_SUP_DIROPN    directory open error		ERR_SUP_INVDIR    invalid directory*/int sys_open_dir (  char  path_name[]        /* directory name */		 ){        char temp_path[MAX_PATH_SIZE];	int res;        int len;        /* ensure there is no directory currently open */	if (current_path[0]!=NULCH) return(ERR_SUP_DIROPN);        /* check pathname for validity */        /* construct temporary search path name */	temp_path[0] = NULCH;	if (path_name != NULL) {		strncpy(temp_path,path_name,MAX_PATH_SIZE-4);	}	/* build wildcard search string */        len = strlen(temp_path);	/* if path is null, use current directory */        if (len==0) strcpy(temp_path,"*.*");	/* handle paths ending in backslash, including root */        else if (temp_path[len-1]=='\\') strcat(temp_path,"*.*");	/* handle paths not ending in backslash */        else strcat(temp_path,"\\*.*");	/* validate the directory by searching for either an ordinary	   file or a directory in it.  This should never fail; even	   empty directories contain the directories "." and ".."	*/		res = findfirst(temp_path, &file_block, FA_DIREC);	if (res!=0)  return(ERR_SUP_INVDIR);        /* save pathname as current, clear entry count */	current_path[0] = NULCH;	if (path_name != NULL) {		strncpy(current_path,path_name,MAX_PATH_SIZE-6);	}	num_entries = 0;	return(OK);}/*	Procedure: sys_get_entry	Purpose: get the next directory entry;	Parameters: char name_buf[]	name buffer		    int buf_size  	buffer capacity		    long *file_size_p	file length buffer         	Returns: error code, or zero if ok	Calls:	findfirst		findnext		strncpy, strcpy, strrchr, strcat    	Globals: current_path, num_entries, file_block	Errors:  ERR_SUP_NOENTR    no such entry*/int sys_get_entry (char    name_buf[],       /* buffer for entry */		   int   buf_size,         /* buffer size */		   long* file_size_p       /* buffer for size value */		  ){	char filename[MAX_PATH_SIZE+1];	int err;        int len;        char *cp;        /* find next MPX file entry, if any */        /* if this is the first call */	if (num_entries==0) {	       /* construct complete search path name */	       len = strlen(current_path);	       if (len==0) strcpy(current_path,"*.MPX");	       else if (current_path[len-1]=='\\') strcat(current_path,"*.MPX");	       else strcat(current_path,"\\*.MPX");	       /* find first entry */		err = findfirst (current_path,&file_block,0);        }        /* otherwise, find next entry */        else err = findnext(&file_block);        if (err<0) return(ERR_SUP_NOENTR);		/* ensure buf_size is not too large */		if (buf_size > MAX_PATH_SIZE) buf_size = MAX_PATH_SIZE;		      /* copy filename to buffer */	filename[buf_size] = NULCH;	strncpy (filename,file_block.ff_name,			 (size_t) buf_size);	/* remove ".MPX" from name */	cp = strrchr(filename, (int) '.');        *cp = NULCH;	/* copy name and size to caller's buffer */        strcpy (name_buf,filename);	*file_size_p = file_block.ff_fsize;        /* count entry */	num_entries++;	return(OK);}/*	Procedure: sys_close_dir	Purpose: close an open directory	Parameters: none	Returns: error code; zero if OK	Calls:   none	Globals: current_path	Errors:  none*/int sys_close_dir (void){	current_path[0] = NULCH;	return(OK);}/*	Procedure: sys_check_program	Purpose: locate and measure a program file	Parameters: see prototype	Returns: program size or error code	Calls:   strlen, strcat		fopen, fread	Globals: none	Errors:  ERR_SUP_NAMLNG    pathname too long		ERR_SUP_FILNFD    file not found		ERR_SUP_FILINV    file invalid*/#define HEADER_SIZE 32int sys_check_program(     char     dir_name[],       /* directory name */			char     prog_name[],      /* program name */			int*     prog_len_p,       /* ptr to prog length */			int*     start_offset_p    /* ptr to start offset */			){        /* buffer for full pathname */	char file_name[MAX_PATH_SIZE+1];        /* buffer for file header */        byte header[HEADER_SIZE];	FILE *file_p;     /* file pointer for C file routines */        int num_read;      /* number of header bytes read */	int file_size;    /* size of complete file */        int header_size;/* size of header */        int code_size;     /* size of program code */        int data_size;     /* size of program data */        int errcode;       /* error code */        /* ensure that path name is not too long */        if ((strlen(dir_name) + strlen(prog_name) + 5)		 > MAX_PATH_SIZE) return(ERR_SUP_NAMLNG);	/* construct path name */	file_name[0] = NULCH;	if (dir_name[0] != NULCH) {		strcat(file_name, dir_name);	        strcat(file_name, "\\");	}        strcat(file_name, prog_name);	strcat(file_name, ".MPX");        /* try to open the file */	errcode = OK;        file_p = fopen(file_name, "rb");        if (file_p == NULL) return(ERR_SUP_FILNFD);	/* read the header, check for EXE signature */        num_read = fread( (void*) header, 1, HEADER_SIZE, file_p);        if (num_read != HEADER_SIZE) {		errcode = ERR_SUP_FILINV;	}        else if ((header[0] != 0x4D) || (header[1] != 0x5A)) {		errcode = ERR_SUP_FILINV;	}        /* close the file, then return if error occurred */        fclose(file_p);	if (errcode!=OK) return(errcode);        /* compute allocation size needed */        file_size = (header[5]*256 + header[4] -1) * 512		+ (header[3]*256 + header[2]);        header_size =(header[9]*256 + header[8])*16;        code_size = file_size - header_size;        data_size = (header[11]*256 + header[10])*16;        /* return total length and starting offset */        *prog_len_p = code_size + data_size;	*start_offset_p = (header[23]*256 + header[22]) * 16;	return(OK);}/*	Procedure: sys_load_program	Purpose: load a program file	Parameters: see prototype	Returns: error code; zero if OK	Calls:   intdosx		segread		strlen, strcat	Globals: none 	Errors:  ERR_SUP_NAMLNG    name too long		ERR_SUP_FILNFD    file not found	       ERR_SUP_FILINV      file invalid		ERR_SUP_PROGSZ    program too large	       ERR_SUP_LDADDR      address not aligned		ERR_SUP_LDFAIL    load failed*/int sys_load_program (     void*    load_addr,        /* address for loading */			int      max_size,         /* memory size */			char     dir_name[],       /* directory name */			char     prog_name[]       /* program name */		      ){	int errcode;      /* error code */        int prog_len;      /* program length */	int offset;       /* offset for starting */	word norm_seg;    /* normalized load address segment */        word norm_off;     /* normalized load address offset */        /* full pathname for file to be loaded */	char file_name[MAX_PATH_SIZE+1];        /* parameter block for MSDOS EXEC function */	struct {		word load_seg;    /* segment address for loading */	       word reloc_seg;     /* segment address for relocation */        }p_block;	union REGS inregs;            /* input register structure */	union REGS outregs;           /* output register structure */	struct SREGS segregs;         /* segment register structure */        /* check program, get length and offset */	errcode = sys_check_program(dir_name, prog_name,					&prog_len, &offset);        if (errcode < 0) return(errcode);        /* ensure that allocated memory is large enough */        if (max_size < prog_len) return(ERR_SUP_PROGSZ);        /* get normalized segment and offset, check alignment */	norm_seg = FP_SEG(load_addr);	norm_off = FP_OFF(load_addr);	norm_seg += norm_off / 16;        norm_off %= 16;	if (norm_off != 0) return(ERR_SUP_LDADDR);        /* ensure that path name is not too long */        if ((strlen(dir_name) + strlen(prog_name) + 5)		 > MAX_PATH_SIZE) return(ERR_SUP_NAMLNG);	/* construct path name */	file_name[0] = NULCH;	if (dir_name[0] != NULCH) {		strcat(file_name, dir_name);	        strcat(file_name, "\\");	}        strcat(file_name, prog_name);	strcat(file_name, ".MPX");        /* get current segment regs */	segread(&segregs);        /* setup function codes */	inregs.h.ah = 0x4B;        /* EXEC function */	inregs.h.al = 0x03;        /* load only */        /* setup parameter block and name pointers */        segregs.ds = FP_SEG(&file_name);	inregs.x.dx = FP_OFF(&file_name);        segregs.es = FP_SEG(&p_block);	inregs.x.bx = FP_OFF(&p_block);        /* setup load segment -- must be normalized */	p_block.load_seg = norm_seg;	p_block.reloc_seg = p_block.load_seg;        /* call the MS-DOS loader */	errcode = intdosx(&inregs,&outregs,&segregs);        errcode = errcode;        /* check for error */	if (outregs.x.cflag) return(ERR_SUP_LDFAIL);	/* load successful */	return(OK);}/* END OF FILE */params1,0
/***********************************************************************	MPX: The MultiProgramming eXecutive	Project to Accompany	A Practical Approach to Operating Systems	Malcolm G. Lane & James D. Mooney	Copyright 1993, P.W.S. Kent Publishing Co., Boston, MA.		File Name: mpx_supt.c	Authors: J.J. Patnesky, A. Ghosal, M. Lane, J. Mooney	Version: 2.1b	Date: 01/31/08	Purpose: Support routines for MPX-PC		Modules: all	Environment:      IBM-PC (XT, AT or PS/2)			MS-DOS 3.3 or later			TURBO-C 3.0 or TURBO-C++ 1.0 or later	Compile using the LARGE MODEL and SS NOT equal to DS.	All addresses and pointers are "far", and	CS, DS and SS are independent.	Procedures in this file:		sys_init		sys_exit		sys_set_vec		sys_req		sys_alloc_mem		sys_free_mem		sys_get_date		sys_set_date		sys_open_dir		sys_get_entry		sys_close_dir	       sys_check_program	       sys_load_program************************************************************************Change Log:	07/16/88  akg	added comments	02/25/92  jdm	full revision, UNIX version	04/14/92  jdm	Macintosh version	05/15/92  jdm	cleanup and documentation	07/14/92  jdm	update for revised specs        08/13/92  jdm 	revised IBM version; added private heap        10/14/92  jdm 	added check and load procedures        10/18/92  jdm 	revised sys_alloc_mem for alignment	11/17/92  jdm	true heap mgt, aligned, using calloc & free	11/19/92  jdm	enable device handling for final module	12/31/92  jdm	revised sys_req parameters	01/02/93  jdm	return count value after I/O	01/03/93  jdm	revised error names and codes	01/27/93  jdm	corrected count for line input in sys_req			fixed open_dir to handle null lines	02/24/93  jdm	changed sys_set_vec param to interrupt	03/08/93  jdm	corrections to sys_check & sys_load	03/20/93  jdm	stack switch in free, check, and load	04/22/93  jdm	corrected index conflict in sys_free_mem			added safety escape in alloc table search	07/28/93  jdm	conversion to large model	09/01/93  jdm	fixed allocation bug;  made date private	09/14/93  jdm	cleaned up memory allocation        09/16/93  jdm	adjusted program load for large model        09/30/93  jdm	modified for correct list of root directory	11/01/94  jdm	changed load file read to binary	09/18/95  jdm	fixed get_entry to default to current, not root	01/31/08  jdm   fixed possible overflow problem in get_entry************************************************************************/#include "mpx_supt.h"#include <stdlib.h>#include <dos.h>#include <dir.h>#include <errno.h>#include <conio.h>#include <alloc.h>#define VEC_ADDR (0x60L*4)#define MAX_ALLOC 200#define MAX_XPOS 79#define MAX_YPOS 24#define MAX_PATH_SIZE 50/*	System-dependent type definitions*/typedef unsigned char byte;typedef unsigned int word;typedef unsigned long longword;typedef byte *address;typedef struct params {	int      op_code;	int      device_id;	char     *buf_p;	int      *count_p;	} params;/*	Global variables accessed only by support routines*/	static longword vec_save;  /* saved interrupt vector */	static int mod_code;                /* module code */                                           	static struct date sys_date;        /* MPX system date */	/* data structures for directory access */        static char current_path[MAX_PATH_SIZE+1];        static int num_entries;        static struct ffblk file_block;        /* handler presence flags */	static flag sysc_hand;	static flag trm_hand;	static flag prt_hand;	static flag com_hand;        /* memory allocation table */	static struct {		void* original;		void* aligned;	} alloc_table[MAX_ALLOC];	static int alloc_ix;                /* current index */	static int num_alloc;               /* no. of allocated blocks *//*	Procedure: sys_init	Purpose: initialize mpx	Parameters: see prototype  	Return value: error code, or OK if no error	Calls: getdate    	Globals: mod_code		vec_save		sys_date		alloc_table, alloc_ix, num_alloc		sysc_hand, term_hand, prt_hand, com_hand	Errors: none*/int sys_init (    int      modules  /* module code */	     ){	mod_code = modules;        vec_save = 0L;        /* no handlers detected yet */	sysc_hand = FALSE;	trm_hand = FALSE;	prt_hand = FALSE;	com_hand = FALSE;	/* initialize allocation table */	for (alloc_ix=0; alloc_ix < MAX_ALLOC; alloc_ix++) {		alloc_table[alloc_ix].original = NULL;		alloc_table[alloc_ix].aligned = NULL;	}	alloc_ix = 0;	num_alloc = 0;	/* if we have reached Module R3, enable system call handling */	if (modules >= MODULE_R3) sysc_hand = TRUE;	/* if we have reached the final module, enable device handlers */	if (modules >= MODULE_F) {		trm_hand = TRUE;		prt_hand = TRUE;		com_hand = TRUE;	}	/* get system date */        getdate(&sys_date);	return (OK);}/*	Procedure: sys_exit	Purpose: terminate mpx	Parameters: none  	Return value: none	Calls: none       	Globals: vec_save*/void sys_exit(void){	longword *vec_p;	/* if trap vector changed, restore it */	if (vec_save != 0L) {		vec_p = (longword*) VEC_ADDR;		*vec_p = vec_save;	}	/* return to host with null error code */	exit(0);}/*	Procedure: sys_set_vec	Purpose: link trap vector to MPX system call handler	Parameters: handler: addr of handler         	Return value: error code; OK if no error	Calls: none       	Globals: vec_save	Errors: none*/int sys_set_vec   ( void interrupt (*handler)() /* system call handler */		){	longword *vec_p;			vec_p = (longword*) VEC_ADDR;		vec_save = *vec_p;		*vec_p = (longword) handler;	return (0);}/*	Procedure: sys_req	Purpose: Request a system service	Inputs:		op_code           operation code		device_id         device identifier		buf_p             addresso f data buffer		count_p           address of size of buffer	Returns: Result or error code, depending on service		Services supported:	IDLE     null operation				READ     input from a device				WRITE    output to a device				CLEAR    clear terminal screen				GOTOXY   absolute cursor position				EXIT     terminate the caller	Calls:   fgets		strlen			Globals: none		Errors:  ERR_SUP_INVDEV    invalid device		ERR_SUP_INVOPC    invalid operation code		ERR_SUP_INVPOS    invalid character position		ERR_SUP_RDFAIL    read failed		ERR_SUP_WRFAIL    write failed	Description:	For Modules R1 through R4,	this procedure is used only for terminal I/O.	Later modules support both reading and	writing for several devices.	For Modules R1 through R4,	sys_req uses the ANSI C function "fgets."	Later modules may use alternate functions and device drivers.*/int sys_req (   int      op_code, /* operation code */		int      device_id,        /* device id */		char*    buf_p,            /* I/O buffer */		int*     count_p           /* address of count */		){	int      rval;    /* result or error code */	char     *rp;     /* return pointer for fgets */	char     rc;      /* return char for fputc */        params    *param_p; /* pointer to parameter record in stack */	flag     docall;  /* true if system call interrupt wanted */	int      ix;      /* temporary index */	docall = FALSE;	rval = OK;	switch (op_code) {		case IDLE:		if (sysc_hand) docall = TRUE;		break; 				case READ:		switch (device_id) {				case TERMINAL:			if (trm_hand) docall = TRUE;			else {				rp = fgets(buf_p,*count_p,stdin);				if (rp==NULL) rval = ERR_SUP_RDFAIL;				else rval = strlen(buf_p);			}			break;					case COM_PORT:			if (com_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					default:			rval = ERR_SUP_INVDEV;					}		break;	case WRITE:		switch (device_id) {				case TERMINAL:			if (trm_hand) docall = TRUE;			else {				rval = *count_p;				for (ix=0; ix<*count_p; ix++) {					rc = fputc(buf_p[ix],stdout);					if (rc == EOF) {						rval = ERR_SUP_WRFAIL;						break;					}				}			}			break;					case COM_PORT:			if (com_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					case PRINTER:			if (prt_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					default:			rval = ERR_SUP_INVDEV;					}		break;	case CLEAR:		if (device_id==TERMINAL) {			if (trm_hand) docall = TRUE;			else {			     clrscr();				rval = 0;			}		}		else rval = ERR_SUP_INVDEV;		break;			case GOTOXY:		if (device_id==TERMINAL) {			if (trm_hand) docall = TRUE;			else {				if (*count_p != 2) rval = ERR_SUP_WRFAIL;				else if ((*buf_p<0)					|| (*buf_p > MAX_XPOS))					rval = ERR_SUP_WRFAIL;				else if ((*(buf_p+1)<0)					|| (*(buf_p+1) > MAX_YPOS))					rval = ERR_SUP_WRFAIL;				else {					gotoxy(*buf_p + 1,						*(buf_p+1) + 1);					rval = 0;				}			}		}		else rval = ERR_SUP_INVDEV;		break;			/* EXIT - terminate the calling process */	/* legal only when a system call handler is present */	case EXIT:		if (sysc_hand) docall = TRUE;		else rval = ERR_SUP_INVOPC;		break; 	default:		rval = ERR_SUP_INVOPC;			}		/* Invoke user's call handler if present.	   If the call is an IO request, return will occur	   only after the request is complete.	*/	if (docall && (rval==OK)) {		/* invoke the call handler */	_SP = _SP - sizeof(params);		param_p = (params*) MK_FP(_SS,_SP);	       param_p->op_code = op_code;	       param_p->device_id = device_id;	       param_p->buf_p = buf_p;	       param_p->count_p = count_p;	       geninterrupt(0x60);	       rval = _AX;	       _SP = _SP + sizeof(params);		/* for I/O operations, return count value */		switch(op_code) {		case READ:		case WRITE:		case CLEAR:		case GOTOXY:			rval = *count_p;		}	}	return(rval);}/*	Procedure: sys_alloc_mem	Purpose: Allocate a memory block	Parameters:			size_t size       No. of bytes to allocate	Returns: void* pointer to allocated block;		 null pointer in case of error		 	Calls: calloc		Globals: alloc_table, alloc_ix, num_alloc	For program loading (Module R-4), the blocks must be aligned.	This is achieved by requesting one extra paragraph and	returning the lowest aligned address as the base.  It is	necessary to keep a table of allocated address, original and	aligned, to support correct freeing.	It would seem simpler to use the Turbo-C function allocmem,	which always allocates aligned blocks.  However, allocmem	appears to conflict with the internal allocation of fopen	and other C library routines.*/void *sys_alloc_mem (      size_t   size     /* size in bytes to allocate */		    ){	int ix_save;      /* temp copy of table index */        void *addr;        /* addr returned by calloc (*void) */	word offset;      /* offset of unaligned address */	word seg;         /* segment addr of unaligned address */	void *addr_alig; /* aligned address */	int rem; /* temp for alignment computation */	/* ensure that allocation table is not full */	if (num_alloc >= MAX_ALLOC) {		return(NULL);	}	/* find free entry in allocation table */	ix_save = alloc_ix;	while (alloc_table[alloc_ix].original != NULL) {		alloc_ix++;		if (alloc_ix >= MAX_ALLOC) alloc_ix = 0;		/* safety check -- should never happen! */		if (alloc_ix == ix_save) return(NULL);	}	/* call allocation routine */	/* request 15 extra bytes to ensure alignment is possible */	addr = calloc(size + 15,1);	/* compute aligned base */	offset = FP_OFF(addr);        seg = FP_SEG(addr);	rem = offset % 16;	if (rem > 0) offset = offset + 16 - rem;	addr_alig = MK_FP(seg,offset);	/* insert entries in table */	alloc_table[alloc_ix].original = addr;	alloc_table[alloc_ix].aligned = addr_alig;	/* increment count */	num_alloc++;	return(addr_alig);}/*	Procedure: sys_free_mem	Purpose: free a memory block	Parameters:		void *ptr         ptr to block to allocate	Returns: integer error code; zero if OK		Calls:   free	Globals: alloc_table, num_alloc	Errors:  ERR_SUP_INVMEM    invalid memory block	This procedure receives an aligned address; it must	find and free the corresponding non-aligned one.*/int sys_free_mem (         void     *ptr     /* pointer to block */		 ){	void *free_addr;  /* true (unaligned) block address */	int free_ix;               /* temp table index */	/* ensure valid pointer */	if (ptr==NULL) return(ERR_SUP_INVMEM);	/* Look for the block in the allocation table */	free_addr = NULL;	for (free_ix=0; free_ix<MAX_ALLOC; free_ix++) {		if (alloc_table[free_ix].aligned == ptr) {			free_addr = alloc_table[free_ix].original;			break;		}	}	/* If the block wasn't found, report error */	if (free_addr == NULL) return(ERR_SUP_INVMEM);	/* free the block & clear the table entry */	alloc_table[free_ix].original = NULL;	alloc_table[free_ix].aligned = NULL;        free(free_addr);	/* decrement count */	num_alloc--;	return(OK);}        /*	Procedure: sys_get_date	Purpose: Returns the system date (month, day, year)	Parameters:		date_rec *date_p Pointer to structure of type date	Returns: void		Calls: none		Globals: sys_date        Errors: none*/void sys_get_date (  date_rec*      date_p   /* ptr to date record */		){	date_p->month = sys_date.da_mon;	date_p->day = sys_date.da_day;	date_p->year = sys_date.da_year;}/*	Procedure: sys_set_date	Purpose: Sets the system date (month, day, year)	Parameters:		date_rec *date_p ptr to structure of type date	Returns: error code; OK if no error	Calls:   none        Globals: sys_date	Errors: none*/int sys_set_date (  date_rec*       date_p   /* ptr to date record */		 ){	sys_date.da_mon = date_p->month;        sys_date.da_day = date_p->day;        sys_date.da_year = date_p->year;	return(OK);}/*	Procedure: sys_open_dir	Purpose: open a specified directory	Parameters: char dir_name[]            directory name	Returns: error code; zero if OK	Calls:   findfirst		strncpy  	Globals: current_path, file_block, num_entries	Errors:  ERR_SUP_DIROPN    directory open error		ERR_SUP_INVDIR    invalid directory*/int sys_open_dir (  char  path_name[]        /* directory name */		 ){        char temp_path[MAX_PATH_SIZE];	int res;        int len;        /* ensure there is no directory currently open */	if (current_path[0]!=NULCH) return(ERR_SUP_DIROPN);        /* check pathname for validity */        /* construct temporary search path name */	temp_path[0] = NULCH;	if (path_name != NULL) {		strncpy(temp_path,path_name,MAX_PATH_SIZE-4);	}	/* build wildcard search string */        len = strlen(temp_path);	/* if path is null, use current directory */        if (len==0) strcpy(temp_path,"*.*");	/* handle paths ending in backslash, including root */        else if (temp_path[len-1]=='\\') strcat(temp_path,"*.*");	/* handle paths not ending in backslash */        else strcat(temp_path,"\\*.*");	/* validate the directory by searching for either an ordinary	   file or a directory in it.  This should never fail; even	   empty directories contain the directories "." and ".."	*/		res = findfirst(temp_path, &file_block, FA_DIREC);	if (res!=0)  return(ERR_SUP_INVDIR);        /* save pathname as current, clear entry count */	current_path[0] = NULCH;	if (path_name != NULL) {		strncpy(current_path,path_name,MAX_PATH_SIZE-6);	}	num_entries = 0;	return(OK);}/*	Procedure: sys_get_entry	Purpose: get the next directory entry;	Parameters: char name_buf[]	name buffer		    int buf_size  	buffer capacity		    long *file_size_p	file length buffer         	Returns: error code, or zero if ok	Calls:	findfirst		findnext		strncpy, strcpy, strrchr, strcat    	Globals: current_path, num_entries, file_block	Errors:  ERR_SUP_NOENTR    no such entry*/int sys_get_entry (char    name_buf[],       /* buffer for entry */		   int   buf_size,         /* buffer size */		   long* file_size_p       /* buffer for size value */		  ){	char filename[MAX_PATH_SIZE+1];	int err;        int len;        char *cp;        /* find next MPX file entry, if any */        /* if this is the first call */	if (num_entries==0) {	       /* construct complete search path name */	       len = strlen(current_path);	       if (len==0) strcpy(current_path,"*.MPX");	       else if (current_path[len-1]=='\\') strcat(current_path,"*.MPX");	       else strcat(current_path,"\\*.MPX");	       /* find first entry */		err = findfirst (current_path,&file_block,0);        }        /* otherwise, find next entry */        else err = findnext(&file_block);        if (err<0) return(ERR_SUP_NOENTR);		/* ensure buf_size is not too large */		if (buf_size > MAX_PATH_SIZE) buf_size = MAX_PATH_SIZE;		      /* copy filename to buffer */	filename[buf_size] = NULCH;	strncpy (filename,file_block.ff_name,			 (size_t) buf_size);	/* remove ".MPX" from name */	cp = strrchr(filename, (int) '.');        *cp = NULCH;	/* copy name and size to caller's buffer */        strcpy (name_buf,filename);	*file_size_p = file_block.ff_fsize;        /* count entry */	num_entries++;	return(OK);}/*	Procedure: sys_close_dir	Purpose: close an open directory	Parameters: none	Returns: error code; zero if OK	Calls:   none	Globals: current_path	Errors:  none*/int sys_close_dir (void){	current_path[0] = NULCH;	return(OK);}/*	Procedure: sys_check_program	Purpose: locate and measure a program file	Parameters: see prototype	Returns: program size or error code	Calls:   strlen, strcat		fopen, fread	Globals: none	Errors:  ERR_SUP_NAMLNG    pathname too long		ERR_SUP_FILNFD    file not found		ERR_SUP_FILINV    file invalid*/#define HEADER_SIZE 32int sys_check_program(     char     dir_name[],       /* directory name */			char     prog_name[],      /* program name */			int*     prog_len_p,       /* ptr to prog length */			int*     start_offset_p    /* ptr to start offset */			){        /* buffer for full pathname */	char file_name[MAX_PATH_SIZE+1];        /* buffer for file header */        byte header[HEADER_SIZE];	FILE *file_p;     /* file pointer for C file routines */        int num_read;      /* number of header bytes read */	int file_size;    /* size of complete file */        int header_size;/* size of header */        int code_size;     /* size of program code */        int data_size;     /* size of program data */        int errcode;       /* error code */        /* ensure that path name is not too long */        if ((strlen(dir_name) + strlen(prog_name) + 5)		 > MAX_PATH_SIZE) return(ERR_SUP_NAMLNG);	/* construct path name */	file_name[0] = NULCH;	if (dir_name[0] != NULCH) {		strcat(file_name, dir_name);	        strcat(file_name, "\\");	}        strcat(file_name, prog_name);	strcat(file_name, ".MPX");        /* try to open the file */	errcode = OK;        file_p = fopen(file_name, "rb");        if (file_p == NULL) return(ERR_SUP_FILNFD);	/* read the header, check for EXE signature */        num_read = fread( (void*) header, 1, HEADER_SIZE, file_p);        if (num_read != HEADER_SIZE) {		errcode = ERR_SUP_FILINV;	}        else if ((header[0] != 0x4D) || (header[1] != 0x5A)) {		errcode = ERR_SUP_FILINV;	}        /* close the file, then return if error occurred */        fclose(file_p);	if (errcode!=OK) return(errcode);        /* compute allocation size needed */        file_size = (header[5]*256 + header[4] -1) * 512		+ (header[3]*256 + header[2]);        header_size =(header[9]*256 + header[8])*16;        code_size = file_size - header_size;        data_size = (header[11]*256 + header[10])*16;        /* return total length and starting offset */        *prog_len_p = code_size + data_size;	*start_offset_p = (header[23]*256 + header[22]) * 16;	return(OK);}/*	Procedure: sys_load_program	Purpose: load a program file	Parameters: see prototype	Returns: error code; zero if OK	Calls:   intdosx		segread		strlen, strcat	Globals: none 	Errors:  ERR_SUP_NAMLNG    name too long		ERR_SUP_FILNFD    file not found	       ERR_SUP_FILINV      file invalid		ERR_SUP_PROGSZ    program too large	       ERR_SUP_LDADDR      address not aligned		ERR_SUP_LDFAIL    load failed*/int sys_load_program (     void*    load_addr,        /* address for loading */			int      max_size,         /* memory size */			char     dir_name[],       /* directory name */			char     prog_name[]       /* program name */		      ){	int errcode;      /* error code */        int prog_len;      /* program length */	int offset;       /* offset for starting */	word norm_seg;    /* normalized load address segment */        word norm_off;     /* normalized load address offset */        /* full pathname for file to be loaded */	char file_name[MAX_PATH_SIZE+1];        /* parameter block for MSDOS EXEC function */	struct {		word load_seg;    /* segment address for loading */	       word reloc_seg;     /* segment address for relocation */        }p_block;	union REGS inregs;            /* input register structure */	union REGS outregs;           /* output register structure */	struct SREGS segregs;         /* segment register structure */        /* check program, get length and offset */	errcode = sys_check_program(dir_name, prog_name,					&prog_len, &offset);        if (errcode < 0) return(errcode);        /* ensure that allocated memory is large enough */        if (max_size < prog_len) return(ERR_SUP_PROGSZ);        /* get normalized segment and offset, check alignment */	norm_seg = FP_SEG(load_addr);	norm_off = FP_OFF(load_addr);	norm_seg += norm_off / 16;        norm_off %= 16;	if (norm_off != 0) return(ERR_SUP_LDADDR);        /* ensure that path name is not too long */        if ((strlen(dir_name) + strlen(prog_name) + 5)		 > MAX_PATH_SIZE) return(ERR_SUP_NAMLNG);	/* construct path name */	file_name[0] = NULCH;	if (dir_name[0] != NULCH) {		strcat(file_name, dir_name);	        strcat(file_name, "\\");	}        strcat(file_name, prog_name);	strcat(file_name, ".MPX");        /* get current segment regs */	segread(&segregs);        /* setup function codes */	inregs.h.ah = 0x4B;        /* EXEC function */	inregs.h.al = 0x03;        /* load only */        /* setup parameter block and name pointers */        segregs.ds = FP_SEG(&file_name);	inregs.x.dx = FP_OFF(&file_name);        segregs.es = FP_SEG(&p_block);	inregs.x.bx = FP_OFF(&p_block);        /* setup load segment -- must be normalized */	p_block.load_seg = norm_seg;	p_block.reloc_seg = p_block.load_seg;        /* call the MS-DOS loader */	errcode = intdosx(&inregs,&outregs,&segregs);        errcode = errcode;        /* check for error */	if (outregs.x.cflag) return(ERR_SUP_LDFAIL);	/* load successful */	return(OK);}/* END OF FILE */op_code1,0
/***********************************************************************	MPX: The MultiProgramming eXecutive	Project to Accompany	A Practical Approach to Operating Systems	Malcolm G. Lane & James D. Mooney	Copyright 1993, P.W.S. Kent Publishing Co., Boston, MA.		File Name: mpx_supt.c	Authors: J.J. Patnesky, A. Ghosal, M. Lane, J. Mooney	Version: 2.1b	Date: 01/31/08	Purpose: Support routines for MPX-PC		Modules: all	Environment:      IBM-PC (XT, AT or PS/2)			MS-DOS 3.3 or later			TURBO-C 3.0 or TURBO-C++ 1.0 or later	Compile using the LARGE MODEL and SS NOT equal to DS.	All addresses and pointers are "far", and	CS, DS and SS are independent.	Procedures in this file:		sys_init		sys_exit		sys_set_vec		sys_req		sys_alloc_mem		sys_free_mem		sys_get_date		sys_set_date		sys_open_dir		sys_get_entry		sys_close_dir	       sys_check_program	       sys_load_program************************************************************************Change Log:	07/16/88  akg	added comments	02/25/92  jdm	full revision, UNIX version	04/14/92  jdm	Macintosh version	05/15/92  jdm	cleanup and documentation	07/14/92  jdm	update for revised specs        08/13/92  jdm 	revised IBM version; added private heap        10/14/92  jdm 	added check and load procedures        10/18/92  jdm 	revised sys_alloc_mem for alignment	11/17/92  jdm	true heap mgt, aligned, using calloc & free	11/19/92  jdm	enable device handling for final module	12/31/92  jdm	revised sys_req parameters	01/02/93  jdm	return count value after I/O	01/03/93  jdm	revised error names and codes	01/27/93  jdm	corrected count for line input in sys_req			fixed open_dir to handle null lines	02/24/93  jdm	changed sys_set_vec param to interrupt	03/08/93  jdm	corrections to sys_check & sys_load	03/20/93  jdm	stack switch in free, check, and load	04/22/93  jdm	corrected index conflict in sys_free_mem			added safety escape in alloc table search	07/28/93  jdm	conversion to large model	09/01/93  jdm	fixed allocation bug;  made date private	09/14/93  jdm	cleaned up memory allocation        09/16/93  jdm	adjusted program load for large model        09/30/93  jdm	modified for correct list of root directory	11/01/94  jdm	changed load file read to binary	09/18/95  jdm	fixed get_entry to default to current, not root	01/31/08  jdm   fixed possible overflow problem in get_entry************************************************************************/#include "mpx_supt.h"#include <stdlib.h>#include <dos.h>#include <dir.h>#include <errno.h>#include <conio.h>#include <alloc.h>#define VEC_ADDR (0x60L*4)#define MAX_ALLOC 200#define MAX_XPOS 79#define MAX_YPOS 24#define MAX_PATH_SIZE 50/*	System-dependent type definitions*/typedef unsigned char byte;typedef unsigned int word;typedef unsigned long longword;typedef byte *address;typedef struct params {	int      op_code;	int      device_id;	char     *buf_p;	int      *count_p;	} params;/*	Global variables accessed only by support routines*/	static longword vec_save;  /* saved interrupt vector */	static int mod_code;                /* module code */                                           	static struct date sys_date;        /* MPX system date */	/* data structures for directory access */        static char current_path[MAX_PATH_SIZE+1];        static int num_entries;        static struct ffblk file_block;        /* handler presence flags */	static flag sysc_hand;	static flag trm_hand;	static flag prt_hand;	static flag com_hand;        /* memory allocation table */	static struct {		void* original;		void* aligned;	} alloc_table[MAX_ALLOC];	static int alloc_ix;                /* current index */	static int num_alloc;               /* no. of allocated blocks *//*	Procedure: sys_init	Purpose: initialize mpx	Parameters: see prototype  	Return value: error code, or OK if no error	Calls: getdate    	Globals: mod_code		vec_save		sys_date		alloc_table, alloc_ix, num_alloc		sysc_hand, term_hand, prt_hand, com_hand	Errors: none*/int sys_init (    int      modules  /* module code */	     ){	mod_code = modules;        vec_save = 0L;        /* no handlers detected yet */	sysc_hand = FALSE;	trm_hand = FALSE;	prt_hand = FALSE;	com_hand = FALSE;	/* initialize allocation table */	for (alloc_ix=0; alloc_ix < MAX_ALLOC; alloc_ix++) {		alloc_table[alloc_ix].original = NULL;		alloc_table[alloc_ix].aligned = NULL;	}	alloc_ix = 0;	num_alloc = 0;	/* if we have reached Module R3, enable system call handling */	if (modules >= MODULE_R3) sysc_hand = TRUE;	/* if we have reached the final module, enable device handlers */	if (modules >= MODULE_F) {		trm_hand = TRUE;		prt_hand = TRUE;		com_hand = TRUE;	}	/* get system date */        getdate(&sys_date);	return (OK);}/*	Procedure: sys_exit	Purpose: terminate mpx	Parameters: none  	Return value: none	Calls: none       	Globals: vec_save*/void sys_exit(void){	longword *vec_p;	/* if trap vector changed, restore it */	if (vec_save != 0L) {		vec_p = (longword*) VEC_ADDR;		*vec_p = vec_save;	}	/* return to host with null error code */	exit(0);}/*	Procedure: sys_set_vec	Purpose: link trap vector to MPX system call handler	Parameters: handler: addr of handler         	Return value: error code; OK if no error	Calls: none       	Globals: vec_save	Errors: none*/int sys_set_vec   ( void interrupt (*handler)() /* system call handler */		){	longword *vec_p;			vec_p = (longword*) VEC_ADDR;		vec_save = *vec_p;		*vec_p = (longword) handler;	return (0);}/*	Procedure: sys_req	Purpose: Request a system service	Inputs:		op_code           operation code		device_id         device identifier		buf_p             addresso f data buffer		count_p           address of size of buffer	Returns: Result or error code, depending on service		Services supported:	IDLE     null operation				READ     input from a device				WRITE    output to a device				CLEAR    clear terminal screen				GOTOXY   absolute cursor position				EXIT     terminate the caller	Calls:   fgets		strlen			Globals: none		Errors:  ERR_SUP_INVDEV    invalid device		ERR_SUP_INVOPC    invalid operation code		ERR_SUP_INVPOS    invalid character position		ERR_SUP_RDFAIL    read failed		ERR_SUP_WRFAIL    write failed	Description:	For Modules R1 through R4,	this procedure is used only for terminal I/O.	Later modules support both reading and	writing for several devices.	For Modules R1 through R4,	sys_req uses the ANSI C function "fgets."	Later modules may use alternate functions and device drivers.*/int sys_req (   int      op_code, /* operation code */		int      device_id,        /* device id */		char*    buf_p,            /* I/O buffer */		int*     count_p           /* address of count */		){	int      rval;    /* result or error code */	char     *rp;     /* return pointer for fgets */	char     rc;      /* return char for fputc */        params    *param_p; /* pointer to parameter record in stack */	flag     docall;  /* true if system call interrupt wanted */	int      ix;      /* temporary index */	docall = FALSE;	rval = OK;	switch (op_code) {		case IDLE:		if (sysc_hand) docall = TRUE;		break; 				case READ:		switch (device_id) {				case TERMINAL:			if (trm_hand) docall = TRUE;			else {				rp = fgets(buf_p,*count_p,stdin);				if (rp==NULL) rval = ERR_SUP_RDFAIL;				else rval = strlen(buf_p);			}			break;					case COM_PORT:			if (com_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					default:			rval = ERR_SUP_INVDEV;					}		break;	case WRITE:		switch (device_id) {				case TERMINAL:			if (trm_hand) docall = TRUE;			else {				rval = *count_p;				for (ix=0; ix<*count_p; ix++) {					rc = fputc(buf_p[ix],stdout);					if (rc == EOF) {						rval = ERR_SUP_WRFAIL;						break;					}				}			}			break;					case COM_PORT:			if (com_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					case PRINTER:			if (prt_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					default:			rval = ERR_SUP_INVDEV;					}		break;	case CLEAR:		if (device_id==TERMINAL) {			if (trm_hand) docall = TRUE;			else {			     clrscr();				rval = 0;			}		}		else rval = ERR_SUP_INVDEV;		break;			case GOTOXY:		if (device_id==TERMINAL) {			if (trm_hand) docall = TRUE;			else {				if (*count_p != 2) rval = ERR_SUP_WRFAIL;				else if ((*buf_p<0)					|| (*buf_p > MAX_XPOS))					rval = ERR_SUP_WRFAIL;				else if ((*(buf_p+1)<0)					|| (*(buf_p+1) > MAX_YPOS))					rval = ERR_SUP_WRFAIL;				else {					gotoxy(*buf_p + 1,						*(buf_p+1) + 1);					rval = 0;				}			}		}		else rval = ERR_SUP_INVDEV;		break;			/* EXIT - terminate the calling process */	/* legal only when a system call handler is present */	case EXIT:		if (sysc_hand) docall = TRUE;		else rval = ERR_SUP_INVOPC;		break; 	default:		rval = ERR_SUP_INVOPC;			}		/* Invoke user's call handler if present.	   If the call is an IO request, return will occur	   only after the request is complete.	*/	if (docall && (rval==OK)) {		/* invoke the call handler */	_SP = _SP - sizeof(params);		param_p = (params*) MK_FP(_SS,_SP);	       param_p->op_code = op_code;	       param_p->device_id = device_id;	       param_p->buf_p = buf_p;	       param_p->count_p = count_p;	       geninterrupt(0x60);	       rval = _AX;	       _SP = _SP + sizeof(params);		/* for I/O operations, return count value */		switch(op_code) {		case READ:		case WRITE:		case CLEAR:		case GOTOXY:			rval = *count_p;		}	}	return(rval);}/*	Procedure: sys_alloc_mem	Purpose: Allocate a memory block	Parameters:			size_t size       No. of bytes to allocate	Returns: void* pointer to allocated block;		 null pointer in case of error		 	Calls: calloc		Globals: alloc_table, alloc_ix, num_alloc	For program loading (Module R-4), the blocks must be aligned.	This is achieved by requesting one extra paragraph and	returning the lowest aligned address as the base.  It is	necessary to keep a table of allocated address, original and	aligned, to support correct freeing.	It would seem simpler to use the Turbo-C function allocmem,	which always allocates aligned blocks.  However, allocmem	appears to conflict with the internal allocation of fopen	and other C library routines.*/void *sys_alloc_mem (      size_t   size     /* size in bytes to allocate */		    ){	int ix_save;      /* temp copy of table index */        void *addr;        /* addr returned by calloc (*void) */	word offset;      /* offset of unaligned address */	word seg;         /* segment addr of unaligned address */	void *addr_alig; /* aligned address */	int rem; /* temp for alignment computation */	/* ensure that allocation table is not full */	if (num_alloc >= MAX_ALLOC) {		return(NULL);	}	/* find free entry in allocation table */	ix_save = alloc_ix;	while (alloc_table[alloc_ix].original != NULL) {		alloc_ix++;		if (alloc_ix >= MAX_ALLOC) alloc_ix = 0;		/* safety check -- should never happen! */		if (alloc_ix == ix_save) return(NULL);	}	/* call allocation routine */	/* request 15 extra bytes to ensure alignment is possible */	addr = calloc(size + 15,1);	/* compute aligned base */	offset = FP_OFF(addr);        seg = FP_SEG(addr);	rem = offset % 16;	if (rem > 0) offset = offset + 16 - rem;	addr_alig = MK_FP(seg,offset);	/* insert entries in table */	alloc_table[alloc_ix].original = addr;	alloc_table[alloc_ix].aligned = addr_alig;	/* increment count */	num_alloc++;	return(addr_alig);}/*	Procedure: sys_free_mem	Purpose: free a memory block	Parameters:		void *ptr         ptr to block to allocate	Returns: integer error code; zero if OK		Calls:   free	Globals: alloc_table, num_alloc	Errors:  ERR_SUP_INVMEM    invalid memory block	This procedure receives an aligned address; it must	find and free the corresponding non-aligned one.*/int sys_free_mem (         void     *ptr     /* pointer to block */		 ){	void *free_addr;  /* true (unaligned) block address */	int free_ix;               /* temp table index */	/* ensure valid pointer */	if (ptr==NULL) return(ERR_SUP_INVMEM);	/* Look for the block in the allocation table */	free_addr = NULL;	for (free_ix=0; free_ix<MAX_ALLOC; free_ix++) {		if (alloc_table[free_ix].aligned == ptr) {			free_addr = alloc_table[free_ix].original;			break;		}	}	/* If the block wasn't found, report error */	if (free_addr == NULL) return(ERR_SUP_INVMEM);	/* free the block & clear the table entry */	alloc_table[free_ix].original = NULL;	alloc_table[free_ix].aligned = NULL;        free(free_addr);	/* decrement count */	num_alloc--;	return(OK);}        /*	Procedure: sys_get_date	Purpose: Returns the system date (month, day, year)	Parameters:		date_rec *date_p Pointer to structure of type date	Returns: void		Calls: none		Globals: sys_date        Errors: none*/void sys_get_date (  date_rec*      date_p   /* ptr to date record */		){	date_p->month = sys_date.da_mon;	date_p->day = sys_date.da_day;	date_p->year = sys_date.da_year;}/*	Procedure: sys_set_date	Purpose: Sets the system date (month, day, year)	Parameters:		date_rec *date_p ptr to structure of type date	Returns: error code; OK if no error	Calls:   none        Globals: sys_date	Errors: none*/int sys_set_date (  date_rec*       date_p   /* ptr to date record */		 ){	sys_date.da_mon = date_p->month;        sys_date.da_day = date_p->day;        sys_date.da_year = date_p->year;	return(OK);}/*	Procedure: sys_open_dir	Purpose: open a specified directory	Parameters: char dir_name[]            directory name	Returns: error code; zero if OK	Calls:   findfirst		strncpy  	Globals: current_path, file_block, num_entries	Errors:  ERR_SUP_DIROPN    directory open error		ERR_SUP_INVDIR    invalid directory*/int sys_open_dir (  char  path_name[]        /* directory name */		 ){        char temp_path[MAX_PATH_SIZE];	int res;        int len;        /* ensure there is no directory currently open */	if (current_path[0]!=NULCH) return(ERR_SUP_DIROPN);        /* check pathname for validity */        /* construct temporary search path name */	temp_path[0] = NULCH;	if (path_name != NULL) {		strncpy(temp_path,path_name,MAX_PATH_SIZE-4);	}	/* build wildcard search string */        len = strlen(temp_path);	/* if path is null, use current directory */        if (len==0) strcpy(temp_path,"*.*");	/* handle paths ending in backslash, including root */        else if (temp_path[len-1]=='\\') strcat(temp_path,"*.*");	/* handle paths not ending in backslash */        else strcat(temp_path,"\\*.*");	/* validate the directory by searching for either an ordinary	   file or a directory in it.  This should never fail; even	   empty directories contain the directories "." and ".."	*/		res = findfirst(temp_path, &file_block, FA_DIREC);	if (res!=0)  return(ERR_SUP_INVDIR);        /* save pathname as current, clear entry count */	current_path[0] = NULCH;	if (path_name != NULL) {		strncpy(current_path,path_name,MAX_PATH_SIZE-6);	}	num_entries = 0;	return(OK);}/*	Procedure: sys_get_entry	Purpose: get the next directory entry;	Parameters: char name_buf[]	name buffer		    int buf_size  	buffer capacity		    long *file_size_p	file length buffer         	Returns: error code, or zero if ok	Calls:	findfirst		findnext		strncpy, strcpy, strrchr, strcat    	Globals: current_path, num_entries, file_block	Errors:  ERR_SUP_NOENTR    no such entry*/int sys_get_entry (char    name_buf[],       /* buffer for entry */		   int   buf_size,         /* buffer size */		   long* file_size_p       /* buffer for size value */		  ){	char filename[MAX_PATH_SIZE+1];	int err;        int len;        char *cp;        /* find next MPX file entry, if any */        /* if this is the first call */	if (num_entries==0) {	       /* construct complete search path name */	       len = strlen(current_path);	       if (len==0) strcpy(current_path,"*.MPX");	       else if (current_path[len-1]=='\\') strcat(current_path,"*.MPX");	       else strcat(current_path,"\\*.MPX");	       /* find first entry */		err = findfirst (current_path,&file_block,0);        }        /* otherwise, find next entry */        else err = findnext(&file_block);        if (err<0) return(ERR_SUP_NOENTR);		/* ensure buf_size is not too large */		if (buf_size > MAX_PATH_SIZE) buf_size = MAX_PATH_SIZE;		      /* copy filename to buffer */	filename[buf_size] = NULCH;	strncpy (filename,file_block.ff_name,			 (size_t) buf_size);	/* remove ".MPX" from name */	cp = strrchr(filename, (int) '.');        *cp = NULCH;	/* copy name and size to caller's buffer */        strcpy (name_buf,filename);	*file_size_p = file_block.ff_fsize;        /* count entry */	num_entries++;	return(OK);}/*	Procedure: sys_close_dir	Purpose: close an open directory	Parameters: none	Returns: error code; zero if OK	Calls:   none	Globals: current_path	Errors:  none*/int sys_close_dir (void){	current_path[0] = NULCH;	return(OK);}/*	Procedure: sys_check_program	Purpose: locate and measure a program file	Parameters: see prototype	Returns: program size or error code	Calls:   strlen, strcat		fopen, fread	Globals: none	Errors:  ERR_SUP_NAMLNG    pathname too long		ERR_SUP_FILNFD    file not found		ERR_SUP_FILINV    file invalid*/#define HEADER_SIZE 32int sys_check_program(     char     dir_name[],       /* directory name */			char     prog_name[],      /* program name */			int*     prog_len_p,       /* ptr to prog length */			int*     start_offset_p    /* ptr to start offset */			){        /* buffer for full pathname */	char file_name[MAX_PATH_SIZE+1];        /* buffer for file header */        byte header[HEADER_SIZE];	FILE *file_p;     /* file pointer for C file routines */        int num_read;      /* number of header bytes read */	int file_size;    /* size of complete file */        int header_size;/* size of header */        int code_size;     /* size of program code */        int data_size;     /* size of program data */        int errcode;       /* error code */        /* ensure that path name is not too long */        if ((strlen(dir_name) + strlen(prog_name) + 5)		 > MAX_PATH_SIZE) return(ERR_SUP_NAMLNG);	/* construct path name */	file_name[0] = NULCH;	if (dir_name[0] != NULCH) {		strcat(file_name, dir_name);	        strcat(file_name, "\\");	}        strcat(file_name, prog_name);	strcat(file_name, ".MPX");        /* try to open the file */	errcode = OK;        file_p = fopen(file_name, "rb");        if (file_p == NULL) return(ERR_SUP_FILNFD);	/* read the header, check for EXE signature */        num_read = fread( (void*) header, 1, HEADER_SIZE, file_p);        if (num_read != HEADER_SIZE) {		errcode = ERR_SUP_FILINV;	}        else if ((header[0] != 0x4D) || (header[1] != 0x5A)) {		errcode = ERR_SUP_FILINV;	}        /* close the file, then return if error occurred */        fclose(file_p);	if (errcode!=OK) return(errcode);        /* compute allocation size needed */        file_size = (header[5]*256 + header[4] -1) * 512		+ (header[3]*256 + header[2]);        header_size =(header[9]*256 + header[8])*16;        code_size = file_size - header_size;        data_size = (header[11]*256 + header[10])*16;        /* return total length and starting offset */        *prog_len_p = code_size + data_size;	*start_offset_p = (header[23]*256 + header[22]) * 16;	return(OK);}/*	Procedure: sys_load_program	Purpose: load a program file	Parameters: see prototype	Returns: error code; zero if OK	Calls:   intdosx		segread		strlen, strcat	Globals: none 	Errors:  ERR_SUP_NAMLNG    name too long		ERR_SUP_FILNFD    file not found	       ERR_SUP_FILINV      file invalid		ERR_SUP_PROGSZ    program too large	       ERR_SUP_LDADDR      address not aligned		ERR_SUP_LDFAIL    load failed*/int sys_load_program (     void*    load_addr,        /* address for loading */			int      max_size,         /* memory size */			char     dir_name[],       /* directory name */			char     prog_name[]       /* program name */		      ){	int errcode;      /* error code */        int prog_len;      /* program length */	int offset;       /* offset for starting */	word norm_seg;    /* normalized load address segment */        word norm_off;     /* normalized load address offset */        /* full pathname for file to be loaded */	char file_name[MAX_PATH_SIZE+1];        /* parameter block for MSDOS EXEC function */	struct {		word load_seg;    /* segment address for loading */	       word reloc_seg;     /* segment address for relocation */        }p_block;	union REGS inregs;            /* input register structure */	union REGS outregs;           /* output register structure */	struct SREGS segregs;         /* segment register structure */        /* check program, get length and offset */	errcode = sys_check_program(dir_name, prog_name,					&prog_len, &offset);        if (errcode < 0) return(errcode);        /* ensure that allocated memory is large enough */        if (max_size < prog_len) return(ERR_SUP_PROGSZ);        /* get normalized segment and offset, check alignment */	norm_seg = FP_SEG(load_addr);	norm_off = FP_OFF(load_addr);	norm_seg += norm_off / 16;        norm_off %= 16;	if (norm_off != 0) return(ERR_SUP_LDADDR);        /* ensure that path name is not too long */        if ((strlen(dir_name) + strlen(prog_name) + 5)		 > MAX_PATH_SIZE) return(ERR_SUP_NAMLNG);	/* construct path name */	file_name[0] = NULCH;	if (dir_name[0] != NULCH) {		strcat(file_name, dir_name);	        strcat(file_name, "\\");	}        strcat(file_name, prog_name);	strcat(file_name, ".MPX");        /* get current segment regs */	segread(&segregs);        /* setup function codes */	inregs.h.ah = 0x4B;        /* EXEC function */	inregs.h.al = 0x03;        /* load only */        /* setup parameter block and name pointers */        segregs.ds = FP_SEG(&file_name);	inregs.x.dx = FP_OFF(&file_name);        segregs.es = FP_SEG(&p_block);	inregs.x.bx = FP_OFF(&p_block);        /* setup load segment -- must be normalized */	p_block.load_seg = norm_seg;	p_block.reloc_seg = p_block.load_seg;        /* call the MS-DOS loader */	errcode = intdosx(&inregs,&outregs,&segregs);        errcode = errcode;        /* check for error */	if (outregs.x.cflag) return(ERR_SUP_LDFAIL);	/* load successful */	return(OK);}/* END OF FILE */device_id1,0
/***********************************************************************	MPX: The MultiProgramming eXecutive	Project to Accompany	A Practical Approach to Operating Systems	Malcolm G. Lane & James D. Mooney	Copyright 1993, P.W.S. Kent Publishing Co., Boston, MA.		File Name: mpx_supt.c	Authors: J.J. Patnesky, A. Ghosal, M. Lane, J. Mooney	Version: 2.1b	Date: 01/31/08	Purpose: Support routines for MPX-PC		Modules: all	Environment:      IBM-PC (XT, AT or PS/2)			MS-DOS 3.3 or later			TURBO-C 3.0 or TURBO-C++ 1.0 or later	Compile using the LARGE MODEL and SS NOT equal to DS.	All addresses and pointers are "far", and	CS, DS and SS are independent.	Procedures in this file:		sys_init		sys_exit		sys_set_vec		sys_req		sys_alloc_mem		sys_free_mem		sys_get_date		sys_set_date		sys_open_dir		sys_get_entry		sys_close_dir	       sys_check_program	       sys_load_program************************************************************************Change Log:	07/16/88  akg	added comments	02/25/92  jdm	full revision, UNIX version	04/14/92  jdm	Macintosh version	05/15/92  jdm	cleanup and documentation	07/14/92  jdm	update for revised specs        08/13/92  jdm 	revised IBM version; added private heap        10/14/92  jdm 	added check and load procedures        10/18/92  jdm 	revised sys_alloc_mem for alignment	11/17/92  jdm	true heap mgt, aligned, using calloc & free	11/19/92  jdm	enable device handling for final module	12/31/92  jdm	revised sys_req parameters	01/02/93  jdm	return count value after I/O	01/03/93  jdm	revised error names and codes	01/27/93  jdm	corrected count for line input in sys_req			fixed open_dir to handle null lines	02/24/93  jdm	changed sys_set_vec param to interrupt	03/08/93  jdm	corrections to sys_check & sys_load	03/20/93  jdm	stack switch in free, check, and load	04/22/93  jdm	corrected index conflict in sys_free_mem			added safety escape in alloc table search	07/28/93  jdm	conversion to large model	09/01/93  jdm	fixed allocation bug;  made date private	09/14/93  jdm	cleaned up memory allocation        09/16/93  jdm	adjusted program load for large model        09/30/93  jdm	modified for correct list of root directory	11/01/94  jdm	changed load file read to binary	09/18/95  jdm	fixed get_entry to default to current, not root	01/31/08  jdm   fixed possible overflow problem in get_entry************************************************************************/#include "mpx_supt.h"#include <stdlib.h>#include <dos.h>#include <dir.h>#include <errno.h>#include <conio.h>#include <alloc.h>#define VEC_ADDR (0x60L*4)#define MAX_ALLOC 200#define MAX_XPOS 79#define MAX_YPOS 24#define MAX_PATH_SIZE 50/*	System-dependent type definitions*/typedef unsigned char byte;typedef unsigned int word;typedef unsigned long longword;typedef byte *address;typedef struct params {	int      op_code;	int      device_id;	char     *buf_p;	int      *count_p;	} params;/*	Global variables accessed only by support routines*/	static longword vec_save;  /* saved interrupt vector */	static int mod_code;                /* module code */                                           	static struct date sys_date;        /* MPX system date */	/* data structures for directory access */        static char current_path[MAX_PATH_SIZE+1];        static int num_entries;        static struct ffblk file_block;        /* handler presence flags */	static flag sysc_hand;	static flag trm_hand;	static flag prt_hand;	static flag com_hand;        /* memory allocation table */	static struct {		void* original;		void* aligned;	} alloc_table[MAX_ALLOC];	static int alloc_ix;                /* current index */	static int num_alloc;               /* no. of allocated blocks *//*	Procedure: sys_init	Purpose: initialize mpx	Parameters: see prototype  	Return value: error code, or OK if no error	Calls: getdate    	Globals: mod_code		vec_save		sys_date		alloc_table, alloc_ix, num_alloc		sysc_hand, term_hand, prt_hand, com_hand	Errors: none*/int sys_init (    int      modules  /* module code */	     ){	mod_code = modules;        vec_save = 0L;        /* no handlers detected yet */	sysc_hand = FALSE;	trm_hand = FALSE;	prt_hand = FALSE;	com_hand = FALSE;	/* initialize allocation table */	for (alloc_ix=0; alloc_ix < MAX_ALLOC; alloc_ix++) {		alloc_table[alloc_ix].original = NULL;		alloc_table[alloc_ix].aligned = NULL;	}	alloc_ix = 0;	num_alloc = 0;	/* if we have reached Module R3, enable system call handling */	if (modules >= MODULE_R3) sysc_hand = TRUE;	/* if we have reached the final module, enable device handlers */	if (modules >= MODULE_F) {		trm_hand = TRUE;		prt_hand = TRUE;		com_hand = TRUE;	}	/* get system date */        getdate(&sys_date);	return (OK);}/*	Procedure: sys_exit	Purpose: terminate mpx	Parameters: none  	Return value: none	Calls: none       	Globals: vec_save*/void sys_exit(void){	longword *vec_p;	/* if trap vector changed, restore it */	if (vec_save != 0L) {		vec_p = (longword*) VEC_ADDR;		*vec_p = vec_save;	}	/* return to host with null error code */	exit(0);}/*	Procedure: sys_set_vec	Purpose: link trap vector to MPX system call handler	Parameters: handler: addr of handler         	Return value: error code; OK if no error	Calls: none       	Globals: vec_save	Errors: none*/int sys_set_vec   ( void interrupt (*handler)() /* system call handler */		){	longword *vec_p;			vec_p = (longword*) VEC_ADDR;		vec_save = *vec_p;		*vec_p = (longword) handler;	return (0);}/*	Procedure: sys_req	Purpose: Request a system service	Inputs:		op_code           operation code		device_id         device identifier		buf_p             addresso f data buffer		count_p           address of size of buffer	Returns: Result or error code, depending on service		Services supported:	IDLE     null operation				READ     input from a device				WRITE    output to a device				CLEAR    clear terminal screen				GOTOXY   absolute cursor position				EXIT     terminate the caller	Calls:   fgets		strlen			Globals: none		Errors:  ERR_SUP_INVDEV    invalid device		ERR_SUP_INVOPC    invalid operation code		ERR_SUP_INVPOS    invalid character position		ERR_SUP_RDFAIL    read failed		ERR_SUP_WRFAIL    write failed	Description:	For Modules R1 through R4,	this procedure is used only for terminal I/O.	Later modules support both reading and	writing for several devices.	For Modules R1 through R4,	sys_req uses the ANSI C function "fgets."	Later modules may use alternate functions and device drivers.*/int sys_req (   int      op_code, /* operation code */		int      device_id,        /* device id */		char*    buf_p,            /* I/O buffer */		int*     count_p           /* address of count */		){	int      rval;    /* result or error code */	char     *rp;     /* return pointer for fgets */	char     rc;      /* return char for fputc */        params    *param_p; /* pointer to parameter record in stack */	flag     docall;  /* true if system call interrupt wanted */	int      ix;      /* temporary index */	docall = FALSE;	rval = OK;	switch (op_code) {		case IDLE:		if (sysc_hand) docall = TRUE;		break; 				case READ:		switch (device_id) {				case TERMINAL:			if (trm_hand) docall = TRUE;			else {				rp = fgets(buf_p,*count_p,stdin);				if (rp==NULL) rval = ERR_SUP_RDFAIL;				else rval = strlen(buf_p);			}			break;					case COM_PORT:			if (com_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					default:			rval = ERR_SUP_INVDEV;					}		break;	case WRITE:		switch (device_id) {				case TERMINAL:			if (trm_hand) docall = TRUE;			else {				rval = *count_p;				for (ix=0; ix<*count_p; ix++) {					rc = fputc(buf_p[ix],stdout);					if (rc == EOF) {						rval = ERR_SUP_WRFAIL;						break;					}				}			}			break;					case COM_PORT:			if (com_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					case PRINTER:			if (prt_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					default:			rval = ERR_SUP_INVDEV;					}		break;	case CLEAR:		if (device_id==TERMINAL) {			if (trm_hand) docall = TRUE;			else {			     clrscr();				rval = 0;			}		}		else rval = ERR_SUP_INVDEV;		break;			case GOTOXY:		if (device_id==TERMINAL) {			if (trm_hand) docall = TRUE;			else {				if (*count_p != 2) rval = ERR_SUP_WRFAIL;				else if ((*buf_p<0)					|| (*buf_p > MAX_XPOS))					rval = ERR_SUP_WRFAIL;				else if ((*(buf_p+1)<0)					|| (*(buf_p+1) > MAX_YPOS))					rval = ERR_SUP_WRFAIL;				else {					gotoxy(*buf_p + 1,						*(buf_p+1) + 1);					rval = 0;				}			}		}		else rval = ERR_SUP_INVDEV;		break;			/* EXIT - terminate the calling process */	/* legal only when a system call handler is present */	case EXIT:		if (sysc_hand) docall = TRUE;		else rval = ERR_SUP_INVOPC;		break; 	default:		rval = ERR_SUP_INVOPC;			}		/* Invoke user's call handler if present.	   If the call is an IO request, return will occur	   only after the request is complete.	*/	if (docall && (rval==OK)) {		/* invoke the call handler */	_SP = _SP - sizeof(params);		param_p = (params*) MK_FP(_SS,_SP);	       param_p->op_code = op_code;	       param_p->device_id = device_id;	       param_p->buf_p = buf_p;	       param_p->count_p = count_p;	       geninterrupt(0x60);	       rval = _AX;	       _SP = _SP + sizeof(params);		/* for I/O operations, return count value */		switch(op_code) {		case READ:		case WRITE:		case CLEAR:		case GOTOXY:			rval = *count_p;		}	}	return(rval);}/*	Procedure: sys_alloc_mem	Purpose: Allocate a memory block	Parameters:			size_t size       No. of bytes to allocate	Returns: void* pointer to allocated block;		 null pointer in case of error		 	Calls: calloc		Globals: alloc_table, alloc_ix, num_alloc	For program loading (Module R-4), the blocks must be aligned.	This is achieved by requesting one extra paragraph and	returning the lowest aligned address as the base.  It is	necessary to keep a table of allocated address, original and	aligned, to support correct freeing.	It would seem simpler to use the Turbo-C function allocmem,	which always allocates aligned blocks.  However, allocmem	appears to conflict with the internal allocation of fopen	and other C library routines.*/void *sys_alloc_mem (      size_t   size     /* size in bytes to allocate */		    ){	int ix_save;      /* temp copy of table index */        void *addr;        /* addr returned by calloc (*void) */	word offset;      /* offset of unaligned address */	word seg;         /* segment addr of unaligned address */	void *addr_alig; /* aligned address */	int rem; /* temp for alignment computation */	/* ensure that allocation table is not full */	if (num_alloc >= MAX_ALLOC) {		return(NULL);	}	/* find free entry in allocation table */	ix_save = alloc_ix;	while (alloc_table[alloc_ix].original != NULL) {		alloc_ix++;		if (alloc_ix >= MAX_ALLOC) alloc_ix = 0;		/* safety check -- should never happen! */		if (alloc_ix == ix_save) return(NULL);	}	/* call allocation routine */	/* request 15 extra bytes to ensure alignment is possible */	addr = calloc(size + 15,1);	/* compute aligned base */	offset = FP_OFF(addr);        seg = FP_SEG(addr);	rem = offset % 16;	if (rem > 0) offset = offset + 16 - rem;	addr_alig = MK_FP(seg,offset);	/* insert entries in table */	alloc_table[alloc_ix].original = addr;	alloc_table[alloc_ix].aligned = addr_alig;	/* increment count */	num_alloc++;	return(addr_alig);}/*	Procedure: sys_free_mem	Purpose: free a memory block	Parameters:		void *ptr         ptr to block to allocate	Returns: integer error code; zero if OK		Calls:   free	Globals: alloc_table, num_alloc	Errors:  ERR_SUP_INVMEM    invalid memory block	This procedure receives an aligned address; it must	find and free the corresponding non-aligned one.*/int sys_free_mem (         void     *ptr     /* pointer to block */		 ){	void *free_addr;  /* true (unaligned) block address */	int free_ix;               /* temp table index */	/* ensure valid pointer */	if (ptr==NULL) return(ERR_SUP_INVMEM);	/* Look for the block in the allocation table */	free_addr = NULL;	for (free_ix=0; free_ix<MAX_ALLOC; free_ix++) {		if (alloc_table[free_ix].aligned == ptr) {			free_addr = alloc_table[free_ix].original;			break;		}	}	/* If the block wasn't found, report error */	if (free_addr == NULL) return(ERR_SUP_INVMEM);	/* free the block & clear the table entry */	alloc_table[free_ix].original = NULL;	alloc_table[free_ix].aligned = NULL;        free(free_addr);	/* decrement count */	num_alloc--;	return(OK);}        /*	Procedure: sys_get_date	Purpose: Returns the system date (month, day, year)	Parameters:		date_rec *date_p Pointer to structure of type date	Returns: void		Calls: none		Globals: sys_date        Errors: none*/void sys_get_date (  date_rec*      date_p   /* ptr to date record */		){	date_p->month = sys_date.da_mon;	date_p->day = sys_date.da_day;	date_p->year = sys_date.da_year;}/*	Procedure: sys_set_date	Purpose: Sets the system date (month, day, year)	Parameters:		date_rec *date_p ptr to structure of type date	Returns: error code; OK if no error	Calls:   none        Globals: sys_date	Errors: none*/int sys_set_date (  date_rec*       date_p   /* ptr to date record */		 ){	sys_date.da_mon = date_p->month;        sys_date.da_day = date_p->day;        sys_date.da_year = date_p->year;	return(OK);}/*	Procedure: sys_open_dir	Purpose: open a specified directory	Parameters: char dir_name[]            directory name	Returns: error code; zero if OK	Calls:   findfirst		strncpy  	Globals: current_path, file_block, num_entries	Errors:  ERR_SUP_DIROPN    directory open error		ERR_SUP_INVDIR    invalid directory*/int sys_open_dir (  char  path_name[]        /* directory name */		 ){        char temp_path[MAX_PATH_SIZE];	int res;        int len;        /* ensure there is no directory currently open */	if (current_path[0]!=NULCH) return(ERR_SUP_DIROPN);        /* check pathname for validity */        /* construct temporary search path name */	temp_path[0] = NULCH;	if (path_name != NULL) {		strncpy(temp_path,path_name,MAX_PATH_SIZE-4);	}	/* build wildcard search string */        len = strlen(temp_path);	/* if path is null, use current directory */        if (len==0) strcpy(temp_path,"*.*");	/* handle paths ending in backslash, including root */        else if (temp_path[len-1]=='\\') strcat(temp_path,"*.*");	/* handle paths not ending in backslash */        else strcat(temp_path,"\\*.*");	/* validate the directory by searching for either an ordinary	   file or a directory in it.  This should never fail; even	   empty directories contain the directories "." and ".."	*/		res = findfirst(temp_path, &file_block, FA_DIREC);	if (res!=0)  return(ERR_SUP_INVDIR);        /* save pathname as current, clear entry count */	current_path[0] = NULCH;	if (path_name != NULL) {		strncpy(current_path,path_name,MAX_PATH_SIZE-6);	}	num_entries = 0;	return(OK);}/*	Procedure: sys_get_entry	Purpose: get the next directory entry;	Parameters: char name_buf[]	name buffer		    int buf_size  	buffer capacity		    long *file_size_p	file length buffer         	Returns: error code, or zero if ok	Calls:	findfirst		findnext		strncpy, strcpy, strrchr, strcat    	Globals: current_path, num_entries, file_block	Errors:  ERR_SUP_NOENTR    no such entry*/int sys_get_entry (char    name_buf[],       /* buffer for entry */		   int   buf_size,         /* buffer size */		   long* file_size_p       /* buffer for size value */		  ){	char filename[MAX_PATH_SIZE+1];	int err;        int len;        char *cp;        /* find next MPX file entry, if any */        /* if this is the first call */	if (num_entries==0) {	       /* construct complete search path name */	       len = strlen(current_path);	       if (len==0) strcpy(current_path,"*.MPX");	       else if (current_path[len-1]=='\\') strcat(current_path,"*.MPX");	       else strcat(current_path,"\\*.MPX");	       /* find first entry */		err = findfirst (current_path,&file_block,0);        }        /* otherwise, find next entry */        else err = findnext(&file_block);        if (err<0) return(ERR_SUP_NOENTR);		/* ensure buf_size is not too large */		if (buf_size > MAX_PATH_SIZE) buf_size = MAX_PATH_SIZE;		      /* copy filename to buffer */	filename[buf_size] = NULCH;	strncpy (filename,file_block.ff_name,			 (size_t) buf_size);	/* remove ".MPX" from name */	cp = strrchr(filename, (int) '.');        *cp = NULCH;	/* copy name and size to caller's buffer */        strcpy (name_buf,filename);	*file_size_p = file_block.ff_fsize;        /* count entry */	num_entries++;	return(OK);}/*	Procedure: sys_close_dir	Purpose: close an open directory	Parameters: none	Returns: error code; zero if OK	Calls:   none	Globals: current_path	Errors:  none*/int sys_close_dir (void){	current_path[0] = NULCH;	return(OK);}/*	Procedure: sys_check_program	Purpose: locate and measure a program file	Parameters: see prototype	Returns: program size or error code	Calls:   strlen, strcat		fopen, fread	Globals: none	Errors:  ERR_SUP_NAMLNG    pathname too long		ERR_SUP_FILNFD    file not found		ERR_SUP_FILINV    file invalid*/#define HEADER_SIZE 32int sys_check_program(     char     dir_name[],       /* directory name */			char     prog_name[],      /* program name */			int*     prog_len_p,       /* ptr to prog length */			int*     start_offset_p    /* ptr to start offset */			){        /* buffer for full pathname */	char file_name[MAX_PATH_SIZE+1];        /* buffer for file header */        byte header[HEADER_SIZE];	FILE *file_p;     /* file pointer for C file routines */        int num_read;      /* number of header bytes read */	int file_size;    /* size of complete file */        int header_size;/* size of header */        int code_size;     /* size of program code */        int data_size;     /* size of program data */        int errcode;       /* error code */        /* ensure that path name is not too long */        if ((strlen(dir_name) + strlen(prog_name) + 5)		 > MAX_PATH_SIZE) return(ERR_SUP_NAMLNG);	/* construct path name */	file_name[0] = NULCH;	if (dir_name[0] != NULCH) {		strcat(file_name, dir_name);	        strcat(file_name, "\\");	}        strcat(file_name, prog_name);	strcat(file_name, ".MPX");        /* try to open the file */	errcode = OK;        file_p = fopen(file_name, "rb");        if (file_p == NULL) return(ERR_SUP_FILNFD);	/* read the header, check for EXE signature */        num_read = fread( (void*) header, 1, HEADER_SIZE, file_p);        if (num_read != HEADER_SIZE) {		errcode = ERR_SUP_FILINV;	}        else if ((header[0] != 0x4D) || (header[1] != 0x5A)) {		errcode = ERR_SUP_FILINV;	}        /* close the file, then return if error occurred */        fclose(file_p);	if (errcode!=OK) return(errcode);        /* compute allocation size needed */        file_size = (header[5]*256 + header[4] -1) * 512		+ (header[3]*256 + header[2]);        header_size =(header[9]*256 + header[8])*16;        code_size = file_size - header_size;        data_size = (header[11]*256 + header[10])*16;        /* return total length and starting offset */        *prog_len_p = code_size + data_size;	*start_offset_p = (header[23]*256 + header[22]) * 16;	return(OK);}/*	Procedure: sys_load_program	Purpose: load a program file	Parameters: see prototype	Returns: error code; zero if OK	Calls:   intdosx		segread		strlen, strcat	Globals: none 	Errors:  ERR_SUP_NAMLNG    name too long		ERR_SUP_FILNFD    file not found	       ERR_SUP_FILINV      file invalid		ERR_SUP_PROGSZ    program too large	       ERR_SUP_LDADDR      address not aligned		ERR_SUP_LDFAIL    load failed*/int sys_load_program (     void*    load_addr,        /* address for loading */			int      max_size,         /* memory size */			char     dir_name[],       /* directory name */			char     prog_name[]       /* program name */		      ){	int errcode;      /* error code */        int prog_len;      /* program length */	int offset;       /* offset for starting */	word norm_seg;    /* normalized load address segment */        word norm_off;     /* normalized load address offset */        /* full pathname for file to be loaded */	char file_name[MAX_PATH_SIZE+1];        /* parameter block for MSDOS EXEC function */	struct {		word load_seg;    /* segment address for loading */	       word reloc_seg;     /* segment address for relocation */        }p_block;	union REGS inregs;            /* input register structure */	union REGS outregs;           /* output register structure */	struct SREGS segregs;         /* segment register structure */        /* check program, get length and offset */	errcode = sys_check_program(dir_name, prog_name,					&prog_len, &offset);        if (errcode < 0) return(errcode);        /* ensure that allocated memory is large enough */        if (max_size < prog_len) return(ERR_SUP_PROGSZ);        /* get normalized segment and offset, check alignment */	norm_seg = FP_SEG(load_addr);	norm_off = FP_OFF(load_addr);	norm_seg += norm_off / 16;        norm_off %= 16;	if (norm_off != 0) return(ERR_SUP_LDADDR);        /* ensure that path name is not too long */        if ((strlen(dir_name) + strlen(prog_name) + 5)		 > MAX_PATH_SIZE) return(ERR_SUP_NAMLNG);	/* construct path name */	file_name[0] = NULCH;	if (dir_name[0] != NULCH) {		strcat(file_name, dir_name);	        strcat(file_name, "\\");	}        strcat(file_name, prog_name);	strcat(file_name, ".MPX");        /* get current segment regs */	segread(&segregs);        /* setup function codes */	inregs.h.ah = 0x4B;        /* EXEC function */	inregs.h.al = 0x03;        /* load only */        /* setup parameter block and name pointers */        segregs.ds = FP_SEG(&file_name);	inregs.x.dx = FP_OFF(&file_name);        segregs.es = FP_SEG(&p_block);	inregs.x.bx = FP_OFF(&p_block);        /* setup load segment -- must be normalized */	p_block.load_seg = norm_seg;	p_block.reloc_seg = p_block.load_seg;        /* call the MS-DOS loader */	errcode = intdosx(&inregs,&outregs,&segregs);        errcode = errcode;        /* check for error */	if (outregs.x.cflag) return(ERR_SUP_LDFAIL);	/* load successful */	return(OK);}/* END OF FILE */buf_p1,0
/***********************************************************************	MPX: The MultiProgramming eXecutive	Project to Accompany	A Practical Approach to Operating Systems	Malcolm G. Lane & James D. Mooney	Copyright 1993, P.W.S. Kent Publishing Co., Boston, MA.		File Name: mpx_supt.c	Authors: J.J. Patnesky, A. Ghosal, M. Lane, J. Mooney	Version: 2.1b	Date: 01/31/08	Purpose: Support routines for MPX-PC		Modules: all	Environment:      IBM-PC (XT, AT or PS/2)			MS-DOS 3.3 or later			TURBO-C 3.0 or TURBO-C++ 1.0 or later	Compile using the LARGE MODEL and SS NOT equal to DS.	All addresses and pointers are "far", and	CS, DS and SS are independent.	Procedures in this file:		sys_init		sys_exit		sys_set_vec		sys_req		sys_alloc_mem		sys_free_mem		sys_get_date		sys_set_date		sys_open_dir		sys_get_entry		sys_close_dir	       sys_check_program	       sys_load_program************************************************************************Change Log:	07/16/88  akg	added comments	02/25/92  jdm	full revision, UNIX version	04/14/92  jdm	Macintosh version	05/15/92  jdm	cleanup and documentation	07/14/92  jdm	update for revised specs        08/13/92  jdm 	revised IBM version; added private heap        10/14/92  jdm 	added check and load procedures        10/18/92  jdm 	revised sys_alloc_mem for alignment	11/17/92  jdm	true heap mgt, aligned, using calloc & free	11/19/92  jdm	enable device handling for final module	12/31/92  jdm	revised sys_req parameters	01/02/93  jdm	return count value after I/O	01/03/93  jdm	revised error names and codes	01/27/93  jdm	corrected count for line input in sys_req			fixed open_dir to handle null lines	02/24/93  jdm	changed sys_set_vec param to interrupt	03/08/93  jdm	corrections to sys_check & sys_load	03/20/93  jdm	stack switch in free, check, and load	04/22/93  jdm	corrected index conflict in sys_free_mem			added safety escape in alloc table search	07/28/93  jdm	conversion to large model	09/01/93  jdm	fixed allocation bug;  made date private	09/14/93  jdm	cleaned up memory allocation        09/16/93  jdm	adjusted program load for large model        09/30/93  jdm	modified for correct list of root directory	11/01/94  jdm	changed load file read to binary	09/18/95  jdm	fixed get_entry to default to current, not root	01/31/08  jdm   fixed possible overflow problem in get_entry************************************************************************/#include "mpx_supt.h"#include <stdlib.h>#include <dos.h>#include <dir.h>#include <errno.h>#include <conio.h>#include <alloc.h>#define VEC_ADDR (0x60L*4)#define MAX_ALLOC 200#define MAX_XPOS 79#define MAX_YPOS 24#define MAX_PATH_SIZE 50/*	System-dependent type definitions*/typedef unsigned char byte;typedef unsigned int word;typedef unsigned long longword;typedef byte *address;typedef struct params {	int      op_code;	int      device_id;	char     *buf_p;	int      *count_p;	} params;/*	Global variables accessed only by support routines*/	static longword vec_save;  /* saved interrupt vector */	static int mod_code;                /* module code */                                           	static struct date sys_date;        /* MPX system date */	/* data structures for directory access */        static char current_path[MAX_PATH_SIZE+1];        static int num_entries;        static struct ffblk file_block;        /* handler presence flags */	static flag sysc_hand;	static flag trm_hand;	static flag prt_hand;	static flag com_hand;        /* memory allocation table */	static struct {		void* original;		void* aligned;	} alloc_table[MAX_ALLOC];	static int alloc_ix;                /* current index */	static int num_alloc;               /* no. of allocated blocks *//*	Procedure: sys_init	Purpose: initialize mpx	Parameters: see prototype  	Return value: error code, or OK if no error	Calls: getdate    	Globals: mod_code		vec_save		sys_date		alloc_table, alloc_ix, num_alloc		sysc_hand, term_hand, prt_hand, com_hand	Errors: none*/int sys_init (    int      modules  /* module code */	     ){	mod_code = modules;        vec_save = 0L;        /* no handlers detected yet */	sysc_hand = FALSE;	trm_hand = FALSE;	prt_hand = FALSE;	com_hand = FALSE;	/* initialize allocation table */	for (alloc_ix=0; alloc_ix < MAX_ALLOC; alloc_ix++) {		alloc_table[alloc_ix].original = NULL;		alloc_table[alloc_ix].aligned = NULL;	}	alloc_ix = 0;	num_alloc = 0;	/* if we have reached Module R3, enable system call handling */	if (modules >= MODULE_R3) sysc_hand = TRUE;	/* if we have reached the final module, enable device handlers */	if (modules >= MODULE_F) {		trm_hand = TRUE;		prt_hand = TRUE;		com_hand = TRUE;	}	/* get system date */        getdate(&sys_date);	return (OK);}/*	Procedure: sys_exit	Purpose: terminate mpx	Parameters: none  	Return value: none	Calls: none       	Globals: vec_save*/void sys_exit(void){	longword *vec_p;	/* if trap vector changed, restore it */	if (vec_save != 0L) {		vec_p = (longword*) VEC_ADDR;		*vec_p = vec_save;	}	/* return to host with null error code */	exit(0);}/*	Procedure: sys_set_vec	Purpose: link trap vector to MPX system call handler	Parameters: handler: addr of handler         	Return value: error code; OK if no error	Calls: none       	Globals: vec_save	Errors: none*/int sys_set_vec   ( void interrupt (*handler)() /* system call handler */		){	longword *vec_p;			vec_p = (longword*) VEC_ADDR;		vec_save = *vec_p;		*vec_p = (longword) handler;	return (0);}/*	Procedure: sys_req	Purpose: Request a system service	Inputs:		op_code           operation code		device_id         device identifier		buf_p             addresso f data buffer		count_p           address of size of buffer	Returns: Result or error code, depending on service		Services supported:	IDLE     null operation				READ     input from a device				WRITE    output to a device				CLEAR    clear terminal screen				GOTOXY   absolute cursor position				EXIT     terminate the caller	Calls:   fgets		strlen			Globals: none		Errors:  ERR_SUP_INVDEV    invalid device		ERR_SUP_INVOPC    invalid operation code		ERR_SUP_INVPOS    invalid character position		ERR_SUP_RDFAIL    read failed		ERR_SUP_WRFAIL    write failed	Description:	For Modules R1 through R4,	this procedure is used only for terminal I/O.	Later modules support both reading and	writing for several devices.	For Modules R1 through R4,	sys_req uses the ANSI C function "fgets."	Later modules may use alternate functions and device drivers.*/int sys_req (   int      op_code, /* operation code */		int      device_id,        /* device id */		char*    buf_p,            /* I/O buffer */		int*     count_p           /* address of count */		){	int      rval;    /* result or error code */	char     *rp;     /* return pointer for fgets */	char     rc;      /* return char for fputc */        params    *param_p; /* pointer to parameter record in stack */	flag     docall;  /* true if system call interrupt wanted */	int      ix;      /* temporary index */	docall = FALSE;	rval = OK;	switch (op_code) {		case IDLE:		if (sysc_hand) docall = TRUE;		break; 				case READ:		switch (device_id) {				case TERMINAL:			if (trm_hand) docall = TRUE;			else {				rp = fgets(buf_p,*count_p,stdin);				if (rp==NULL) rval = ERR_SUP_RDFAIL;				else rval = strlen(buf_p);			}			break;					case COM_PORT:			if (com_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					default:			rval = ERR_SUP_INVDEV;					}		break;	case WRITE:		switch (device_id) {				case TERMINAL:			if (trm_hand) docall = TRUE;			else {				rval = *count_p;				for (ix=0; ix<*count_p; ix++) {					rc = fputc(buf_p[ix],stdout);					if (rc == EOF) {						rval = ERR_SUP_WRFAIL;						break;					}				}			}			break;					case COM_PORT:			if (com_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					case PRINTER:			if (prt_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					default:			rval = ERR_SUP_INVDEV;					}		break;	case CLEAR:		if (device_id==TERMINAL) {			if (trm_hand) docall = TRUE;			else {			     clrscr();				rval = 0;			}		}		else rval = ERR_SUP_INVDEV;		break;			case GOTOXY:		if (device_id==TERMINAL) {			if (trm_hand) docall = TRUE;			else {				if (*count_p != 2) rval = ERR_SUP_WRFAIL;				else if ((*buf_p<0)					|| (*buf_p > MAX_XPOS))					rval = ERR_SUP_WRFAIL;				else if ((*(buf_p+1)<0)					|| (*(buf_p+1) > MAX_YPOS))					rval = ERR_SUP_WRFAIL;				else {					gotoxy(*buf_p + 1,						*(buf_p+1) + 1);					rval = 0;				}			}		}		else rval = ERR_SUP_INVDEV;		break;			/* EXIT - terminate the calling process */	/* legal only when a system call handler is present */	case EXIT:		if (sysc_hand) docall = TRUE;		else rval = ERR_SUP_INVOPC;		break; 	default:		rval = ERR_SUP_INVOPC;			}		/* Invoke user's call handler if present.	   If the call is an IO request, return will occur	   only after the request is complete.	*/	if (docall && (rval==OK)) {		/* invoke the call handler */	_SP = _SP - sizeof(params);		param_p = (params*) MK_FP(_SS,_SP);	       param_p->op_code = op_code;	       param_p->device_id = device_id;	       param_p->buf_p = buf_p;	       param_p->count_p = count_p;	       geninterrupt(0x60);	       rval = _AX;	       _SP = _SP + sizeof(params);		/* for I/O operations, return count value */		switch(op_code) {		case READ:		case WRITE:		case CLEAR:		case GOTOXY:			rval = *count_p;		}	}	return(rval);}/*	Procedure: sys_alloc_mem	Purpose: Allocate a memory block	Parameters:			size_t size       No. of bytes to allocate	Returns: void* pointer to allocated block;		 null pointer in case of error		 	Calls: calloc		Globals: alloc_table, alloc_ix, num_alloc	For program loading (Module R-4), the blocks must be aligned.	This is achieved by requesting one extra paragraph and	returning the lowest aligned address as the base.  It is	necessary to keep a table of allocated address, original and	aligned, to support correct freeing.	It would seem simpler to use the Turbo-C function allocmem,	which always allocates aligned blocks.  However, allocmem	appears to conflict with the internal allocation of fopen	and other C library routines.*/void *sys_alloc_mem (      size_t   size     /* size in bytes to allocate */		    ){	int ix_save;      /* temp copy of table index */        void *addr;        /* addr returned by calloc (*void) */	word offset;      /* offset of unaligned address */	word seg;         /* segment addr of unaligned address */	void *addr_alig; /* aligned address */	int rem; /* temp for alignment computation */	/* ensure that allocation table is not full */	if (num_alloc >= MAX_ALLOC) {		return(NULL);	}	/* find free entry in allocation table */	ix_save = alloc_ix;	while (alloc_table[alloc_ix].original != NULL) {		alloc_ix++;		if (alloc_ix >= MAX_ALLOC) alloc_ix = 0;		/* safety check -- should never happen! */		if (alloc_ix == ix_save) return(NULL);	}	/* call allocation routine */	/* request 15 extra bytes to ensure alignment is possible */	addr = calloc(size + 15,1);	/* compute aligned base */	offset = FP_OFF(addr);        seg = FP_SEG(addr);	rem = offset % 16;	if (rem > 0) offset = offset + 16 - rem;	addr_alig = MK_FP(seg,offset);	/* insert entries in table */	alloc_table[alloc_ix].original = addr;	alloc_table[alloc_ix].aligned = addr_alig;	/* increment count */	num_alloc++;	return(addr_alig);}/*	Procedure: sys_free_mem	Purpose: free a memory block	Parameters:		void *ptr         ptr to block to allocate	Returns: integer error code; zero if OK		Calls:   free	Globals: alloc_table, num_alloc	Errors:  ERR_SUP_INVMEM    invalid memory block	This procedure receives an aligned address; it must	find and free the corresponding non-aligned one.*/int sys_free_mem (         void     *ptr     /* pointer to block */		 ){	void *free_addr;  /* true (unaligned) block address */	int free_ix;               /* temp table index */	/* ensure valid pointer */	if (ptr==NULL) return(ERR_SUP_INVMEM);	/* Look for the block in the allocation table */	free_addr = NULL;	for (free_ix=0; free_ix<MAX_ALLOC; free_ix++) {		if (alloc_table[free_ix].aligned == ptr) {			free_addr = alloc_table[free_ix].original;			break;		}	}	/* If the block wasn't found, report error */	if (free_addr == NULL) return(ERR_SUP_INVMEM);	/* free the block & clear the table entry */	alloc_table[free_ix].original = NULL;	alloc_table[free_ix].aligned = NULL;        free(free_addr);	/* decrement count */	num_alloc--;	return(OK);}        /*	Procedure: sys_get_date	Purpose: Returns the system date (month, day, year)	Parameters:		date_rec *date_p Pointer to structure of type date	Returns: void		Calls: none		Globals: sys_date        Errors: none*/void sys_get_date (  date_rec*      date_p   /* ptr to date record */		){	date_p->month = sys_date.da_mon;	date_p->day = sys_date.da_day;	date_p->year = sys_date.da_year;}/*	Procedure: sys_set_date	Purpose: Sets the system date (month, day, year)	Parameters:		date_rec *date_p ptr to structure of type date	Returns: error code; OK if no error	Calls:   none        Globals: sys_date	Errors: none*/int sys_set_date (  date_rec*       date_p   /* ptr to date record */		 ){	sys_date.da_mon = date_p->month;        sys_date.da_day = date_p->day;        sys_date.da_year = date_p->year;	return(OK);}/*	Procedure: sys_open_dir	Purpose: open a specified directory	Parameters: char dir_name[]            directory name	Returns: error code; zero if OK	Calls:   findfirst		strncpy  	Globals: current_path, file_block, num_entries	Errors:  ERR_SUP_DIROPN    directory open error		ERR_SUP_INVDIR    invalid directory*/int sys_open_dir (  char  path_name[]        /* directory name */		 ){        char temp_path[MAX_PATH_SIZE];	int res;        int len;        /* ensure there is no directory currently open */	if (current_path[0]!=NULCH) return(ERR_SUP_DIROPN);        /* check pathname for validity */        /* construct temporary search path name */	temp_path[0] = NULCH;	if (path_name != NULL) {		strncpy(temp_path,path_name,MAX_PATH_SIZE-4);	}	/* build wildcard search string */        len = strlen(temp_path);	/* if path is null, use current directory */        if (len==0) strcpy(temp_path,"*.*");	/* handle paths ending in backslash, including root */        else if (temp_path[len-1]=='\\') strcat(temp_path,"*.*");	/* handle paths not ending in backslash */        else strcat(temp_path,"\\*.*");	/* validate the directory by searching for either an ordinary	   file or a directory in it.  This should never fail; even	   empty directories contain the directories "." and ".."	*/		res = findfirst(temp_path, &file_block, FA_DIREC);	if (res!=0)  return(ERR_SUP_INVDIR);        /* save pathname as current, clear entry count */	current_path[0] = NULCH;	if (path_name != NULL) {		strncpy(current_path,path_name,MAX_PATH_SIZE-6);	}	num_entries = 0;	return(OK);}/*	Procedure: sys_get_entry	Purpose: get the next directory entry;	Parameters: char name_buf[]	name buffer		    int buf_size  	buffer capacity		    long *file_size_p	file length buffer         	Returns: error code, or zero if ok	Calls:	findfirst		findnext		strncpy, strcpy, strrchr, strcat    	Globals: current_path, num_entries, file_block	Errors:  ERR_SUP_NOENTR    no such entry*/int sys_get_entry (char    name_buf[],       /* buffer for entry */		   int   buf_size,         /* buffer size */		   long* file_size_p       /* buffer for size value */		  ){	char filename[MAX_PATH_SIZE+1];	int err;        int len;        char *cp;        /* find next MPX file entry, if any */        /* if this is the first call */	if (num_entries==0) {	       /* construct complete search path name */	       len = strlen(current_path);	       if (len==0) strcpy(current_path,"*.MPX");	       else if (current_path[len-1]=='\\') strcat(current_path,"*.MPX");	       else strcat(current_path,"\\*.MPX");	       /* find first entry */		err = findfirst (current_path,&file_block,0);        }        /* otherwise, find next entry */        else err = findnext(&file_block);        if (err<0) return(ERR_SUP_NOENTR);		/* ensure buf_size is not too large */		if (buf_size > MAX_PATH_SIZE) buf_size = MAX_PATH_SIZE;		      /* copy filename to buffer */	filename[buf_size] = NULCH;	strncpy (filename,file_block.ff_name,			 (size_t) buf_size);	/* remove ".MPX" from name */	cp = strrchr(filename, (int) '.');        *cp = NULCH;	/* copy name and size to caller's buffer */        strcpy (name_buf,filename);	*file_size_p = file_block.ff_fsize;        /* count entry */	num_entries++;	return(OK);}/*	Procedure: sys_close_dir	Purpose: close an open directory	Parameters: none	Returns: error code; zero if OK	Calls:   none	Globals: current_path	Errors:  none*/int sys_close_dir (void){	current_path[0] = NULCH;	return(OK);}/*	Procedure: sys_check_program	Purpose: locate and measure a program file	Parameters: see prototype	Returns: program size or error code	Calls:   strlen, strcat		fopen, fread	Globals: none	Errors:  ERR_SUP_NAMLNG    pathname too long		ERR_SUP_FILNFD    file not found		ERR_SUP_FILINV    file invalid*/#define HEADER_SIZE 32int sys_check_program(     char     dir_name[],       /* directory name */			char     prog_name[],      /* program name */			int*     prog_len_p,       /* ptr to prog length */			int*     start_offset_p    /* ptr to start offset */			){        /* buffer for full pathname */	char file_name[MAX_PATH_SIZE+1];        /* buffer for file header */        byte header[HEADER_SIZE];	FILE *file_p;     /* file pointer for C file routines */        int num_read;      /* number of header bytes read */	int file_size;    /* size of complete file */        int header_size;/* size of header */        int code_size;     /* size of program code */        int data_size;     /* size of program data */        int errcode;       /* error code */        /* ensure that path name is not too long */        if ((strlen(dir_name) + strlen(prog_name) + 5)		 > MAX_PATH_SIZE) return(ERR_SUP_NAMLNG);	/* construct path name */	file_name[0] = NULCH;	if (dir_name[0] != NULCH) {		strcat(file_name, dir_name);	        strcat(file_name, "\\");	}        strcat(file_name, prog_name);	strcat(file_name, ".MPX");        /* try to open the file */	errcode = OK;        file_p = fopen(file_name, "rb");        if (file_p == NULL) return(ERR_SUP_FILNFD);	/* read the header, check for EXE signature */        num_read = fread( (void*) header, 1, HEADER_SIZE, file_p);        if (num_read != HEADER_SIZE) {		errcode = ERR_SUP_FILINV;	}        else if ((header[0] != 0x4D) || (header[1] != 0x5A)) {		errcode = ERR_SUP_FILINV;	}        /* close the file, then return if error occurred */        fclose(file_p);	if (errcode!=OK) return(errcode);        /* compute allocation size needed */        file_size = (header[5]*256 + header[4] -1) * 512		+ (header[3]*256 + header[2]);        header_size =(header[9]*256 + header[8])*16;        code_size = file_size - header_size;        data_size = (header[11]*256 + header[10])*16;        /* return total length and starting offset */        *prog_len_p = code_size + data_size;	*start_offset_p = (header[23]*256 + header[22]) * 16;	return(OK);}/*	Procedure: sys_load_program	Purpose: load a program file	Parameters: see prototype	Returns: error code; zero if OK	Calls:   intdosx		segread		strlen, strcat	Globals: none 	Errors:  ERR_SUP_NAMLNG    name too long		ERR_SUP_FILNFD    file not found	       ERR_SUP_FILINV      file invalid		ERR_SUP_PROGSZ    program too large	       ERR_SUP_LDADDR      address not aligned		ERR_SUP_LDFAIL    load failed*/int sys_load_program (     void*    load_addr,        /* address for loading */			int      max_size,         /* memory size */			char     dir_name[],       /* directory name */			char     prog_name[]       /* program name */		      ){	int errcode;      /* error code */        int prog_len;      /* program length */	int offset;       /* offset for starting */	word norm_seg;    /* normalized load address segment */        word norm_off;     /* normalized load address offset */        /* full pathname for file to be loaded */	char file_name[MAX_PATH_SIZE+1];        /* parameter block for MSDOS EXEC function */	struct {		word load_seg;    /* segment address for loading */	       word reloc_seg;     /* segment address for relocation */        }p_block;	union REGS inregs;            /* input register structure */	union REGS outregs;           /* output register structure */	struct SREGS segregs;         /* segment register structure */        /* check program, get length and offset */	errcode = sys_check_program(dir_name, prog_name,					&prog_len, &offset);        if (errcode < 0) return(errcode);        /* ensure that allocated memory is large enough */        if (max_size < prog_len) return(ERR_SUP_PROGSZ);        /* get normalized segment and offset, check alignment */	norm_seg = FP_SEG(load_addr);	norm_off = FP_OFF(load_addr);	norm_seg += norm_off / 16;        norm_off %= 16;	if (norm_off != 0) return(ERR_SUP_LDADDR);        /* ensure that path name is not too long */        if ((strlen(dir_name) + strlen(prog_name) + 5)		 > MAX_PATH_SIZE) return(ERR_SUP_NAMLNG);	/* construct path name */	file_name[0] = NULCH;	if (dir_name[0] != NULCH) {		strcat(file_name, dir_name);	        strcat(file_name, "\\");	}        strcat(file_name, prog_name);	strcat(file_name, ".MPX");        /* get current segment regs */	segread(&segregs);        /* setup function codes */	inregs.h.ah = 0x4B;        /* EXEC function */	inregs.h.al = 0x03;        /* load only */        /* setup parameter block and name pointers */        segregs.ds = FP_SEG(&file_name);	inregs.x.dx = FP_OFF(&file_name);        segregs.es = FP_SEG(&p_block);	inregs.x.bx = FP_OFF(&p_block);        /* setup load segment -- must be normalized */	p_block.load_seg = norm_seg;	p_block.reloc_seg = p_block.load_seg;        /* call the MS-DOS loader */	errcode = intdosx(&inregs,&outregs,&segregs);        errcode = errcode;        /* check for error */	if (outregs.x.cflag) return(ERR_SUP_LDFAIL);	/* load successful */	return(OK);}/* END OF FILE */count_p1,0
/***********************************************************************	MPX: The MultiProgramming eXecutive	Project to Accompany	A Practical Approach to Operating Systems	Malcolm G. Lane & James D. Mooney	Copyright 1993, P.W.S. Kent Publishing Co., Boston, MA.		File Name: mpx_supt.c	Authors: J.J. Patnesky, A. Ghosal, M. Lane, J. Mooney	Version: 2.1b	Date: 01/31/08	Purpose: Support routines for MPX-PC		Modules: all	Environment:      IBM-PC (XT, AT or PS/2)			MS-DOS 3.3 or later			TURBO-C 3.0 or TURBO-C++ 1.0 or later	Compile using the LARGE MODEL and SS NOT equal to DS.	All addresses and pointers are "far", and	CS, DS and SS are independent.	Procedures in this file:		sys_init		sys_exit		sys_set_vec		sys_req		sys_alloc_mem		sys_free_mem		sys_get_date		sys_set_date		sys_open_dir		sys_get_entry		sys_close_dir	       sys_check_program	       sys_load_program************************************************************************Change Log:	07/16/88  akg	added comments	02/25/92  jdm	full revision, UNIX version	04/14/92  jdm	Macintosh version	05/15/92  jdm	cleanup and documentation	07/14/92  jdm	update for revised specs        08/13/92  jdm 	revised IBM version; added private heap        10/14/92  jdm 	added check and load procedures        10/18/92  jdm 	revised sys_alloc_mem for alignment	11/17/92  jdm	true heap mgt, aligned, using calloc & free	11/19/92  jdm	enable device handling for final module	12/31/92  jdm	revised sys_req parameters	01/02/93  jdm	return count value after I/O	01/03/93  jdm	revised error names and codes	01/27/93  jdm	corrected count for line input in sys_req			fixed open_dir to handle null lines	02/24/93  jdm	changed sys_set_vec param to interrupt	03/08/93  jdm	corrections to sys_check & sys_load	03/20/93  jdm	stack switch in free, check, and load	04/22/93  jdm	corrected index conflict in sys_free_mem			added safety escape in alloc table search	07/28/93  jdm	conversion to large model	09/01/93  jdm	fixed allocation bug;  made date private	09/14/93  jdm	cleaned up memory allocation        09/16/93  jdm	adjusted program load for large model        09/30/93  jdm	modified for correct list of root directory	11/01/94  jdm	changed load file read to binary	09/18/95  jdm	fixed get_entry to default to current, not root	01/31/08  jdm   fixed possible overflow problem in get_entry************************************************************************/#include "mpx_supt.h"#include <stdlib.h>#include <dos.h>#include <dir.h>#include <errno.h>#include <conio.h>#include <alloc.h>#define VEC_ADDR (0x60L*4)#define MAX_ALLOC 200#define MAX_XPOS 79#define MAX_YPOS 24#define MAX_PATH_SIZE 50/*	System-dependent type definitions*/typedef unsigned char byte;typedef unsigned int word;typedef unsigned long longword;typedef byte *address;typedef struct params {	int      op_code;	int      device_id;	char     *buf_p;	int      *count_p;	} params;/*	Global variables accessed only by support routines*/	static longword vec_save;  /* saved interrupt vector */	static int mod_code;                /* module code */                                           	static struct date sys_date;        /* MPX system date */	/* data structures for directory access */        static char current_path[MAX_PATH_SIZE+1];        static int num_entries;        static struct ffblk file_block;        /* handler presence flags */	static flag sysc_hand;	static flag trm_hand;	static flag prt_hand;	static flag com_hand;        /* memory allocation table */	static struct {		void* original;		void* aligned;	} alloc_table[MAX_ALLOC];	static int alloc_ix;                /* current index */	static int num_alloc;               /* no. of allocated blocks *//*	Procedure: sys_init	Purpose: initialize mpx	Parameters: see prototype  	Return value: error code, or OK if no error	Calls: getdate    	Globals: mod_code		vec_save		sys_date		alloc_table, alloc_ix, num_alloc		sysc_hand, term_hand, prt_hand, com_hand	Errors: none*/int sys_init (    int      modules  /* module code */	     ){	mod_code = modules;        vec_save = 0L;        /* no handlers detected yet */	sysc_hand = FALSE;	trm_hand = FALSE;	prt_hand = FALSE;	com_hand = FALSE;	/* initialize allocation table */	for (alloc_ix=0; alloc_ix < MAX_ALLOC; alloc_ix++) {		alloc_table[alloc_ix].original = NULL;		alloc_table[alloc_ix].aligned = NULL;	}	alloc_ix = 0;	num_alloc = 0;	/* if we have reached Module R3, enable system call handling */	if (modules >= MODULE_R3) sysc_hand = TRUE;	/* if we have reached the final module, enable device handlers */	if (modules >= MODULE_F) {		trm_hand = TRUE;		prt_hand = TRUE;		com_hand = TRUE;	}	/* get system date */        getdate(&sys_date);	return (OK);}/*	Procedure: sys_exit	Purpose: terminate mpx	Parameters: none  	Return value: none	Calls: none       	Globals: vec_save*/void sys_exit(void){	longword *vec_p;	/* if trap vector changed, restore it */	if (vec_save != 0L) {		vec_p = (longword*) VEC_ADDR;		*vec_p = vec_save;	}	/* return to host with null error code */	exit(0);}/*	Procedure: sys_set_vec	Purpose: link trap vector to MPX system call handler	Parameters: handler: addr of handler         	Return value: error code; OK if no error	Calls: none       	Globals: vec_save	Errors: none*/int sys_set_vec   ( void interrupt (*handler)() /* system call handler */		){	longword *vec_p;			vec_p = (longword*) VEC_ADDR;		vec_save = *vec_p;		*vec_p = (longword) handler;	return (0);}/*	Procedure: sys_req	Purpose: Request a system service	Inputs:		op_code           operation code		device_id         device identifier		buf_p             addresso f data buffer		count_p           address of size of buffer	Returns: Result or error code, depending on service		Services supported:	IDLE     null operation				READ     input from a device				WRITE    output to a device				CLEAR    clear terminal screen				GOTOXY   absolute cursor position				EXIT     terminate the caller	Calls:   fgets		strlen			Globals: none		Errors:  ERR_SUP_INVDEV    invalid device		ERR_SUP_INVOPC    invalid operation code		ERR_SUP_INVPOS    invalid character position		ERR_SUP_RDFAIL    read failed		ERR_SUP_WRFAIL    write failed	Description:	For Modules R1 through R4,	this procedure is used only for terminal I/O.	Later modules support both reading and	writing for several devices.	For Modules R1 through R4,	sys_req uses the ANSI C function "fgets."	Later modules may use alternate functions and device drivers.*/int sys_req (   int      op_code, /* operation code */		int      device_id,        /* device id */		char*    buf_p,            /* I/O buffer */		int*     count_p           /* address of count */		){	int      rval;    /* result or error code */	char     *rp;     /* return pointer for fgets */	char     rc;      /* return char for fputc */        params    *param_p; /* pointer to parameter record in stack */	flag     docall;  /* true if system call interrupt wanted */	int      ix;      /* temporary index */	docall = FALSE;	rval = OK;	switch (op_code) {		case IDLE:		if (sysc_hand) docall = TRUE;		break; 				case READ:		switch (device_id) {				case TERMINAL:			if (trm_hand) docall = TRUE;			else {				rp = fgets(buf_p,*count_p,stdin);				if (rp==NULL) rval = ERR_SUP_RDFAIL;				else rval = strlen(buf_p);			}			break;					case COM_PORT:			if (com_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					default:			rval = ERR_SUP_INVDEV;					}		break;	case WRITE:		switch (device_id) {				case TERMINAL:			if (trm_hand) docall = TRUE;			else {				rval = *count_p;				for (ix=0; ix<*count_p; ix++) {					rc = fputc(buf_p[ix],stdout);					if (rc == EOF) {						rval = ERR_SUP_WRFAIL;						break;					}				}			}			break;					case COM_PORT:			if (com_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					case PRINTER:			if (prt_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					default:			rval = ERR_SUP_INVDEV;					}		break;	case CLEAR:		if (device_id==TERMINAL) {			if (trm_hand) docall = TRUE;			else {			     clrscr();				rval = 0;			}		}		else rval = ERR_SUP_INVDEV;		break;			case GOTOXY:		if (device_id==TERMINAL) {			if (trm_hand) docall = TRUE;			else {				if (*count_p != 2) rval = ERR_SUP_WRFAIL;				else if ((*buf_p<0)					|| (*buf_p > MAX_XPOS))					rval = ERR_SUP_WRFAIL;				else if ((*(buf_p+1)<0)					|| (*(buf_p+1) > MAX_YPOS))					rval = ERR_SUP_WRFAIL;				else {					gotoxy(*buf_p + 1,						*(buf_p+1) + 1);					rval = 0;				}			}		}		else rval = ERR_SUP_INVDEV;		break;			/* EXIT - terminate the calling process */	/* legal only when a system call handler is present */	case EXIT:		if (sysc_hand) docall = TRUE;		else rval = ERR_SUP_INVOPC;		break; 	default:		rval = ERR_SUP_INVOPC;			}		/* Invoke user's call handler if present.	   If the call is an IO request, return will occur	   only after the request is complete.	*/	if (docall && (rval==OK)) {		/* invoke the call handler */	_SP = _SP - sizeof(params);		param_p = (params*) MK_FP(_SS,_SP);	       param_p->op_code = op_code;	       param_p->device_id = device_id;	       param_p->buf_p = buf_p;	       param_p->count_p = count_p;	       geninterrupt(0x60);	       rval = _AX;	       _SP = _SP + sizeof(params);		/* for I/O operations, return count value */		switch(op_code) {		case READ:		case WRITE:		case CLEAR:		case GOTOXY:			rval = *count_p;		}	}	return(rval);}/*	Procedure: sys_alloc_mem	Purpose: Allocate a memory block	Parameters:			size_t size       No. of bytes to allocate	Returns: void* pointer to allocated block;		 null pointer in case of error		 	Calls: calloc		Globals: alloc_table, alloc_ix, num_alloc	For program loading (Module R-4), the blocks must be aligned.	This is achieved by requesting one extra paragraph and	returning the lowest aligned address as the base.  It is	necessary to keep a table of allocated address, original and	aligned, to support correct freeing.	It would seem simpler to use the Turbo-C function allocmem,	which always allocates aligned blocks.  However, allocmem	appears to conflict with the internal allocation of fopen	and other C library routines.*/void *sys_alloc_mem (      size_t   size     /* size in bytes to allocate */		    ){	int ix_save;      /* temp copy of table index */        void *addr;        /* addr returned by calloc (*void) */	word offset;      /* offset of unaligned address */	word seg;         /* segment addr of unaligned address */	void *addr_alig; /* aligned address */	int rem; /* temp for alignment computation */	/* ensure that allocation table is not full */	if (num_alloc >= MAX_ALLOC) {		return(NULL);	}	/* find free entry in allocation table */	ix_save = alloc_ix;	while (alloc_table[alloc_ix].original != NULL) {		alloc_ix++;		if (alloc_ix >= MAX_ALLOC) alloc_ix = 0;		/* safety check -- should never happen! */		if (alloc_ix == ix_save) return(NULL);	}	/* call allocation routine */	/* request 15 extra bytes to ensure alignment is possible */	addr = calloc(size + 15,1);	/* compute aligned base */	offset = FP_OFF(addr);        seg = FP_SEG(addr);	rem = offset % 16;	if (rem > 0) offset = offset + 16 - rem;	addr_alig = MK_FP(seg,offset);	/* insert entries in table */	alloc_table[alloc_ix].original = addr;	alloc_table[alloc_ix].aligned = addr_alig;	/* increment count */	num_alloc++;	return(addr_alig);}/*	Procedure: sys_free_mem	Purpose: free a memory block	Parameters:		void *ptr         ptr to block to allocate	Returns: integer error code; zero if OK		Calls:   free	Globals: alloc_table, num_alloc	Errors:  ERR_SUP_INVMEM    invalid memory block	This procedure receives an aligned address; it must	find and free the corresponding non-aligned one.*/int sys_free_mem (         void     *ptr     /* pointer to block */		 ){	void *free_addr;  /* true (unaligned) block address */	int free_ix;               /* temp table index */	/* ensure valid pointer */	if (ptr==NULL) return(ERR_SUP_INVMEM);	/* Look for the block in the allocation table */	free_addr = NULL;	for (free_ix=0; free_ix<MAX_ALLOC; free_ix++) {		if (alloc_table[free_ix].aligned == ptr) {			free_addr = alloc_table[free_ix].original;			break;		}	}	/* If the block wasn't found, report error */	if (free_addr == NULL) return(ERR_SUP_INVMEM);	/* free the block & clear the table entry */	alloc_table[free_ix].original = NULL;	alloc_table[free_ix].aligned = NULL;        free(free_addr);	/* decrement count */	num_alloc--;	return(OK);}        /*	Procedure: sys_get_date	Purpose: Returns the system date (month, day, year)	Parameters:		date_rec *date_p Pointer to structure of type date	Returns: void		Calls: none		Globals: sys_date        Errors: none*/void sys_get_date (  date_rec*      date_p   /* ptr to date record */		){	date_p->month = sys_date.da_mon;	date_p->day = sys_date.da_day;	date_p->year = sys_date.da_year;}/*	Procedure: sys_set_date	Purpose: Sets the system date (month, day, year)	Parameters:		date_rec *date_p ptr to structure of type date	Returns: error code; OK if no error	Calls:   none        Globals: sys_date	Errors: none*/int sys_set_date (  date_rec*       date_p   /* ptr to date record */		 ){	sys_date.da_mon = date_p->month;        sys_date.da_day = date_p->day;        sys_date.da_year = date_p->year;	return(OK);}/*	Procedure: sys_open_dir	Purpose: open a specified directory	Parameters: char dir_name[]            directory name	Returns: error code; zero if OK	Calls:   findfirst		strncpy  	Globals: current_path, file_block, num_entries	Errors:  ERR_SUP_DIROPN    directory open error		ERR_SUP_INVDIR    invalid directory*/int sys_open_dir (  char  path_name[]        /* directory name */		 ){        char temp_path[MAX_PATH_SIZE];	int res;        int len;        /* ensure there is no directory currently open */	if (current_path[0]!=NULCH) return(ERR_SUP_DIROPN);        /* check pathname for validity */        /* construct temporary search path name */	temp_path[0] = NULCH;	if (path_name != NULL) {		strncpy(temp_path,path_name,MAX_PATH_SIZE-4);	}	/* build wildcard search string */        len = strlen(temp_path);	/* if path is null, use current directory */        if (len==0) strcpy(temp_path,"*.*");	/* handle paths ending in backslash, including root */        else if (temp_path[len-1]=='\\') strcat(temp_path,"*.*");	/* handle paths not ending in backslash */        else strcat(temp_path,"\\*.*");	/* validate the directory by searching for either an ordinary	   file or a directory in it.  This should never fail; even	   empty directories contain the directories "." and ".."	*/		res = findfirst(temp_path, &file_block, FA_DIREC);	if (res!=0)  return(ERR_SUP_INVDIR);        /* save pathname as current, clear entry count */	current_path[0] = NULCH;	if (path_name != NULL) {		strncpy(current_path,path_name,MAX_PATH_SIZE-6);	}	num_entries = 0;	return(OK);}/*	Procedure: sys_get_entry	Purpose: get the next directory entry;	Parameters: char name_buf[]	name buffer		    int buf_size  	buffer capacity		    long *file_size_p	file length buffer         	Returns: error code, or zero if ok	Calls:	findfirst		findnext		strncpy, strcpy, strrchr, strcat    	Globals: current_path, num_entries, file_block	Errors:  ERR_SUP_NOENTR    no such entry*/int sys_get_entry (char    name_buf[],       /* buffer for entry */		   int   buf_size,         /* buffer size */		   long* file_size_p       /* buffer for size value */		  ){	char filename[MAX_PATH_SIZE+1];	int err;        int len;        char *cp;        /* find next MPX file entry, if any */        /* if this is the first call */	if (num_entries==0) {	       /* construct complete search path name */	       len = strlen(current_path);	       if (len==0) strcpy(current_path,"*.MPX");	       else if (current_path[len-1]=='\\') strcat(current_path,"*.MPX");	       else strcat(current_path,"\\*.MPX");	       /* find first entry */		err = findfirst (current_path,&file_block,0);        }        /* otherwise, find next entry */        else err = findnext(&file_block);        if (err<0) return(ERR_SUP_NOENTR);		/* ensure buf_size is not too large */		if (buf_size > MAX_PATH_SIZE) buf_size = MAX_PATH_SIZE;		      /* copy filename to buffer */	filename[buf_size] = NULCH;	strncpy (filename,file_block.ff_name,			 (size_t) buf_size);	/* remove ".MPX" from name */	cp = strrchr(filename, (int) '.');        *cp = NULCH;	/* copy name and size to caller's buffer */        strcpy (name_buf,filename);	*file_size_p = file_block.ff_fsize;        /* count entry */	num_entries++;	return(OK);}/*	Procedure: sys_close_dir	Purpose: close an open directory	Parameters: none	Returns: error code; zero if OK	Calls:   none	Globals: current_path	Errors:  none*/int sys_close_dir (void){	current_path[0] = NULCH;	return(OK);}/*	Procedure: sys_check_program	Purpose: locate and measure a program file	Parameters: see prototype	Returns: program size or error code	Calls:   strlen, strcat		fopen, fread	Globals: none	Errors:  ERR_SUP_NAMLNG    pathname too long		ERR_SUP_FILNFD    file not found		ERR_SUP_FILINV    file invalid*/#define HEADER_SIZE 32int sys_check_program(     char     dir_name[],       /* directory name */			char     prog_name[],      /* program name */			int*     prog_len_p,       /* ptr to prog length */			int*     start_offset_p    /* ptr to start offset */			){        /* buffer for full pathname */	char file_name[MAX_PATH_SIZE+1];        /* buffer for file header */        byte header[HEADER_SIZE];	FILE *file_p;     /* file pointer for C file routines */        int num_read;      /* number of header bytes read */	int file_size;    /* size of complete file */        int header_size;/* size of header */        int code_size;     /* size of program code */        int data_size;     /* size of program data */        int errcode;       /* error code */        /* ensure that path name is not too long */        if ((strlen(dir_name) + strlen(prog_name) + 5)		 > MAX_PATH_SIZE) return(ERR_SUP_NAMLNG);	/* construct path name */	file_name[0] = NULCH;	if (dir_name[0] != NULCH) {		strcat(file_name, dir_name);	        strcat(file_name, "\\");	}        strcat(file_name, prog_name);	strcat(file_name, ".MPX");        /* try to open the file */	errcode = OK;        file_p = fopen(file_name, "rb");        if (file_p == NULL) return(ERR_SUP_FILNFD);	/* read the header, check for EXE signature */        num_read = fread( (void*) header, 1, HEADER_SIZE, file_p);        if (num_read != HEADER_SIZE) {		errcode = ERR_SUP_FILINV;	}        else if ((header[0] != 0x4D) || (header[1] != 0x5A)) {		errcode = ERR_SUP_FILINV;	}        /* close the file, then return if error occurred */        fclose(file_p);	if (errcode!=OK) return(errcode);        /* compute allocation size needed */        file_size = (header[5]*256 + header[4] -1) * 512		+ (header[3]*256 + header[2]);        header_size =(header[9]*256 + header[8])*16;        code_size = file_size - header_size;        data_size = (header[11]*256 + header[10])*16;        /* return total length and starting offset */        *prog_len_p = code_size + data_size;	*start_offset_p = (header[23]*256 + header[22]) * 16;	return(OK);}/*	Procedure: sys_load_program	Purpose: load a program file	Parameters: see prototype	Returns: error code; zero if OK	Calls:   intdosx		segread		strlen, strcat	Globals: none 	Errors:  ERR_SUP_NAMLNG    name too long		ERR_SUP_FILNFD    file not found	       ERR_SUP_FILINV      file invalid		ERR_SUP_PROGSZ    program too large	       ERR_SUP_LDADDR      address not aligned		ERR_SUP_LDFAIL    load failed*/int sys_load_program (     void*    load_addr,        /* address for loading */			int      max_size,         /* memory size */			char     dir_name[],       /* directory name */			char     prog_name[]       /* program name */		      ){	int errcode;      /* error code */        int prog_len;      /* program length */	int offset;       /* offset for starting */	word norm_seg;    /* normalized load address segment */        word norm_off;     /* normalized load address offset */        /* full pathname for file to be loaded */	char file_name[MAX_PATH_SIZE+1];        /* parameter block for MSDOS EXEC function */	struct {		word load_seg;    /* segment address for loading */	       word reloc_seg;     /* segment address for relocation */        }p_block;	union REGS inregs;            /* input register structure */	union REGS outregs;           /* output register structure */	struct SREGS segregs;         /* segment register structure */        /* check program, get length and offset */	errcode = sys_check_program(dir_name, prog_name,					&prog_len, &offset);        if (errcode < 0) return(errcode);        /* ensure that allocated memory is large enough */        if (max_size < prog_len) return(ERR_SUP_PROGSZ);        /* get normalized segment and offset, check alignment */	norm_seg = FP_SEG(load_addr);	norm_off = FP_OFF(load_addr);	norm_seg += norm_off / 16;        norm_off %= 16;	if (norm_off != 0) return(ERR_SUP_LDADDR);        /* ensure that path name is not too long */        if ((strlen(dir_name) + strlen(prog_name) + 5)		 > MAX_PATH_SIZE) return(ERR_SUP_NAMLNG);	/* construct path name */	file_name[0] = NULCH;	if (dir_name[0] != NULCH) {		strcat(file_name, dir_name);	        strcat(file_name, "\\");	}        strcat(file_name, prog_name);	strcat(file_name, ".MPX");        /* get current segment regs */	segread(&segregs);        /* setup function codes */	inregs.h.ah = 0x4B;        /* EXEC function */	inregs.h.al = 0x03;        /* load only */        /* setup parameter block and name pointers */        segregs.ds = FP_SEG(&file_name);	inregs.x.dx = FP_OFF(&file_name);        segregs.es = FP_SEG(&p_block);	inregs.x.bx = FP_OFF(&p_block);        /* setup load segment -- must be normalized */	p_block.load_seg = norm_seg;	p_block.reloc_seg = p_block.load_seg;        /* call the MS-DOS loader */	errcode = intdosx(&inregs,&outregs,&segregs);        errcode = errcode;        /* check for error */	if (outregs.x.cflag) return(ERR_SUP_LDFAIL);	/* load successful */	return(OK);}/* END OF FILE */params1,0
/***********************************************************************	MPX: The MultiProgramming eXecutive	Project to Accompany	A Practical Approach to Operating Systems	Malcolm G. Lane & James D. Mooney	Copyright 1993, P.W.S. Kent Publishing Co., Boston, MA.		File Name: mpx_supt.c	Authors: J.J. Patnesky, A. Ghosal, M. Lane, J. Mooney	Version: 2.1b	Date: 01/31/08	Purpose: Support routines for MPX-PC		Modules: all	Environment:      IBM-PC (XT, AT or PS/2)			MS-DOS 3.3 or later			TURBO-C 3.0 or TURBO-C++ 1.0 or later	Compile using the LARGE MODEL and SS NOT equal to DS.	All addresses and pointers are "far", and	CS, DS and SS are independent.	Procedures in this file:		sys_init		sys_exit		sys_set_vec		sys_req		sys_alloc_mem		sys_free_mem		sys_get_date		sys_set_date		sys_open_dir		sys_get_entry		sys_close_dir	       sys_check_program	       sys_load_program************************************************************************Change Log:	07/16/88  akg	added comments	02/25/92  jdm	full revision, UNIX version	04/14/92  jdm	Macintosh version	05/15/92  jdm	cleanup and documentation	07/14/92  jdm	update for revised specs        08/13/92  jdm 	revised IBM version; added private heap        10/14/92  jdm 	added check and load procedures        10/18/92  jdm 	revised sys_alloc_mem for alignment	11/17/92  jdm	true heap mgt, aligned, using calloc & free	11/19/92  jdm	enable device handling for final module	12/31/92  jdm	revised sys_req parameters	01/02/93  jdm	return count value after I/O	01/03/93  jdm	revised error names and codes	01/27/93  jdm	corrected count for line input in sys_req			fixed open_dir to handle null lines	02/24/93  jdm	changed sys_set_vec param to interrupt	03/08/93  jdm	corrections to sys_check & sys_load	03/20/93  jdm	stack switch in free, check, and load	04/22/93  jdm	corrected index conflict in sys_free_mem			added safety escape in alloc table search	07/28/93  jdm	conversion to large model	09/01/93  jdm	fixed allocation bug;  made date private	09/14/93  jdm	cleaned up memory allocation        09/16/93  jdm	adjusted program load for large model        09/30/93  jdm	modified for correct list of root directory	11/01/94  jdm	changed load file read to binary	09/18/95  jdm	fixed get_entry to default to current, not root	01/31/08  jdm   fixed possible overflow problem in get_entry************************************************************************/#include "mpx_supt.h"#include <stdlib.h>#include <dos.h>#include <dir.h>#include <errno.h>#include <conio.h>#include <alloc.h>#define VEC_ADDR (0x60L*4)#define MAX_ALLOC 200#define MAX_XPOS 79#define MAX_YPOS 24#define MAX_PATH_SIZE 50/*	System-dependent type definitions*/typedef unsigned char byte;typedef unsigned int word;typedef unsigned long longword;typedef byte *address;typedef struct params {	int      op_code;	int      device_id;	char     *buf_p;	int      *count_p;	} params;/*	Global variables accessed only by support routines*/	static longword vec_save;  /* saved interrupt vector */	static int mod_code;                /* module code */                                           	static struct date sys_date;        /* MPX system date */	/* data structures for directory access */        static char current_path[MAX_PATH_SIZE+1];        static int num_entries;        static struct ffblk file_block;        /* handler presence flags */	static flag sysc_hand;	static flag trm_hand;	static flag prt_hand;	static flag com_hand;        /* memory allocation table */	static struct {		void* original;		void* aligned;	} alloc_table[MAX_ALLOC];	static int alloc_ix;                /* current index */	static int num_alloc;               /* no. of allocated blocks *//*	Procedure: sys_init	Purpose: initialize mpx	Parameters: see prototype  	Return value: error code, or OK if no error	Calls: getdate    	Globals: mod_code		vec_save		sys_date		alloc_table, alloc_ix, num_alloc		sysc_hand, term_hand, prt_hand, com_hand	Errors: none*/int sys_init (    int      modules  /* module code */	     ){	mod_code = modules;        vec_save = 0L;        /* no handlers detected yet */	sysc_hand = FALSE;	trm_hand = FALSE;	prt_hand = FALSE;	com_hand = FALSE;	/* initialize allocation table */	for (alloc_ix=0; alloc_ix < MAX_ALLOC; alloc_ix++) {		alloc_table[alloc_ix].original = NULL;		alloc_table[alloc_ix].aligned = NULL;	}	alloc_ix = 0;	num_alloc = 0;	/* if we have reached Module R3, enable system call handling */	if (modules >= MODULE_R3) sysc_hand = TRUE;	/* if we have reached the final module, enable device handlers */	if (modules >= MODULE_F) {		trm_hand = TRUE;		prt_hand = TRUE;		com_hand = TRUE;	}	/* get system date */        getdate(&sys_date);	return (OK);}/*	Procedure: sys_exit	Purpose: terminate mpx	Parameters: none  	Return value: none	Calls: none       	Globals: vec_save*/void sys_exit(void){	longword *vec_p;	/* if trap vector changed, restore it */	if (vec_save != 0L) {		vec_p = (longword*) VEC_ADDR;		*vec_p = vec_save;	}	/* return to host with null error code */	exit(0);}/*	Procedure: sys_set_vec	Purpose: link trap vector to MPX system call handler	Parameters: handler: addr of handler         	Return value: error code; OK if no error	Calls: none       	Globals: vec_save	Errors: none*/int sys_set_vec   ( void interrupt (*handler)() /* system call handler */		){	longword *vec_p;			vec_p = (longword*) VEC_ADDR;		vec_save = *vec_p;		*vec_p = (longword) handler;	return (0);}/*	Procedure: sys_req	Purpose: Request a system service	Inputs:		op_code           operation code		device_id         device identifier		buf_p             addresso f data buffer		count_p           address of size of buffer	Returns: Result or error code, depending on service		Services supported:	IDLE     null operation				READ     input from a device				WRITE    output to a device				CLEAR    clear terminal screen				GOTOXY   absolute cursor position				EXIT     terminate the caller	Calls:   fgets		strlen			Globals: none		Errors:  ERR_SUP_INVDEV    invalid device		ERR_SUP_INVOPC    invalid operation code		ERR_SUP_INVPOS    invalid character position		ERR_SUP_RDFAIL    read failed		ERR_SUP_WRFAIL    write failed	Description:	For Modules R1 through R4,	this procedure is used only for terminal I/O.	Later modules support both reading and	writing for several devices.	For Modules R1 through R4,	sys_req uses the ANSI C function "fgets."	Later modules may use alternate functions and device drivers.*/int sys_req (   int      op_code, /* operation code */		int      device_id,        /* device id */		char*    buf_p,            /* I/O buffer */		int*     count_p           /* address of count */		){	int      rval;    /* result or error code */	char     *rp;     /* return pointer for fgets */	char     rc;      /* return char for fputc */        params    *param_p; /* pointer to parameter record in stack */	flag     docall;  /* true if system call interrupt wanted */	int      ix;      /* temporary index */	docall = FALSE;	rval = OK;	switch (op_code) {		case IDLE:		if (sysc_hand) docall = TRUE;		break; 				case READ:		switch (device_id) {				case TERMINAL:			if (trm_hand) docall = TRUE;			else {				rp = fgets(buf_p,*count_p,stdin);				if (rp==NULL) rval = ERR_SUP_RDFAIL;				else rval = strlen(buf_p);			}			break;					case COM_PORT:			if (com_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					default:			rval = ERR_SUP_INVDEV;					}		break;	case WRITE:		switch (device_id) {				case TERMINAL:			if (trm_hand) docall = TRUE;			else {				rval = *count_p;				for (ix=0; ix<*count_p; ix++) {					rc = fputc(buf_p[ix],stdout);					if (rc == EOF) {						rval = ERR_SUP_WRFAIL;						break;					}				}			}			break;					case COM_PORT:			if (com_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					case PRINTER:			if (prt_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					default:			rval = ERR_SUP_INVDEV;					}		break;	case CLEAR:		if (device_id==TERMINAL) {			if (trm_hand) docall = TRUE;			else {			     clrscr();				rval = 0;			}		}		else rval = ERR_SUP_INVDEV;		break;			case GOTOXY:		if (device_id==TERMINAL) {			if (trm_hand) docall = TRUE;			else {				if (*count_p != 2) rval = ERR_SUP_WRFAIL;				else if ((*buf_p<0)					|| (*buf_p > MAX_XPOS))					rval = ERR_SUP_WRFAIL;				else if ((*(buf_p+1)<0)					|| (*(buf_p+1) > MAX_YPOS))					rval = ERR_SUP_WRFAIL;				else {					gotoxy(*buf_p + 1,						*(buf_p+1) + 1);					rval = 0;				}			}		}		else rval = ERR_SUP_INVDEV;		break;			/* EXIT - terminate the calling process */	/* legal only when a system call handler is present */	case EXIT:		if (sysc_hand) docall = TRUE;		else rval = ERR_SUP_INVOPC;		break; 	default:		rval = ERR_SUP_INVOPC;			}		/* Invoke user's call handler if present.	   If the call is an IO request, return will occur	   only after the request is complete.	*/	if (docall && (rval==OK)) {		/* invoke the call handler */	_SP = _SP - sizeof(params);		param_p = (params*) MK_FP(_SS,_SP);	       param_p->op_code = op_code;	       param_p->device_id = device_id;	       param_p->buf_p = buf_p;	       param_p->count_p = count_p;	       geninterrupt(0x60);	       rval = _AX;	       _SP = _SP + sizeof(params);		/* for I/O operations, return count value */		switch(op_code) {		case READ:		case WRITE:		case CLEAR:		case GOTOXY:			rval = *count_p;		}	}	return(rval);}/*	Procedure: sys_alloc_mem	Purpose: Allocate a memory block	Parameters:			size_t size       No. of bytes to allocate	Returns: void* pointer to allocated block;		 null pointer in case of error		 	Calls: calloc		Globals: alloc_table, alloc_ix, num_alloc	For program loading (Module R-4), the blocks must be aligned.	This is achieved by requesting one extra paragraph and	returning the lowest aligned address as the base.  It is	necessary to keep a table of allocated address, original and	aligned, to support correct freeing.	It would seem simpler to use the Turbo-C function allocmem,	which always allocates aligned blocks.  However, allocmem	appears to conflict with the internal allocation of fopen	and other C library routines.*/void *sys_alloc_mem (      size_t   size     /* size in bytes to allocate */		    ){	int ix_save;      /* temp copy of table index */        void *addr;        /* addr returned by calloc (*void) */	word offset;      /* offset of unaligned address */	word seg;         /* segment addr of unaligned address */	void *addr_alig; /* aligned address */	int rem; /* temp for alignment computation */	/* ensure that allocation table is not full */	if (num_alloc >= MAX_ALLOC) {		return(NULL);	}	/* find free entry in allocation table */	ix_save = alloc_ix;	while (alloc_table[alloc_ix].original != NULL) {		alloc_ix++;		if (alloc_ix >= MAX_ALLOC) alloc_ix = 0;		/* safety check -- should never happen! */		if (alloc_ix == ix_save) return(NULL);	}	/* call allocation routine */	/* request 15 extra bytes to ensure alignment is possible */	addr = calloc(size + 15,1);	/* compute aligned base */	offset = FP_OFF(addr);        seg = FP_SEG(addr);	rem = offset % 16;	if (rem > 0) offset = offset + 16 - rem;	addr_alig = MK_FP(seg,offset);	/* insert entries in table */	alloc_table[alloc_ix].original = addr;	alloc_table[alloc_ix].aligned = addr_alig;	/* increment count */	num_alloc++;	return(addr_alig);}/*	Procedure: sys_free_mem	Purpose: free a memory block	Parameters:		void *ptr         ptr to block to allocate	Returns: integer error code; zero if OK		Calls:   free	Globals: alloc_table, num_alloc	Errors:  ERR_SUP_INVMEM    invalid memory block	This procedure receives an aligned address; it must	find and free the corresponding non-aligned one.*/int sys_free_mem (         void     *ptr     /* pointer to block */		 ){	void *free_addr;  /* true (unaligned) block address */	int free_ix;               /* temp table index */	/* ensure valid pointer */	if (ptr==NULL) return(ERR_SUP_INVMEM);	/* Look for the block in the allocation table */	free_addr = NULL;	for (free_ix=0; free_ix<MAX_ALLOC; free_ix++) {		if (alloc_table[free_ix].aligned == ptr) {			free_addr = alloc_table[free_ix].original;			break;		}	}	/* If the block wasn't found, report error */	if (free_addr == NULL) return(ERR_SUP_INVMEM);	/* free the block & clear the table entry */	alloc_table[free_ix].original = NULL;	alloc_table[free_ix].aligned = NULL;        free(free_addr);	/* decrement count */	num_alloc--;	return(OK);}        /*	Procedure: sys_get_date	Purpose: Returns the system date (month, day, year)	Parameters:		date_rec *date_p Pointer to structure of type date	Returns: void		Calls: none		Globals: sys_date        Errors: none*/void sys_get_date (  date_rec*      date_p   /* ptr to date record */		){	date_p->month = sys_date.da_mon;	date_p->day = sys_date.da_day;	date_p->year = sys_date.da_year;}/*	Procedure: sys_set_date	Purpose: Sets the system date (month, day, year)	Parameters:		date_rec *date_p ptr to structure of type date	Returns: error code; OK if no error	Calls:   none        Globals: sys_date	Errors: none*/int sys_set_date (  date_rec*       date_p   /* ptr to date record */		 ){	sys_date.da_mon = date_p->month;        sys_date.da_day = date_p->day;        sys_date.da_year = date_p->year;	return(OK);}/*	Procedure: sys_open_dir	Purpose: open a specified directory	Parameters: char dir_name[]            directory name	Returns: error code; zero if OK	Calls:   findfirst		strncpy  	Globals: current_path, file_block, num_entries	Errors:  ERR_SUP_DIROPN    directory open error		ERR_SUP_INVDIR    invalid directory*/int sys_open_dir (  char  path_name[]        /* directory name */		 ){        char temp_path[MAX_PATH_SIZE];	int res;        int len;        /* ensure there is no directory currently open */	if (current_path[0]!=NULCH) return(ERR_SUP_DIROPN);        /* check pathname for validity */        /* construct temporary search path name */	temp_path[0] = NULCH;	if (path_name != NULL) {		strncpy(temp_path,path_name,MAX_PATH_SIZE-4);	}	/* build wildcard search string */        len = strlen(temp_path);	/* if path is null, use current directory */        if (len==0) strcpy(temp_path,"*.*");	/* handle paths ending in backslash, including root */        else if (temp_path[len-1]=='\\') strcat(temp_path,"*.*");	/* handle paths not ending in backslash */        else strcat(temp_path,"\\*.*");	/* validate the directory by searching for either an ordinary	   file or a directory in it.  This should never fail; even	   empty directories contain the directories "." and ".."	*/		res = findfirst(temp_path, &file_block, FA_DIREC);	if (res!=0)  return(ERR_SUP_INVDIR);        /* save pathname as current, clear entry count */	current_path[0] = NULCH;	if (path_name != NULL) {		strncpy(current_path,path_name,MAX_PATH_SIZE-6);	}	num_entries = 0;	return(OK);}/*	Procedure: sys_get_entry	Purpose: get the next directory entry;	Parameters: char name_buf[]	name buffer		    int buf_size  	buffer capacity		    long *file_size_p	file length buffer         	Returns: error code, or zero if ok	Calls:	findfirst		findnext		strncpy, strcpy, strrchr, strcat    	Globals: current_path, num_entries, file_block	Errors:  ERR_SUP_NOENTR    no such entry*/int sys_get_entry (char    name_buf[],       /* buffer for entry */		   int   buf_size,         /* buffer size */		   long* file_size_p       /* buffer for size value */		  ){	char filename[MAX_PATH_SIZE+1];	int err;        int len;        char *cp;        /* find next MPX file entry, if any */        /* if this is the first call */	if (num_entries==0) {	       /* construct complete search path name */	       len = strlen(current_path);	       if (len==0) strcpy(current_path,"*.MPX");	       else if (current_path[len-1]=='\\') strcat(current_path,"*.MPX");	       else strcat(current_path,"\\*.MPX");	       /* find first entry */		err = findfirst (current_path,&file_block,0);        }        /* otherwise, find next entry */        else err = findnext(&file_block);        if (err<0) return(ERR_SUP_NOENTR);		/* ensure buf_size is not too large */		if (buf_size > MAX_PATH_SIZE) buf_size = MAX_PATH_SIZE;		      /* copy filename to buffer */	filename[buf_size] = NULCH;	strncpy (filename,file_block.ff_name,			 (size_t) buf_size);	/* remove ".MPX" from name */	cp = strrchr(filename, (int) '.');        *cp = NULCH;	/* copy name and size to caller's buffer */        strcpy (name_buf,filename);	*file_size_p = file_block.ff_fsize;        /* count entry */	num_entries++;	return(OK);}/*	Procedure: sys_close_dir	Purpose: close an open directory	Parameters: none	Returns: error code; zero if OK	Calls:   none	Globals: current_path	Errors:  none*/int sys_close_dir (void){	current_path[0] = NULCH;	return(OK);}/*	Procedure: sys_check_program	Purpose: locate and measure a program file	Parameters: see prototype	Returns: program size or error code	Calls:   strlen, strcat		fopen, fread	Globals: none	Errors:  ERR_SUP_NAMLNG    pathname too long		ERR_SUP_FILNFD    file not found		ERR_SUP_FILINV    file invalid*/#define HEADER_SIZE 32int sys_check_program(     char     dir_name[],       /* directory name */			char     prog_name[],      /* program name */			int*     prog_len_p,       /* ptr to prog length */			int*     start_offset_p    /* ptr to start offset */			){        /* buffer for full pathname */	char file_name[MAX_PATH_SIZE+1];        /* buffer for file header */        byte header[HEADER_SIZE];	FILE *file_p;     /* file pointer for C file routines */        int num_read;      /* number of header bytes read */	int file_size;    /* size of complete file */        int header_size;/* size of header */        int code_size;     /* size of program code */        int data_size;     /* size of program data */        int errcode;       /* error code */        /* ensure that path name is not too long */        if ((strlen(dir_name) + strlen(prog_name) + 5)		 > MAX_PATH_SIZE) return(ERR_SUP_NAMLNG);	/* construct path name */	file_name[0] = NULCH;	if (dir_name[0] != NULCH) {		strcat(file_name, dir_name);	        strcat(file_name, "\\");	}        strcat(file_name, prog_name);	strcat(file_name, ".MPX");        /* try to open the file */	errcode = OK;        file_p = fopen(file_name, "rb");        if (file_p == NULL) return(ERR_SUP_FILNFD);	/* read the header, check for EXE signature */        num_read = fread( (void*) header, 1, HEADER_SIZE, file_p);        if (num_read != HEADER_SIZE) {		errcode = ERR_SUP_FILINV;	}        else if ((header[0] != 0x4D) || (header[1] != 0x5A)) {		errcode = ERR_SUP_FILINV;	}        /* close the file, then return if error occurred */        fclose(file_p);	if (errcode!=OK) return(errcode);        /* compute allocation size needed */        file_size = (header[5]*256 + header[4] -1) * 512		+ (header[3]*256 + header[2]);        header_size =(header[9]*256 + header[8])*16;        code_size = file_size - header_size;        data_size = (header[11]*256 + header[10])*16;        /* return total length and starting offset */        *prog_len_p = code_size + data_size;	*start_offset_p = (header[23]*256 + header[22]) * 16;	return(OK);}/*	Procedure: sys_load_program	Purpose: load a program file	Parameters: see prototype	Returns: error code; zero if OK	Calls:   intdosx		segread		strlen, strcat	Globals: none 	Errors:  ERR_SUP_NAMLNG    name too long		ERR_SUP_FILNFD    file not found	       ERR_SUP_FILINV      file invalid		ERR_SUP_PROGSZ    program too large	       ERR_SUP_LDADDR      address not aligned		ERR_SUP_LDFAIL    load failed*/int sys_load_program (     void*    load_addr,        /* address for loading */			int      max_size,         /* memory size */			char     dir_name[],       /* directory name */			char     prog_name[]       /* program name */		      ){	int errcode;      /* error code */        int prog_len;      /* program length */	int offset;       /* offset for starting */	word norm_seg;    /* normalized load address segment */        word norm_off;     /* normalized load address offset */        /* full pathname for file to be loaded */	char file_name[MAX_PATH_SIZE+1];        /* parameter block for MSDOS EXEC function */	struct {		word load_seg;    /* segment address for loading */	       word reloc_seg;     /* segment address for relocation */        }p_block;	union REGS inregs;            /* input register structure */	union REGS outregs;           /* output register structure */	struct SREGS segregs;         /* segment register structure */        /* check program, get length and offset */	errcode = sys_check_program(dir_name, prog_name,					&prog_len, &offset);        if (errcode < 0) return(errcode);        /* ensure that allocated memory is large enough */        if (max_size < prog_len) return(ERR_SUP_PROGSZ);        /* get normalized segment and offset, check alignment */	norm_seg = FP_SEG(load_addr);	norm_off = FP_OFF(load_addr);	norm_seg += norm_off / 16;        norm_off %= 16;	if (norm_off != 0) return(ERR_SUP_LDADDR);        /* ensure that path name is not too long */        if ((strlen(dir_name) + strlen(prog_name) + 5)		 > MAX_PATH_SIZE) return(ERR_SUP_NAMLNG);	/* construct path name */	file_name[0] = NULCH;	if (dir_name[0] != NULCH) {		strcat(file_name, dir_name);	        strcat(file_name, "\\");	}        strcat(file_name, prog_name);	strcat(file_name, ".MPX");        /* get current segment regs */	segread(&segregs);        /* setup function codes */	inregs.h.ah = 0x4B;        /* EXEC function */	inregs.h.al = 0x03;        /* load only */        /* setup parameter block and name pointers */        segregs.ds = FP_SEG(&file_name);	inregs.x.dx = FP_OFF(&file_name);        segregs.es = FP_SEG(&p_block);	inregs.x.bx = FP_OFF(&p_block);        /* setup load segment -- must be normalized */	p_block.load_seg = norm_seg;	p_block.reloc_seg = p_block.load_seg;        /* call the MS-DOS loader */	errcode = intdosx(&inregs,&outregs,&segregs);        errcode = errcode;        /* check for error */	if (outregs.x.cflag) return(ERR_SUP_LDFAIL);	/* load successful */	return(OK);}/* END OF FILE */vec_save1,0
/***********************************************************************	MPX: The MultiProgramming eXecutive	Project to Accompany	A Practical Approach to Operating Systems	Malcolm G. Lane & James D. Mooney	Copyright 1993, P.W.S. Kent Publishing Co., Boston, MA.		File Name: mpx_supt.c	Authors: J.J. Patnesky, A. Ghosal, M. Lane, J. Mooney	Version: 2.1b	Date: 01/31/08	Purpose: Support routines for MPX-PC		Modules: all	Environment:      IBM-PC (XT, AT or PS/2)			MS-DOS 3.3 or later			TURBO-C 3.0 or TURBO-C++ 1.0 or later	Compile using the LARGE MODEL and SS NOT equal to DS.	All addresses and pointers are "far", and	CS, DS and SS are independent.	Procedures in this file:		sys_init		sys_exit		sys_set_vec		sys_req		sys_alloc_mem		sys_free_mem		sys_get_date		sys_set_date		sys_open_dir		sys_get_entry		sys_close_dir	       sys_check_program	       sys_load_program************************************************************************Change Log:	07/16/88  akg	added comments	02/25/92  jdm	full revision, UNIX version	04/14/92  jdm	Macintosh version	05/15/92  jdm	cleanup and documentation	07/14/92  jdm	update for revised specs        08/13/92  jdm 	revised IBM version; added private heap        10/14/92  jdm 	added check and load procedures        10/18/92  jdm 	revised sys_alloc_mem for alignment	11/17/92  jdm	true heap mgt, aligned, using calloc & free	11/19/92  jdm	enable device handling for final module	12/31/92  jdm	revised sys_req parameters	01/02/93  jdm	return count value after I/O	01/03/93  jdm	revised error names and codes	01/27/93  jdm	corrected count for line input in sys_req			fixed open_dir to handle null lines	02/24/93  jdm	changed sys_set_vec param to interrupt	03/08/93  jdm	corrections to sys_check & sys_load	03/20/93  jdm	stack switch in free, check, and load	04/22/93  jdm	corrected index conflict in sys_free_mem			added safety escape in alloc table search	07/28/93  jdm	conversion to large model	09/01/93  jdm	fixed allocation bug;  made date private	09/14/93  jdm	cleaned up memory allocation        09/16/93  jdm	adjusted program load for large model        09/30/93  jdm	modified for correct list of root directory	11/01/94  jdm	changed load file read to binary	09/18/95  jdm	fixed get_entry to default to current, not root	01/31/08  jdm   fixed possible overflow problem in get_entry************************************************************************/#include "mpx_supt.h"#include <stdlib.h>#include <dos.h>#include <dir.h>#include <errno.h>#include <conio.h>#include <alloc.h>#define VEC_ADDR (0x60L*4)#define MAX_ALLOC 200#define MAX_XPOS 79#define MAX_YPOS 24#define MAX_PATH_SIZE 50/*	System-dependent type definitions*/typedef unsigned char byte;typedef unsigned int word;typedef unsigned long longword;typedef byte *address;typedef struct params {	int      op_code;	int      device_id;	char     *buf_p;	int      *count_p;	} params;/*	Global variables accessed only by support routines*/	static longword vec_save;  /* saved interrupt vector */	static int mod_code;                /* module code */                                           	static struct date sys_date;        /* MPX system date */	/* data structures for directory access */        static char current_path[MAX_PATH_SIZE+1];        static int num_entries;        static struct ffblk file_block;        /* handler presence flags */	static flag sysc_hand;	static flag trm_hand;	static flag prt_hand;	static flag com_hand;        /* memory allocation table */	static struct {		void* original;		void* aligned;	} alloc_table[MAX_ALLOC];	static int alloc_ix;                /* current index */	static int num_alloc;               /* no. of allocated blocks *//*	Procedure: sys_init	Purpose: initialize mpx	Parameters: see prototype  	Return value: error code, or OK if no error	Calls: getdate    	Globals: mod_code		vec_save		sys_date		alloc_table, alloc_ix, num_alloc		sysc_hand, term_hand, prt_hand, com_hand	Errors: none*/int sys_init (    int      modules  /* module code */	     ){	mod_code = modules;        vec_save = 0L;        /* no handlers detected yet */	sysc_hand = FALSE;	trm_hand = FALSE;	prt_hand = FALSE;	com_hand = FALSE;	/* initialize allocation table */	for (alloc_ix=0; alloc_ix < MAX_ALLOC; alloc_ix++) {		alloc_table[alloc_ix].original = NULL;		alloc_table[alloc_ix].aligned = NULL;	}	alloc_ix = 0;	num_alloc = 0;	/* if we have reached Module R3, enable system call handling */	if (modules >= MODULE_R3) sysc_hand = TRUE;	/* if we have reached the final module, enable device handlers */	if (modules >= MODULE_F) {		trm_hand = TRUE;		prt_hand = TRUE;		com_hand = TRUE;	}	/* get system date */        getdate(&sys_date);	return (OK);}/*	Procedure: sys_exit	Purpose: terminate mpx	Parameters: none  	Return value: none	Calls: none       	Globals: vec_save*/void sys_exit(void){	longword *vec_p;	/* if trap vector changed, restore it */	if (vec_save != 0L) {		vec_p = (longword*) VEC_ADDR;		*vec_p = vec_save;	}	/* return to host with null error code */	exit(0);}/*	Procedure: sys_set_vec	Purpose: link trap vector to MPX system call handler	Parameters: handler: addr of handler         	Return value: error code; OK if no error	Calls: none       	Globals: vec_save	Errors: none*/int sys_set_vec   ( void interrupt (*handler)() /* system call handler */		){	longword *vec_p;			vec_p = (longword*) VEC_ADDR;		vec_save = *vec_p;		*vec_p = (longword) handler;	return (0);}/*	Procedure: sys_req	Purpose: Request a system service	Inputs:		op_code           operation code		device_id         device identifier		buf_p             addresso f data buffer		count_p           address of size of buffer	Returns: Result or error code, depending on service		Services supported:	IDLE     null operation				READ     input from a device				WRITE    output to a device				CLEAR    clear terminal screen				GOTOXY   absolute cursor position				EXIT     terminate the caller	Calls:   fgets		strlen			Globals: none		Errors:  ERR_SUP_INVDEV    invalid device		ERR_SUP_INVOPC    invalid operation code		ERR_SUP_INVPOS    invalid character position		ERR_SUP_RDFAIL    read failed		ERR_SUP_WRFAIL    write failed	Description:	For Modules R1 through R4,	this procedure is used only for terminal I/O.	Later modules support both reading and	writing for several devices.	For Modules R1 through R4,	sys_req uses the ANSI C function "fgets."	Later modules may use alternate functions and device drivers.*/int sys_req (   int      op_code, /* operation code */		int      device_id,        /* device id */		char*    buf_p,            /* I/O buffer */		int*     count_p           /* address of count */		){	int      rval;    /* result or error code */	char     *rp;     /* return pointer for fgets */	char     rc;      /* return char for fputc */        params    *param_p; /* pointer to parameter record in stack */	flag     docall;  /* true if system call interrupt wanted */	int      ix;      /* temporary index */	docall = FALSE;	rval = OK;	switch (op_code) {		case IDLE:		if (sysc_hand) docall = TRUE;		break; 				case READ:		switch (device_id) {				case TERMINAL:			if (trm_hand) docall = TRUE;			else {				rp = fgets(buf_p,*count_p,stdin);				if (rp==NULL) rval = ERR_SUP_RDFAIL;				else rval = strlen(buf_p);			}			break;					case COM_PORT:			if (com_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					default:			rval = ERR_SUP_INVDEV;					}		break;	case WRITE:		switch (device_id) {				case TERMINAL:			if (trm_hand) docall = TRUE;			else {				rval = *count_p;				for (ix=0; ix<*count_p; ix++) {					rc = fputc(buf_p[ix],stdout);					if (rc == EOF) {						rval = ERR_SUP_WRFAIL;						break;					}				}			}			break;					case COM_PORT:			if (com_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					case PRINTER:			if (prt_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					default:			rval = ERR_SUP_INVDEV;					}		break;	case CLEAR:		if (device_id==TERMINAL) {			if (trm_hand) docall = TRUE;			else {			     clrscr();				rval = 0;			}		}		else rval = ERR_SUP_INVDEV;		break;			case GOTOXY:		if (device_id==TERMINAL) {			if (trm_hand) docall = TRUE;			else {				if (*count_p != 2) rval = ERR_SUP_WRFAIL;				else if ((*buf_p<0)					|| (*buf_p > MAX_XPOS))					rval = ERR_SUP_WRFAIL;				else if ((*(buf_p+1)<0)					|| (*(buf_p+1) > MAX_YPOS))					rval = ERR_SUP_WRFAIL;				else {					gotoxy(*buf_p + 1,						*(buf_p+1) + 1);					rval = 0;				}			}		}		else rval = ERR_SUP_INVDEV;		break;			/* EXIT - terminate the calling process */	/* legal only when a system call handler is present */	case EXIT:		if (sysc_hand) docall = TRUE;		else rval = ERR_SUP_INVOPC;		break; 	default:		rval = ERR_SUP_INVOPC;			}		/* Invoke user's call handler if present.	   If the call is an IO request, return will occur	   only after the request is complete.	*/	if (docall && (rval==OK)) {		/* invoke the call handler */	_SP = _SP - sizeof(params);		param_p = (params*) MK_FP(_SS,_SP);	       param_p->op_code = op_code;	       param_p->device_id = device_id;	       param_p->buf_p = buf_p;	       param_p->count_p = count_p;	       geninterrupt(0x60);	       rval = _AX;	       _SP = _SP + sizeof(params);		/* for I/O operations, return count value */		switch(op_code) {		case READ:		case WRITE:		case CLEAR:		case GOTOXY:			rval = *count_p;		}	}	return(rval);}/*	Procedure: sys_alloc_mem	Purpose: Allocate a memory block	Parameters:			size_t size       No. of bytes to allocate	Returns: void* pointer to allocated block;		 null pointer in case of error		 	Calls: calloc		Globals: alloc_table, alloc_ix, num_alloc	For program loading (Module R-4), the blocks must be aligned.	This is achieved by requesting one extra paragraph and	returning the lowest aligned address as the base.  It is	necessary to keep a table of allocated address, original and	aligned, to support correct freeing.	It would seem simpler to use the Turbo-C function allocmem,	which always allocates aligned blocks.  However, allocmem	appears to conflict with the internal allocation of fopen	and other C library routines.*/void *sys_alloc_mem (      size_t   size     /* size in bytes to allocate */		    ){	int ix_save;      /* temp copy of table index */        void *addr;        /* addr returned by calloc (*void) */	word offset;      /* offset of unaligned address */	word seg;         /* segment addr of unaligned address */	void *addr_alig; /* aligned address */	int rem; /* temp for alignment computation */	/* ensure that allocation table is not full */	if (num_alloc >= MAX_ALLOC) {		return(NULL);	}	/* find free entry in allocation table */	ix_save = alloc_ix;	while (alloc_table[alloc_ix].original != NULL) {		alloc_ix++;		if (alloc_ix >= MAX_ALLOC) alloc_ix = 0;		/* safety check -- should never happen! */		if (alloc_ix == ix_save) return(NULL);	}	/* call allocation routine */	/* request 15 extra bytes to ensure alignment is possible */	addr = calloc(size + 15,1);	/* compute aligned base */	offset = FP_OFF(addr);        seg = FP_SEG(addr);	rem = offset % 16;	if (rem > 0) offset = offset + 16 - rem;	addr_alig = MK_FP(seg,offset);	/* insert entries in table */	alloc_table[alloc_ix].original = addr;	alloc_table[alloc_ix].aligned = addr_alig;	/* increment count */	num_alloc++;	return(addr_alig);}/*	Procedure: sys_free_mem	Purpose: free a memory block	Parameters:		void *ptr         ptr to block to allocate	Returns: integer error code; zero if OK		Calls:   free	Globals: alloc_table, num_alloc	Errors:  ERR_SUP_INVMEM    invalid memory block	This procedure receives an aligned address; it must	find and free the corresponding non-aligned one.*/int sys_free_mem (         void     *ptr     /* pointer to block */		 ){	void *free_addr;  /* true (unaligned) block address */	int free_ix;               /* temp table index */	/* ensure valid pointer */	if (ptr==NULL) return(ERR_SUP_INVMEM);	/* Look for the block in the allocation table */	free_addr = NULL;	for (free_ix=0; free_ix<MAX_ALLOC; free_ix++) {		if (alloc_table[free_ix].aligned == ptr) {			free_addr = alloc_table[free_ix].original;			break;		}	}	/* If the block wasn't found, report error */	if (free_addr == NULL) return(ERR_SUP_INVMEM);	/* free the block & clear the table entry */	alloc_table[free_ix].original = NULL;	alloc_table[free_ix].aligned = NULL;        free(free_addr);	/* decrement count */	num_alloc--;	return(OK);}        /*	Procedure: sys_get_date	Purpose: Returns the system date (month, day, year)	Parameters:		date_rec *date_p Pointer to structure of type date	Returns: void		Calls: none		Globals: sys_date        Errors: none*/void sys_get_date (  date_rec*      date_p   /* ptr to date record */		){	date_p->month = sys_date.da_mon;	date_p->day = sys_date.da_day;	date_p->year = sys_date.da_year;}/*	Procedure: sys_set_date	Purpose: Sets the system date (month, day, year)	Parameters:		date_rec *date_p ptr to structure of type date	Returns: error code; OK if no error	Calls:   none        Globals: sys_date	Errors: none*/int sys_set_date (  date_rec*       date_p   /* ptr to date record */		 ){	sys_date.da_mon = date_p->month;        sys_date.da_day = date_p->day;        sys_date.da_year = date_p->year;	return(OK);}/*	Procedure: sys_open_dir	Purpose: open a specified directory	Parameters: char dir_name[]            directory name	Returns: error code; zero if OK	Calls:   findfirst		strncpy  	Globals: current_path, file_block, num_entries	Errors:  ERR_SUP_DIROPN    directory open error		ERR_SUP_INVDIR    invalid directory*/int sys_open_dir (  char  path_name[]        /* directory name */		 ){        char temp_path[MAX_PATH_SIZE];	int res;        int len;        /* ensure there is no directory currently open */	if (current_path[0]!=NULCH) return(ERR_SUP_DIROPN);        /* check pathname for validity */        /* construct temporary search path name */	temp_path[0] = NULCH;	if (path_name != NULL) {		strncpy(temp_path,path_name,MAX_PATH_SIZE-4);	}	/* build wildcard search string */        len = strlen(temp_path);	/* if path is null, use current directory */        if (len==0) strcpy(temp_path,"*.*");	/* handle paths ending in backslash, including root */        else if (temp_path[len-1]=='\\') strcat(temp_path,"*.*");	/* handle paths not ending in backslash */        else strcat(temp_path,"\\*.*");	/* validate the directory by searching for either an ordinary	   file or a directory in it.  This should never fail; even	   empty directories contain the directories "." and ".."	*/		res = findfirst(temp_path, &file_block, FA_DIREC);	if (res!=0)  return(ERR_SUP_INVDIR);        /* save pathname as current, clear entry count */	current_path[0] = NULCH;	if (path_name != NULL) {		strncpy(current_path,path_name,MAX_PATH_SIZE-6);	}	num_entries = 0;	return(OK);}/*	Procedure: sys_get_entry	Purpose: get the next directory entry;	Parameters: char name_buf[]	name buffer		    int buf_size  	buffer capacity		    long *file_size_p	file length buffer         	Returns: error code, or zero if ok	Calls:	findfirst		findnext		strncpy, strcpy, strrchr, strcat    	Globals: current_path, num_entries, file_block	Errors:  ERR_SUP_NOENTR    no such entry*/int sys_get_entry (char    name_buf[],       /* buffer for entry */		   int   buf_size,         /* buffer size */		   long* file_size_p       /* buffer for size value */		  ){	char filename[MAX_PATH_SIZE+1];	int err;        int len;        char *cp;        /* find next MPX file entry, if any */        /* if this is the first call */	if (num_entries==0) {	       /* construct complete search path name */	       len = strlen(current_path);	       if (len==0) strcpy(current_path,"*.MPX");	       else if (current_path[len-1]=='\\') strcat(current_path,"*.MPX");	       else strcat(current_path,"\\*.MPX");	       /* find first entry */		err = findfirst (current_path,&file_block,0);        }        /* otherwise, find next entry */        else err = findnext(&file_block);        if (err<0) return(ERR_SUP_NOENTR);		/* ensure buf_size is not too large */		if (buf_size > MAX_PATH_SIZE) buf_size = MAX_PATH_SIZE;		      /* copy filename to buffer */	filename[buf_size] = NULCH;	strncpy (filename,file_block.ff_name,			 (size_t) buf_size);	/* remove ".MPX" from name */	cp = strrchr(filename, (int) '.');        *cp = NULCH;	/* copy name and size to caller's buffer */        strcpy (name_buf,filename);	*file_size_p = file_block.ff_fsize;        /* count entry */	num_entries++;	return(OK);}/*	Procedure: sys_close_dir	Purpose: close an open directory	Parameters: none	Returns: error code; zero if OK	Calls:   none	Globals: current_path	Errors:  none*/int sys_close_dir (void){	current_path[0] = NULCH;	return(OK);}/*	Procedure: sys_check_program	Purpose: locate and measure a program file	Parameters: see prototype	Returns: program size or error code	Calls:   strlen, strcat		fopen, fread	Globals: none	Errors:  ERR_SUP_NAMLNG    pathname too long		ERR_SUP_FILNFD    file not found		ERR_SUP_FILINV    file invalid*/#define HEADER_SIZE 32int sys_check_program(     char     dir_name[],       /* directory name */			char     prog_name[],      /* program name */			int*     prog_len_p,       /* ptr to prog length */			int*     start_offset_p    /* ptr to start offset */			){        /* buffer for full pathname */	char file_name[MAX_PATH_SIZE+1];        /* buffer for file header */        byte header[HEADER_SIZE];	FILE *file_p;     /* file pointer for C file routines */        int num_read;      /* number of header bytes read */	int file_size;    /* size of complete file */        int header_size;/* size of header */        int code_size;     /* size of program code */        int data_size;     /* size of program data */        int errcode;       /* error code */        /* ensure that path name is not too long */        if ((strlen(dir_name) + strlen(prog_name) + 5)		 > MAX_PATH_SIZE) return(ERR_SUP_NAMLNG);	/* construct path name */	file_name[0] = NULCH;	if (dir_name[0] != NULCH) {		strcat(file_name, dir_name);	        strcat(file_name, "\\");	}        strcat(file_name, prog_name);	strcat(file_name, ".MPX");        /* try to open the file */	errcode = OK;        file_p = fopen(file_name, "rb");        if (file_p == NULL) return(ERR_SUP_FILNFD);	/* read the header, check for EXE signature */        num_read = fread( (void*) header, 1, HEADER_SIZE, file_p);        if (num_read != HEADER_SIZE) {		errcode = ERR_SUP_FILINV;	}        else if ((header[0] != 0x4D) || (header[1] != 0x5A)) {		errcode = ERR_SUP_FILINV;	}        /* close the file, then return if error occurred */        fclose(file_p);	if (errcode!=OK) return(errcode);        /* compute allocation size needed */        file_size = (header[5]*256 + header[4] -1) * 512		+ (header[3]*256 + header[2]);        header_size =(header[9]*256 + header[8])*16;        code_size = file_size - header_size;        data_size = (header[11]*256 + header[10])*16;        /* return total length and starting offset */        *prog_len_p = code_size + data_size;	*start_offset_p = (header[23]*256 + header[22]) * 16;	return(OK);}/*	Procedure: sys_load_program	Purpose: load a program file	Parameters: see prototype	Returns: error code; zero if OK	Calls:   intdosx		segread		strlen, strcat	Globals: none 	Errors:  ERR_SUP_NAMLNG    name too long		ERR_SUP_FILNFD    file not found	       ERR_SUP_FILINV      file invalid		ERR_SUP_PROGSZ    program too large	       ERR_SUP_LDADDR      address not aligned		ERR_SUP_LDFAIL    load failed*/int sys_load_program (     void*    load_addr,        /* address for loading */			int      max_size,         /* memory size */			char     dir_name[],       /* directory name */			char     prog_name[]       /* program name */		      ){	int errcode;      /* error code */        int prog_len;      /* program length */	int offset;       /* offset for starting */	word norm_seg;    /* normalized load address segment */        word norm_off;     /* normalized load address offset */        /* full pathname for file to be loaded */	char file_name[MAX_PATH_SIZE+1];        /* parameter block for MSDOS EXEC function */	struct {		word load_seg;    /* segment address for loading */	       word reloc_seg;     /* segment address for relocation */        }p_block;	union REGS inregs;            /* input register structure */	union REGS outregs;           /* output register structure */	struct SREGS segregs;         /* segment register structure */        /* check program, get length and offset */	errcode = sys_check_program(dir_name, prog_name,					&prog_len, &offset);        if (errcode < 0) return(errcode);        /* ensure that allocated memory is large enough */        if (max_size < prog_len) return(ERR_SUP_PROGSZ);        /* get normalized segment and offset, check alignment */	norm_seg = FP_SEG(load_addr);	norm_off = FP_OFF(load_addr);	norm_seg += norm_off / 16;        norm_off %= 16;	if (norm_off != 0) return(ERR_SUP_LDADDR);        /* ensure that path name is not too long */        if ((strlen(dir_name) + strlen(prog_name) + 5)		 > MAX_PATH_SIZE) return(ERR_SUP_NAMLNG);	/* construct path name */	file_name[0] = NULCH;	if (dir_name[0] != NULCH) {		strcat(file_name, dir_name);	        strcat(file_name, "\\");	}        strcat(file_name, prog_name);	strcat(file_name, ".MPX");        /* get current segment regs */	segread(&segregs);        /* setup function codes */	inregs.h.ah = 0x4B;        /* EXEC function */	inregs.h.al = 0x03;        /* load only */        /* setup parameter block and name pointers */        segregs.ds = FP_SEG(&file_name);	inregs.x.dx = FP_OFF(&file_name);        segregs.es = FP_SEG(&p_block);	inregs.x.bx = FP_OFF(&p_block);        /* setup load segment -- must be normalized */	p_block.load_seg = norm_seg;	p_block.reloc_seg = p_block.load_seg;        /* call the MS-DOS loader */	errcode = intdosx(&inregs,&outregs,&segregs);        errcode = errcode;        /* check for error */	if (outregs.x.cflag) return(ERR_SUP_LDFAIL);	/* load successful */	return(OK);}/* END OF FILE */mod_code1,0
/***********************************************************************	MPX: The MultiProgramming eXecutive	Project to Accompany	A Practical Approach to Operating Systems	Malcolm G. Lane & James D. Mooney	Copyright 1993, P.W.S. Kent Publishing Co., Boston, MA.		File Name: mpx_supt.c	Authors: J.J. Patnesky, A. Ghosal, M. Lane, J. Mooney	Version: 2.1b	Date: 01/31/08	Purpose: Support routines for MPX-PC		Modules: all	Environment:      IBM-PC (XT, AT or PS/2)			MS-DOS 3.3 or later			TURBO-C 3.0 or TURBO-C++ 1.0 or later	Compile using the LARGE MODEL and SS NOT equal to DS.	All addresses and pointers are "far", and	CS, DS and SS are independent.	Procedures in this file:		sys_init		sys_exit		sys_set_vec		sys_req		sys_alloc_mem		sys_free_mem		sys_get_date		sys_set_date		sys_open_dir		sys_get_entry		sys_close_dir	       sys_check_program	       sys_load_program************************************************************************Change Log:	07/16/88  akg	added comments	02/25/92  jdm	full revision, UNIX version	04/14/92  jdm	Macintosh version	05/15/92  jdm	cleanup and documentation	07/14/92  jdm	update for revised specs        08/13/92  jdm 	revised IBM version; added private heap        10/14/92  jdm 	added check and load procedures        10/18/92  jdm 	revised sys_alloc_mem for alignment	11/17/92  jdm	true heap mgt, aligned, using calloc & free	11/19/92  jdm	enable device handling for final module	12/31/92  jdm	revised sys_req parameters	01/02/93  jdm	return count value after I/O	01/03/93  jdm	revised error names and codes	01/27/93  jdm	corrected count for line input in sys_req			fixed open_dir to handle null lines	02/24/93  jdm	changed sys_set_vec param to interrupt	03/08/93  jdm	corrections to sys_check & sys_load	03/20/93  jdm	stack switch in free, check, and load	04/22/93  jdm	corrected index conflict in sys_free_mem			added safety escape in alloc table search	07/28/93  jdm	conversion to large model	09/01/93  jdm	fixed allocation bug;  made date private	09/14/93  jdm	cleaned up memory allocation        09/16/93  jdm	adjusted program load for large model        09/30/93  jdm	modified for correct list of root directory	11/01/94  jdm	changed load file read to binary	09/18/95  jdm	fixed get_entry to default to current, not root	01/31/08  jdm   fixed possible overflow problem in get_entry************************************************************************/#include "mpx_supt.h"#include <stdlib.h>#include <dos.h>#include <dir.h>#include <errno.h>#include <conio.h>#include <alloc.h>#define VEC_ADDR (0x60L*4)#define MAX_ALLOC 200#define MAX_XPOS 79#define MAX_YPOS 24#define MAX_PATH_SIZE 50/*	System-dependent type definitions*/typedef unsigned char byte;typedef unsigned int word;typedef unsigned long longword;typedef byte *address;typedef struct params {	int      op_code;	int      device_id;	char     *buf_p;	int      *count_p;	} params;/*	Global variables accessed only by support routines*/	static longword vec_save;  /* saved interrupt vector */	static int mod_code;                /* module code */                                           	static struct date sys_date;        /* MPX system date */	/* data structures for directory access */        static char current_path[MAX_PATH_SIZE+1];        static int num_entries;        static struct ffblk file_block;        /* handler presence flags */	static flag sysc_hand;	static flag trm_hand;	static flag prt_hand;	static flag com_hand;        /* memory allocation table */	static struct {		void* original;		void* aligned;	} alloc_table[MAX_ALLOC];	static int alloc_ix;                /* current index */	static int num_alloc;               /* no. of allocated blocks *//*	Procedure: sys_init	Purpose: initialize mpx	Parameters: see prototype  	Return value: error code, or OK if no error	Calls: getdate    	Globals: mod_code		vec_save		sys_date		alloc_table, alloc_ix, num_alloc		sysc_hand, term_hand, prt_hand, com_hand	Errors: none*/int sys_init (    int      modules  /* module code */	     ){	mod_code = modules;        vec_save = 0L;        /* no handlers detected yet */	sysc_hand = FALSE;	trm_hand = FALSE;	prt_hand = FALSE;	com_hand = FALSE;	/* initialize allocation table */	for (alloc_ix=0; alloc_ix < MAX_ALLOC; alloc_ix++) {		alloc_table[alloc_ix].original = NULL;		alloc_table[alloc_ix].aligned = NULL;	}	alloc_ix = 0;	num_alloc = 0;	/* if we have reached Module R3, enable system call handling */	if (modules >= MODULE_R3) sysc_hand = TRUE;	/* if we have reached the final module, enable device handlers */	if (modules >= MODULE_F) {		trm_hand = TRUE;		prt_hand = TRUE;		com_hand = TRUE;	}	/* get system date */        getdate(&sys_date);	return (OK);}/*	Procedure: sys_exit	Purpose: terminate mpx	Parameters: none  	Return value: none	Calls: none       	Globals: vec_save*/void sys_exit(void){	longword *vec_p;	/* if trap vector changed, restore it */	if (vec_save != 0L) {		vec_p = (longword*) VEC_ADDR;		*vec_p = vec_save;	}	/* return to host with null error code */	exit(0);}/*	Procedure: sys_set_vec	Purpose: link trap vector to MPX system call handler	Parameters: handler: addr of handler         	Return value: error code; OK if no error	Calls: none       	Globals: vec_save	Errors: none*/int sys_set_vec   ( void interrupt (*handler)() /* system call handler */		){	longword *vec_p;			vec_p = (longword*) VEC_ADDR;		vec_save = *vec_p;		*vec_p = (longword) handler;	return (0);}/*	Procedure: sys_req	Purpose: Request a system service	Inputs:		op_code           operation code		device_id         device identifier		buf_p             addresso f data buffer		count_p           address of size of buffer	Returns: Result or error code, depending on service		Services supported:	IDLE     null operation				READ     input from a device				WRITE    output to a device				CLEAR    clear terminal screen				GOTOXY   absolute cursor position				EXIT     terminate the caller	Calls:   fgets		strlen			Globals: none		Errors:  ERR_SUP_INVDEV    invalid device		ERR_SUP_INVOPC    invalid operation code		ERR_SUP_INVPOS    invalid character position		ERR_SUP_RDFAIL    read failed		ERR_SUP_WRFAIL    write failed	Description:	For Modules R1 through R4,	this procedure is used only for terminal I/O.	Later modules support both reading and	writing for several devices.	For Modules R1 through R4,	sys_req uses the ANSI C function "fgets."	Later modules may use alternate functions and device drivers.*/int sys_req (   int      op_code, /* operation code */		int      device_id,        /* device id */		char*    buf_p,            /* I/O buffer */		int*     count_p           /* address of count */		){	int      rval;    /* result or error code */	char     *rp;     /* return pointer for fgets */	char     rc;      /* return char for fputc */        params    *param_p; /* pointer to parameter record in stack */	flag     docall;  /* true if system call interrupt wanted */	int      ix;      /* temporary index */	docall = FALSE;	rval = OK;	switch (op_code) {		case IDLE:		if (sysc_hand) docall = TRUE;		break; 				case READ:		switch (device_id) {				case TERMINAL:			if (trm_hand) docall = TRUE;			else {				rp = fgets(buf_p,*count_p,stdin);				if (rp==NULL) rval = ERR_SUP_RDFAIL;				else rval = strlen(buf_p);			}			break;					case COM_PORT:			if (com_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					default:			rval = ERR_SUP_INVDEV;					}		break;	case WRITE:		switch (device_id) {				case TERMINAL:			if (trm_hand) docall = TRUE;			else {				rval = *count_p;				for (ix=0; ix<*count_p; ix++) {					rc = fputc(buf_p[ix],stdout);					if (rc == EOF) {						rval = ERR_SUP_WRFAIL;						break;					}				}			}			break;					case COM_PORT:			if (com_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					case PRINTER:			if (prt_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					default:			rval = ERR_SUP_INVDEV;					}		break;	case CLEAR:		if (device_id==TERMINAL) {			if (trm_hand) docall = TRUE;			else {			     clrscr();				rval = 0;			}		}		else rval = ERR_SUP_INVDEV;		break;			case GOTOXY:		if (device_id==TERMINAL) {			if (trm_hand) docall = TRUE;			else {				if (*count_p != 2) rval = ERR_SUP_WRFAIL;				else if ((*buf_p<0)					|| (*buf_p > MAX_XPOS))					rval = ERR_SUP_WRFAIL;				else if ((*(buf_p+1)<0)					|| (*(buf_p+1) > MAX_YPOS))					rval = ERR_SUP_WRFAIL;				else {					gotoxy(*buf_p + 1,						*(buf_p+1) + 1);					rval = 0;				}			}		}		else rval = ERR_SUP_INVDEV;		break;			/* EXIT - terminate the calling process */	/* legal only when a system call handler is present */	case EXIT:		if (sysc_hand) docall = TRUE;		else rval = ERR_SUP_INVOPC;		break; 	default:		rval = ERR_SUP_INVOPC;			}		/* Invoke user's call handler if present.	   If the call is an IO request, return will occur	   only after the request is complete.	*/	if (docall && (rval==OK)) {		/* invoke the call handler */	_SP = _SP - sizeof(params);		param_p = (params*) MK_FP(_SS,_SP);	       param_p->op_code = op_code;	       param_p->device_id = device_id;	       param_p->buf_p = buf_p;	       param_p->count_p = count_p;	       geninterrupt(0x60);	       rval = _AX;	       _SP = _SP + sizeof(params);		/* for I/O operations, return count value */		switch(op_code) {		case READ:		case WRITE:		case CLEAR:		case GOTOXY:			rval = *count_p;		}	}	return(rval);}/*	Procedure: sys_alloc_mem	Purpose: Allocate a memory block	Parameters:			size_t size       No. of bytes to allocate	Returns: void* pointer to allocated block;		 null pointer in case of error		 	Calls: calloc		Globals: alloc_table, alloc_ix, num_alloc	For program loading (Module R-4), the blocks must be aligned.	This is achieved by requesting one extra paragraph and	returning the lowest aligned address as the base.  It is	necessary to keep a table of allocated address, original and	aligned, to support correct freeing.	It would seem simpler to use the Turbo-C function allocmem,	which always allocates aligned blocks.  However, allocmem	appears to conflict with the internal allocation of fopen	and other C library routines.*/void *sys_alloc_mem (      size_t   size     /* size in bytes to allocate */		    ){	int ix_save;      /* temp copy of table index */        void *addr;        /* addr returned by calloc (*void) */	word offset;      /* offset of unaligned address */	word seg;         /* segment addr of unaligned address */	void *addr_alig; /* aligned address */	int rem; /* temp for alignment computation */	/* ensure that allocation table is not full */	if (num_alloc >= MAX_ALLOC) {		return(NULL);	}	/* find free entry in allocation table */	ix_save = alloc_ix;	while (alloc_table[alloc_ix].original != NULL) {		alloc_ix++;		if (alloc_ix >= MAX_ALLOC) alloc_ix = 0;		/* safety check -- should never happen! */		if (alloc_ix == ix_save) return(NULL);	}	/* call allocation routine */	/* request 15 extra bytes to ensure alignment is possible */	addr = calloc(size + 15,1);	/* compute aligned base */	offset = FP_OFF(addr);        seg = FP_SEG(addr);	rem = offset % 16;	if (rem > 0) offset = offset + 16 - rem;	addr_alig = MK_FP(seg,offset);	/* insert entries in table */	alloc_table[alloc_ix].original = addr;	alloc_table[alloc_ix].aligned = addr_alig;	/* increment count */	num_alloc++;	return(addr_alig);}/*	Procedure: sys_free_mem	Purpose: free a memory block	Parameters:		void *ptr         ptr to block to allocate	Returns: integer error code; zero if OK		Calls:   free	Globals: alloc_table, num_alloc	Errors:  ERR_SUP_INVMEM    invalid memory block	This procedure receives an aligned address; it must	find and free the corresponding non-aligned one.*/int sys_free_mem (         void     *ptr     /* pointer to block */		 ){	void *free_addr;  /* true (unaligned) block address */	int free_ix;               /* temp table index */	/* ensure valid pointer */	if (ptr==NULL) return(ERR_SUP_INVMEM);	/* Look for the block in the allocation table */	free_addr = NULL;	for (free_ix=0; free_ix<MAX_ALLOC; free_ix++) {		if (alloc_table[free_ix].aligned == ptr) {			free_addr = alloc_table[free_ix].original;			break;		}	}	/* If the block wasn't found, report error */	if (free_addr == NULL) return(ERR_SUP_INVMEM);	/* free the block & clear the table entry */	alloc_table[free_ix].original = NULL;	alloc_table[free_ix].aligned = NULL;        free(free_addr);	/* decrement count */	num_alloc--;	return(OK);}        /*	Procedure: sys_get_date	Purpose: Returns the system date (month, day, year)	Parameters:		date_rec *date_p Pointer to structure of type date	Returns: void		Calls: none		Globals: sys_date        Errors: none*/void sys_get_date (  date_rec*      date_p   /* ptr to date record */		){	date_p->month = sys_date.da_mon;	date_p->day = sys_date.da_day;	date_p->year = sys_date.da_year;}/*	Procedure: sys_set_date	Purpose: Sets the system date (month, day, year)	Parameters:		date_rec *date_p ptr to structure of type date	Returns: error code; OK if no error	Calls:   none        Globals: sys_date	Errors: none*/int sys_set_date (  date_rec*       date_p   /* ptr to date record */		 ){	sys_date.da_mon = date_p->month;        sys_date.da_day = date_p->day;        sys_date.da_year = date_p->year;	return(OK);}/*	Procedure: sys_open_dir	Purpose: open a specified directory	Parameters: char dir_name[]            directory name	Returns: error code; zero if OK	Calls:   findfirst		strncpy  	Globals: current_path, file_block, num_entries	Errors:  ERR_SUP_DIROPN    directory open error		ERR_SUP_INVDIR    invalid directory*/int sys_open_dir (  char  path_name[]        /* directory name */		 ){        char temp_path[MAX_PATH_SIZE];	int res;        int len;        /* ensure there is no directory currently open */	if (current_path[0]!=NULCH) return(ERR_SUP_DIROPN);        /* check pathname for validity */        /* construct temporary search path name */	temp_path[0] = NULCH;	if (path_name != NULL) {		strncpy(temp_path,path_name,MAX_PATH_SIZE-4);	}	/* build wildcard search string */        len = strlen(temp_path);	/* if path is null, use current directory */        if (len==0) strcpy(temp_path,"*.*");	/* handle paths ending in backslash, including root */        else if (temp_path[len-1]=='\\') strcat(temp_path,"*.*");	/* handle paths not ending in backslash */        else strcat(temp_path,"\\*.*");	/* validate the directory by searching for either an ordinary	   file or a directory in it.  This should never fail; even	   empty directories contain the directories "." and ".."	*/		res = findfirst(temp_path, &file_block, FA_DIREC);	if (res!=0)  return(ERR_SUP_INVDIR);        /* save pathname as current, clear entry count */	current_path[0] = NULCH;	if (path_name != NULL) {		strncpy(current_path,path_name,MAX_PATH_SIZE-6);	}	num_entries = 0;	return(OK);}/*	Procedure: sys_get_entry	Purpose: get the next directory entry;	Parameters: char name_buf[]	name buffer		    int buf_size  	buffer capacity		    long *file_size_p	file length buffer         	Returns: error code, or zero if ok	Calls:	findfirst		findnext		strncpy, strcpy, strrchr, strcat    	Globals: current_path, num_entries, file_block	Errors:  ERR_SUP_NOENTR    no such entry*/int sys_get_entry (char    name_buf[],       /* buffer for entry */		   int   buf_size,         /* buffer size */		   long* file_size_p       /* buffer for size value */		  ){	char filename[MAX_PATH_SIZE+1];	int err;        int len;        char *cp;        /* find next MPX file entry, if any */        /* if this is the first call */	if (num_entries==0) {	       /* construct complete search path name */	       len = strlen(current_path);	       if (len==0) strcpy(current_path,"*.MPX");	       else if (current_path[len-1]=='\\') strcat(current_path,"*.MPX");	       else strcat(current_path,"\\*.MPX");	       /* find first entry */		err = findfirst (current_path,&file_block,0);        }        /* otherwise, find next entry */        else err = findnext(&file_block);        if (err<0) return(ERR_SUP_NOENTR);		/* ensure buf_size is not too large */		if (buf_size > MAX_PATH_SIZE) buf_size = MAX_PATH_SIZE;		      /* copy filename to buffer */	filename[buf_size] = NULCH;	strncpy (filename,file_block.ff_name,			 (size_t) buf_size);	/* remove ".MPX" from name */	cp = strrchr(filename, (int) '.');        *cp = NULCH;	/* copy name and size to caller's buffer */        strcpy (name_buf,filename);	*file_size_p = file_block.ff_fsize;        /* count entry */	num_entries++;	return(OK);}/*	Procedure: sys_close_dir	Purpose: close an open directory	Parameters: none	Returns: error code; zero if OK	Calls:   none	Globals: current_path	Errors:  none*/int sys_close_dir (void){	current_path[0] = NULCH;	return(OK);}/*	Procedure: sys_check_program	Purpose: locate and measure a program file	Parameters: see prototype	Returns: program size or error code	Calls:   strlen, strcat		fopen, fread	Globals: none	Errors:  ERR_SUP_NAMLNG    pathname too long		ERR_SUP_FILNFD    file not found		ERR_SUP_FILINV    file invalid*/#define HEADER_SIZE 32int sys_check_program(     char     dir_name[],       /* directory name */			char     prog_name[],      /* program name */			int*     prog_len_p,       /* ptr to prog length */			int*     start_offset_p    /* ptr to start offset */			){        /* buffer for full pathname */	char file_name[MAX_PATH_SIZE+1];        /* buffer for file header */        byte header[HEADER_SIZE];	FILE *file_p;     /* file pointer for C file routines */        int num_read;      /* number of header bytes read */	int file_size;    /* size of complete file */        int header_size;/* size of header */        int code_size;     /* size of program code */        int data_size;     /* size of program data */        int errcode;       /* error code */        /* ensure that path name is not too long */        if ((strlen(dir_name) + strlen(prog_name) + 5)		 > MAX_PATH_SIZE) return(ERR_SUP_NAMLNG);	/* construct path name */	file_name[0] = NULCH;	if (dir_name[0] != NULCH) {		strcat(file_name, dir_name);	        strcat(file_name, "\\");	}        strcat(file_name, prog_name);	strcat(file_name, ".MPX");        /* try to open the file */	errcode = OK;        file_p = fopen(file_name, "rb");        if (file_p == NULL) return(ERR_SUP_FILNFD);	/* read the header, check for EXE signature */        num_read = fread( (void*) header, 1, HEADER_SIZE, file_p);        if (num_read != HEADER_SIZE) {		errcode = ERR_SUP_FILINV;	}        else if ((header[0] != 0x4D) || (header[1] != 0x5A)) {		errcode = ERR_SUP_FILINV;	}        /* close the file, then return if error occurred */        fclose(file_p);	if (errcode!=OK) return(errcode);        /* compute allocation size needed */        file_size = (header[5]*256 + header[4] -1) * 512		+ (header[3]*256 + header[2]);        header_size =(header[9]*256 + header[8])*16;        code_size = file_size - header_size;        data_size = (header[11]*256 + header[10])*16;        /* return total length and starting offset */        *prog_len_p = code_size + data_size;	*start_offset_p = (header[23]*256 + header[22]) * 16;	return(OK);}/*	Procedure: sys_load_program	Purpose: load a program file	Parameters: see prototype	Returns: error code; zero if OK	Calls:   intdosx		segread		strlen, strcat	Globals: none 	Errors:  ERR_SUP_NAMLNG    name too long		ERR_SUP_FILNFD    file not found	       ERR_SUP_FILINV      file invalid		ERR_SUP_PROGSZ    program too large	       ERR_SUP_LDADDR      address not aligned		ERR_SUP_LDFAIL    load failed*/int sys_load_program (     void*    load_addr,        /* address for loading */			int      max_size,         /* memory size */			char     dir_name[],       /* directory name */			char     prog_name[]       /* program name */		      ){	int errcode;      /* error code */        int prog_len;      /* program length */	int offset;       /* offset for starting */	word norm_seg;    /* normalized load address segment */        word norm_off;     /* normalized load address offset */        /* full pathname for file to be loaded */	char file_name[MAX_PATH_SIZE+1];        /* parameter block for MSDOS EXEC function */	struct {		word load_seg;    /* segment address for loading */	       word reloc_seg;     /* segment address for relocation */        }p_block;	union REGS inregs;            /* input register structure */	union REGS outregs;           /* output register structure */	struct SREGS segregs;         /* segment register structure */        /* check program, get length and offset */	errcode = sys_check_program(dir_name, prog_name,					&prog_len, &offset);        if (errcode < 0) return(errcode);        /* ensure that allocated memory is large enough */        if (max_size < prog_len) return(ERR_SUP_PROGSZ);        /* get normalized segment and offset, check alignment */	norm_seg = FP_SEG(load_addr);	norm_off = FP_OFF(load_addr);	norm_seg += norm_off / 16;        norm_off %= 16;	if (norm_off != 0) return(ERR_SUP_LDADDR);        /* ensure that path name is not too long */        if ((strlen(dir_name) + strlen(prog_name) + 5)		 > MAX_PATH_SIZE) return(ERR_SUP_NAMLNG);	/* construct path name */	file_name[0] = NULCH;	if (dir_name[0] != NULCH) {		strcat(file_name, dir_name);	        strcat(file_name, "\\");	}        strcat(file_name, prog_name);	strcat(file_name, ".MPX");        /* get current segment regs */	segread(&segregs);        /* setup function codes */	inregs.h.ah = 0x4B;        /* EXEC function */	inregs.h.al = 0x03;        /* load only */        /* setup parameter block and name pointers */        segregs.ds = FP_SEG(&file_name);	inregs.x.dx = FP_OFF(&file_name);        segregs.es = FP_SEG(&p_block);	inregs.x.bx = FP_OFF(&p_block);        /* setup load segment -- must be normalized */	p_block.load_seg = norm_seg;	p_block.reloc_seg = p_block.load_seg;        /* call the MS-DOS loader */	errcode = intdosx(&inregs,&outregs,&segregs);        errcode = errcode;        /* check for error */	if (outregs.x.cflag) return(ERR_SUP_LDFAIL);	/* load successful */	return(OK);}/* END OF FILE */sys_date1,0
/***********************************************************************	MPX: The MultiProgramming eXecutive	Project to Accompany	A Practical Approach to Operating Systems	Malcolm G. Lane & James D. Mooney	Copyright 1993, P.W.S. Kent Publishing Co., Boston, MA.		File Name: mpx_supt.c	Authors: J.J. Patnesky, A. Ghosal, M. Lane, J. Mooney	Version: 2.1b	Date: 01/31/08	Purpose: Support routines for MPX-PC		Modules: all	Environment:      IBM-PC (XT, AT or PS/2)			MS-DOS 3.3 or later			TURBO-C 3.0 or TURBO-C++ 1.0 or later	Compile using the LARGE MODEL and SS NOT equal to DS.	All addresses and pointers are "far", and	CS, DS and SS are independent.	Procedures in this file:		sys_init		sys_exit		sys_set_vec		sys_req		sys_alloc_mem		sys_free_mem		sys_get_date		sys_set_date		sys_open_dir		sys_get_entry		sys_close_dir	       sys_check_program	       sys_load_program************************************************************************Change Log:	07/16/88  akg	added comments	02/25/92  jdm	full revision, UNIX version	04/14/92  jdm	Macintosh version	05/15/92  jdm	cleanup and documentation	07/14/92  jdm	update for revised specs        08/13/92  jdm 	revised IBM version; added private heap        10/14/92  jdm 	added check and load procedures        10/18/92  jdm 	revised sys_alloc_mem for alignment	11/17/92  jdm	true heap mgt, aligned, using calloc & free	11/19/92  jdm	enable device handling for final module	12/31/92  jdm	revised sys_req parameters	01/02/93  jdm	return count value after I/O	01/03/93  jdm	revised error names and codes	01/27/93  jdm	corrected count for line input in sys_req			fixed open_dir to handle null lines	02/24/93  jdm	changed sys_set_vec param to interrupt	03/08/93  jdm	corrections to sys_check & sys_load	03/20/93  jdm	stack switch in free, check, and load	04/22/93  jdm	corrected index conflict in sys_free_mem			added safety escape in alloc table search	07/28/93  jdm	conversion to large model	09/01/93  jdm	fixed allocation bug;  made date private	09/14/93  jdm	cleaned up memory allocation        09/16/93  jdm	adjusted program load for large model        09/30/93  jdm	modified for correct list of root directory	11/01/94  jdm	changed load file read to binary	09/18/95  jdm	fixed get_entry to default to current, not root	01/31/08  jdm   fixed possible overflow problem in get_entry************************************************************************/#include "mpx_supt.h"#include <stdlib.h>#include <dos.h>#include <dir.h>#include <errno.h>#include <conio.h>#include <alloc.h>#define VEC_ADDR (0x60L*4)#define MAX_ALLOC 200#define MAX_XPOS 79#define MAX_YPOS 24#define MAX_PATH_SIZE 50/*	System-dependent type definitions*/typedef unsigned char byte;typedef unsigned int word;typedef unsigned long longword;typedef byte *address;typedef struct params {	int      op_code;	int      device_id;	char     *buf_p;	int      *count_p;	} params;/*	Global variables accessed only by support routines*/	static longword vec_save;  /* saved interrupt vector */	static int mod_code;                /* module code */                                           	static struct date sys_date;        /* MPX system date */	/* data structures for directory access */        static char current_path[MAX_PATH_SIZE+1];        static int num_entries;        static struct ffblk file_block;        /* handler presence flags */	static flag sysc_hand;	static flag trm_hand;	static flag prt_hand;	static flag com_hand;        /* memory allocation table */	static struct {		void* original;		void* aligned;	} alloc_table[MAX_ALLOC];	static int alloc_ix;                /* current index */	static int num_alloc;               /* no. of allocated blocks *//*	Procedure: sys_init	Purpose: initialize mpx	Parameters: see prototype  	Return value: error code, or OK if no error	Calls: getdate    	Globals: mod_code		vec_save		sys_date		alloc_table, alloc_ix, num_alloc		sysc_hand, term_hand, prt_hand, com_hand	Errors: none*/int sys_init (    int      modules  /* module code */	     ){	mod_code = modules;        vec_save = 0L;        /* no handlers detected yet */	sysc_hand = FALSE;	trm_hand = FALSE;	prt_hand = FALSE;	com_hand = FALSE;	/* initialize allocation table */	for (alloc_ix=0; alloc_ix < MAX_ALLOC; alloc_ix++) {		alloc_table[alloc_ix].original = NULL;		alloc_table[alloc_ix].aligned = NULL;	}	alloc_ix = 0;	num_alloc = 0;	/* if we have reached Module R3, enable system call handling */	if (modules >= MODULE_R3) sysc_hand = TRUE;	/* if we have reached the final module, enable device handlers */	if (modules >= MODULE_F) {		trm_hand = TRUE;		prt_hand = TRUE;		com_hand = TRUE;	}	/* get system date */        getdate(&sys_date);	return (OK);}/*	Procedure: sys_exit	Purpose: terminate mpx	Parameters: none  	Return value: none	Calls: none       	Globals: vec_save*/void sys_exit(void){	longword *vec_p;	/* if trap vector changed, restore it */	if (vec_save != 0L) {		vec_p = (longword*) VEC_ADDR;		*vec_p = vec_save;	}	/* return to host with null error code */	exit(0);}/*	Procedure: sys_set_vec	Purpose: link trap vector to MPX system call handler	Parameters: handler: addr of handler         	Return value: error code; OK if no error	Calls: none       	Globals: vec_save	Errors: none*/int sys_set_vec   ( void interrupt (*handler)() /* system call handler */		){	longword *vec_p;			vec_p = (longword*) VEC_ADDR;		vec_save = *vec_p;		*vec_p = (longword) handler;	return (0);}/*	Procedure: sys_req	Purpose: Request a system service	Inputs:		op_code           operation code		device_id         device identifier		buf_p             addresso f data buffer		count_p           address of size of buffer	Returns: Result or error code, depending on service		Services supported:	IDLE     null operation				READ     input from a device				WRITE    output to a device				CLEAR    clear terminal screen				GOTOXY   absolute cursor position				EXIT     terminate the caller	Calls:   fgets		strlen			Globals: none		Errors:  ERR_SUP_INVDEV    invalid device		ERR_SUP_INVOPC    invalid operation code		ERR_SUP_INVPOS    invalid character position		ERR_SUP_RDFAIL    read failed		ERR_SUP_WRFAIL    write failed	Description:	For Modules R1 through R4,	this procedure is used only for terminal I/O.	Later modules support both reading and	writing for several devices.	For Modules R1 through R4,	sys_req uses the ANSI C function "fgets."	Later modules may use alternate functions and device drivers.*/int sys_req (   int      op_code, /* operation code */		int      device_id,        /* device id */		char*    buf_p,            /* I/O buffer */		int*     count_p           /* address of count */		){	int      rval;    /* result or error code */	char     *rp;     /* return pointer for fgets */	char     rc;      /* return char for fputc */        params    *param_p; /* pointer to parameter record in stack */	flag     docall;  /* true if system call interrupt wanted */	int      ix;      /* temporary index */	docall = FALSE;	rval = OK;	switch (op_code) {		case IDLE:		if (sysc_hand) docall = TRUE;		break; 				case READ:		switch (device_id) {				case TERMINAL:			if (trm_hand) docall = TRUE;			else {				rp = fgets(buf_p,*count_p,stdin);				if (rp==NULL) rval = ERR_SUP_RDFAIL;				else rval = strlen(buf_p);			}			break;					case COM_PORT:			if (com_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					default:			rval = ERR_SUP_INVDEV;					}		break;	case WRITE:		switch (device_id) {				case TERMINAL:			if (trm_hand) docall = TRUE;			else {				rval = *count_p;				for (ix=0; ix<*count_p; ix++) {					rc = fputc(buf_p[ix],stdout);					if (rc == EOF) {						rval = ERR_SUP_WRFAIL;						break;					}				}			}			break;					case COM_PORT:			if (com_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					case PRINTER:			if (prt_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					default:			rval = ERR_SUP_INVDEV;					}		break;	case CLEAR:		if (device_id==TERMINAL) {			if (trm_hand) docall = TRUE;			else {			     clrscr();				rval = 0;			}		}		else rval = ERR_SUP_INVDEV;		break;			case GOTOXY:		if (device_id==TERMINAL) {			if (trm_hand) docall = TRUE;			else {				if (*count_p != 2) rval = ERR_SUP_WRFAIL;				else if ((*buf_p<0)					|| (*buf_p > MAX_XPOS))					rval = ERR_SUP_WRFAIL;				else if ((*(buf_p+1)<0)					|| (*(buf_p+1) > MAX_YPOS))					rval = ERR_SUP_WRFAIL;				else {					gotoxy(*buf_p + 1,						*(buf_p+1) + 1);					rval = 0;				}			}		}		else rval = ERR_SUP_INVDEV;		break;			/* EXIT - terminate the calling process */	/* legal only when a system call handler is present */	case EXIT:		if (sysc_hand) docall = TRUE;		else rval = ERR_SUP_INVOPC;		break; 	default:		rval = ERR_SUP_INVOPC;			}		/* Invoke user's call handler if present.	   If the call is an IO request, return will occur	   only after the request is complete.	*/	if (docall && (rval==OK)) {		/* invoke the call handler */	_SP = _SP - sizeof(params);		param_p = (params*) MK_FP(_SS,_SP);	       param_p->op_code = op_code;	       param_p->device_id = device_id;	       param_p->buf_p = buf_p;	       param_p->count_p = count_p;	       geninterrupt(0x60);	       rval = _AX;	       _SP = _SP + sizeof(params);		/* for I/O operations, return count value */		switch(op_code) {		case READ:		case WRITE:		case CLEAR:		case GOTOXY:			rval = *count_p;		}	}	return(rval);}/*	Procedure: sys_alloc_mem	Purpose: Allocate a memory block	Parameters:			size_t size       No. of bytes to allocate	Returns: void* pointer to allocated block;		 null pointer in case of error		 	Calls: calloc		Globals: alloc_table, alloc_ix, num_alloc	For program loading (Module R-4), the blocks must be aligned.	This is achieved by requesting one extra paragraph and	returning the lowest aligned address as the base.  It is	necessary to keep a table of allocated address, original and	aligned, to support correct freeing.	It would seem simpler to use the Turbo-C function allocmem,	which always allocates aligned blocks.  However, allocmem	appears to conflict with the internal allocation of fopen	and other C library routines.*/void *sys_alloc_mem (      size_t   size     /* size in bytes to allocate */		    ){	int ix_save;      /* temp copy of table index */        void *addr;        /* addr returned by calloc (*void) */	word offset;      /* offset of unaligned address */	word seg;         /* segment addr of unaligned address */	void *addr_alig; /* aligned address */	int rem; /* temp for alignment computation */	/* ensure that allocation table is not full */	if (num_alloc >= MAX_ALLOC) {		return(NULL);	}	/* find free entry in allocation table */	ix_save = alloc_ix;	while (alloc_table[alloc_ix].original != NULL) {		alloc_ix++;		if (alloc_ix >= MAX_ALLOC) alloc_ix = 0;		/* safety check -- should never happen! */		if (alloc_ix == ix_save) return(NULL);	}	/* call allocation routine */	/* request 15 extra bytes to ensure alignment is possible */	addr = calloc(size + 15,1);	/* compute aligned base */	offset = FP_OFF(addr);        seg = FP_SEG(addr);	rem = offset % 16;	if (rem > 0) offset = offset + 16 - rem;	addr_alig = MK_FP(seg,offset);	/* insert entries in table */	alloc_table[alloc_ix].original = addr;	alloc_table[alloc_ix].aligned = addr_alig;	/* increment count */	num_alloc++;	return(addr_alig);}/*	Procedure: sys_free_mem	Purpose: free a memory block	Parameters:		void *ptr         ptr to block to allocate	Returns: integer error code; zero if OK		Calls:   free	Globals: alloc_table, num_alloc	Errors:  ERR_SUP_INVMEM    invalid memory block	This procedure receives an aligned address; it must	find and free the corresponding non-aligned one.*/int sys_free_mem (         void     *ptr     /* pointer to block */		 ){	void *free_addr;  /* true (unaligned) block address */	int free_ix;               /* temp table index */	/* ensure valid pointer */	if (ptr==NULL) return(ERR_SUP_INVMEM);	/* Look for the block in the allocation table */	free_addr = NULL;	for (free_ix=0; free_ix<MAX_ALLOC; free_ix++) {		if (alloc_table[free_ix].aligned == ptr) {			free_addr = alloc_table[free_ix].original;			break;		}	}	/* If the block wasn't found, report error */	if (free_addr == NULL) return(ERR_SUP_INVMEM);	/* free the block & clear the table entry */	alloc_table[free_ix].original = NULL;	alloc_table[free_ix].aligned = NULL;        free(free_addr);	/* decrement count */	num_alloc--;	return(OK);}        /*	Procedure: sys_get_date	Purpose: Returns the system date (month, day, year)	Parameters:		date_rec *date_p Pointer to structure of type date	Returns: void		Calls: none		Globals: sys_date        Errors: none*/void sys_get_date (  date_rec*      date_p   /* ptr to date record */		){	date_p->month = sys_date.da_mon;	date_p->day = sys_date.da_day;	date_p->year = sys_date.da_year;}/*	Procedure: sys_set_date	Purpose: Sets the system date (month, day, year)	Parameters:		date_rec *date_p ptr to structure of type date	Returns: error code; OK if no error	Calls:   none        Globals: sys_date	Errors: none*/int sys_set_date (  date_rec*       date_p   /* ptr to date record */		 ){	sys_date.da_mon = date_p->month;        sys_date.da_day = date_p->day;        sys_date.da_year = date_p->year;	return(OK);}/*	Procedure: sys_open_dir	Purpose: open a specified directory	Parameters: char dir_name[]            directory name	Returns: error code; zero if OK	Calls:   findfirst		strncpy  	Globals: current_path, file_block, num_entries	Errors:  ERR_SUP_DIROPN    directory open error		ERR_SUP_INVDIR    invalid directory*/int sys_open_dir (  char  path_name[]        /* directory name */		 ){        char temp_path[MAX_PATH_SIZE];	int res;        int len;        /* ensure there is no directory currently open */	if (current_path[0]!=NULCH) return(ERR_SUP_DIROPN);        /* check pathname for validity */        /* construct temporary search path name */	temp_path[0] = NULCH;	if (path_name != NULL) {		strncpy(temp_path,path_name,MAX_PATH_SIZE-4);	}	/* build wildcard search string */        len = strlen(temp_path);	/* if path is null, use current directory */        if (len==0) strcpy(temp_path,"*.*");	/* handle paths ending in backslash, including root */        else if (temp_path[len-1]=='\\') strcat(temp_path,"*.*");	/* handle paths not ending in backslash */        else strcat(temp_path,"\\*.*");	/* validate the directory by searching for either an ordinary	   file or a directory in it.  This should never fail; even	   empty directories contain the directories "." and ".."	*/		res = findfirst(temp_path, &file_block, FA_DIREC);	if (res!=0)  return(ERR_SUP_INVDIR);        /* save pathname as current, clear entry count */	current_path[0] = NULCH;	if (path_name != NULL) {		strncpy(current_path,path_name,MAX_PATH_SIZE-6);	}	num_entries = 0;	return(OK);}/*	Procedure: sys_get_entry	Purpose: get the next directory entry;	Parameters: char name_buf[]	name buffer		    int buf_size  	buffer capacity		    long *file_size_p	file length buffer         	Returns: error code, or zero if ok	Calls:	findfirst		findnext		strncpy, strcpy, strrchr, strcat    	Globals: current_path, num_entries, file_block	Errors:  ERR_SUP_NOENTR    no such entry*/int sys_get_entry (char    name_buf[],       /* buffer for entry */		   int   buf_size,         /* buffer size */		   long* file_size_p       /* buffer for size value */		  ){	char filename[MAX_PATH_SIZE+1];	int err;        int len;        char *cp;        /* find next MPX file entry, if any */        /* if this is the first call */	if (num_entries==0) {	       /* construct complete search path name */	       len = strlen(current_path);	       if (len==0) strcpy(current_path,"*.MPX");	       else if (current_path[len-1]=='\\') strcat(current_path,"*.MPX");	       else strcat(current_path,"\\*.MPX");	       /* find first entry */		err = findfirst (current_path,&file_block,0);        }        /* otherwise, find next entry */        else err = findnext(&file_block);        if (err<0) return(ERR_SUP_NOENTR);		/* ensure buf_size is not too large */		if (buf_size > MAX_PATH_SIZE) buf_size = MAX_PATH_SIZE;		      /* copy filename to buffer */	filename[buf_size] = NULCH;	strncpy (filename,file_block.ff_name,			 (size_t) buf_size);	/* remove ".MPX" from name */	cp = strrchr(filename, (int) '.');        *cp = NULCH;	/* copy name and size to caller's buffer */        strcpy (name_buf,filename);	*file_size_p = file_block.ff_fsize;        /* count entry */	num_entries++;	return(OK);}/*	Procedure: sys_close_dir	Purpose: close an open directory	Parameters: none	Returns: error code; zero if OK	Calls:   none	Globals: current_path	Errors:  none*/int sys_close_dir (void){	current_path[0] = NULCH;	return(OK);}/*	Procedure: sys_check_program	Purpose: locate and measure a program file	Parameters: see prototype	Returns: program size or error code	Calls:   strlen, strcat		fopen, fread	Globals: none	Errors:  ERR_SUP_NAMLNG    pathname too long		ERR_SUP_FILNFD    file not found		ERR_SUP_FILINV    file invalid*/#define HEADER_SIZE 32int sys_check_program(     char     dir_name[],       /* directory name */			char     prog_name[],      /* program name */			int*     prog_len_p,       /* ptr to prog length */			int*     start_offset_p    /* ptr to start offset */			){        /* buffer for full pathname */	char file_name[MAX_PATH_SIZE+1];        /* buffer for file header */        byte header[HEADER_SIZE];	FILE *file_p;     /* file pointer for C file routines */        int num_read;      /* number of header bytes read */	int file_size;    /* size of complete file */        int header_size;/* size of header */        int code_size;     /* size of program code */        int data_size;     /* size of program data */        int errcode;       /* error code */        /* ensure that path name is not too long */        if ((strlen(dir_name) + strlen(prog_name) + 5)		 > MAX_PATH_SIZE) return(ERR_SUP_NAMLNG);	/* construct path name */	file_name[0] = NULCH;	if (dir_name[0] != NULCH) {		strcat(file_name, dir_name);	        strcat(file_name, "\\");	}        strcat(file_name, prog_name);	strcat(file_name, ".MPX");        /* try to open the file */	errcode = OK;        file_p = fopen(file_name, "rb");        if (file_p == NULL) return(ERR_SUP_FILNFD);	/* read the header, check for EXE signature */        num_read = fread( (void*) header, 1, HEADER_SIZE, file_p);        if (num_read != HEADER_SIZE) {		errcode = ERR_SUP_FILINV;	}        else if ((header[0] != 0x4D) || (header[1] != 0x5A)) {		errcode = ERR_SUP_FILINV;	}        /* close the file, then return if error occurred */        fclose(file_p);	if (errcode!=OK) return(errcode);        /* compute allocation size needed */        file_size = (header[5]*256 + header[4] -1) * 512		+ (header[3]*256 + header[2]);        header_size =(header[9]*256 + header[8])*16;        code_size = file_size - header_size;        data_size = (header[11]*256 + header[10])*16;        /* return total length and starting offset */        *prog_len_p = code_size + data_size;	*start_offset_p = (header[23]*256 + header[22]) * 16;	return(OK);}/*	Procedure: sys_load_program	Purpose: load a program file	Parameters: see prototype	Returns: error code; zero if OK	Calls:   intdosx		segread		strlen, strcat	Globals: none 	Errors:  ERR_SUP_NAMLNG    name too long		ERR_SUP_FILNFD    file not found	       ERR_SUP_FILINV      file invalid		ERR_SUP_PROGSZ    program too large	       ERR_SUP_LDADDR      address not aligned		ERR_SUP_LDFAIL    load failed*/int sys_load_program (     void*    load_addr,        /* address for loading */			int      max_size,         /* memory size */			char     dir_name[],       /* directory name */			char     prog_name[]       /* program name */		      ){	int errcode;      /* error code */        int prog_len;      /* program length */	int offset;       /* offset for starting */	word norm_seg;    /* normalized load address segment */        word norm_off;     /* normalized load address offset */        /* full pathname for file to be loaded */	char file_name[MAX_PATH_SIZE+1];        /* parameter block for MSDOS EXEC function */	struct {		word load_seg;    /* segment address for loading */	       word reloc_seg;     /* segment address for relocation */        }p_block;	union REGS inregs;            /* input register structure */	union REGS outregs;           /* output register structure */	struct SREGS segregs;         /* segment register structure */        /* check program, get length and offset */	errcode = sys_check_program(dir_name, prog_name,					&prog_len, &offset);        if (errcode < 0) return(errcode);        /* ensure that allocated memory is large enough */        if (max_size < prog_len) return(ERR_SUP_PROGSZ);        /* get normalized segment and offset, check alignment */	norm_seg = FP_SEG(load_addr);	norm_off = FP_OFF(load_addr);	norm_seg += norm_off / 16;        norm_off %= 16;	if (norm_off != 0) return(ERR_SUP_LDADDR);        /* ensure that path name is not too long */        if ((strlen(dir_name) + strlen(prog_name) + 5)		 > MAX_PATH_SIZE) return(ERR_SUP_NAMLNG);	/* construct path name */	file_name[0] = NULCH;	if (dir_name[0] != NULCH) {		strcat(file_name, dir_name);	        strcat(file_name, "\\");	}        strcat(file_name, prog_name);	strcat(file_name, ".MPX");        /* get current segment regs */	segread(&segregs);        /* setup function codes */	inregs.h.ah = 0x4B;        /* EXEC function */	inregs.h.al = 0x03;        /* load only */        /* setup parameter block and name pointers */        segregs.ds = FP_SEG(&file_name);	inregs.x.dx = FP_OFF(&file_name);        segregs.es = FP_SEG(&p_block);	inregs.x.bx = FP_OFF(&p_block);        /* setup load segment -- must be normalized */	p_block.load_seg = norm_seg;	p_block.reloc_seg = p_block.load_seg;        /* call the MS-DOS loader */	errcode = intdosx(&inregs,&outregs,&segregs);        errcode = errcode;        /* check for error */	if (outregs.x.cflag) return(ERR_SUP_LDFAIL);	/* load successful */	return(OK);}/* END OF FILE */current_path1,0
/***********************************************************************	MPX: The MultiProgramming eXecutive	Project to Accompany	A Practical Approach to Operating Systems	Malcolm G. Lane & James D. Mooney	Copyright 1993, P.W.S. Kent Publishing Co., Boston, MA.		File Name: mpx_supt.c	Authors: J.J. Patnesky, A. Ghosal, M. Lane, J. Mooney	Version: 2.1b	Date: 01/31/08	Purpose: Support routines for MPX-PC		Modules: all	Environment:      IBM-PC (XT, AT or PS/2)			MS-DOS 3.3 or later			TURBO-C 3.0 or TURBO-C++ 1.0 or later	Compile using the LARGE MODEL and SS NOT equal to DS.	All addresses and pointers are "far", and	CS, DS and SS are independent.	Procedures in this file:		sys_init		sys_exit		sys_set_vec		sys_req		sys_alloc_mem		sys_free_mem		sys_get_date		sys_set_date		sys_open_dir		sys_get_entry		sys_close_dir	       sys_check_program	       sys_load_program************************************************************************Change Log:	07/16/88  akg	added comments	02/25/92  jdm	full revision, UNIX version	04/14/92  jdm	Macintosh version	05/15/92  jdm	cleanup and documentation	07/14/92  jdm	update for revised specs        08/13/92  jdm 	revised IBM version; added private heap        10/14/92  jdm 	added check and load procedures        10/18/92  jdm 	revised sys_alloc_mem for alignment	11/17/92  jdm	true heap mgt, aligned, using calloc & free	11/19/92  jdm	enable device handling for final module	12/31/92  jdm	revised sys_req parameters	01/02/93  jdm	return count value after I/O	01/03/93  jdm	revised error names and codes	01/27/93  jdm	corrected count for line input in sys_req			fixed open_dir to handle null lines	02/24/93  jdm	changed sys_set_vec param to interrupt	03/08/93  jdm	corrections to sys_check & sys_load	03/20/93  jdm	stack switch in free, check, and load	04/22/93  jdm	corrected index conflict in sys_free_mem			added safety escape in alloc table search	07/28/93  jdm	conversion to large model	09/01/93  jdm	fixed allocation bug;  made date private	09/14/93  jdm	cleaned up memory allocation        09/16/93  jdm	adjusted program load for large model        09/30/93  jdm	modified for correct list of root directory	11/01/94  jdm	changed load file read to binary	09/18/95  jdm	fixed get_entry to default to current, not root	01/31/08  jdm   fixed possible overflow problem in get_entry************************************************************************/#include "mpx_supt.h"#include <stdlib.h>#include <dos.h>#include <dir.h>#include <errno.h>#include <conio.h>#include <alloc.h>#define VEC_ADDR (0x60L*4)#define MAX_ALLOC 200#define MAX_XPOS 79#define MAX_YPOS 24#define MAX_PATH_SIZE 50/*	System-dependent type definitions*/typedef unsigned char byte;typedef unsigned int word;typedef unsigned long longword;typedef byte *address;typedef struct params {	int      op_code;	int      device_id;	char     *buf_p;	int      *count_p;	} params;/*	Global variables accessed only by support routines*/	static longword vec_save;  /* saved interrupt vector */	static int mod_code;                /* module code */                                           	static struct date sys_date;        /* MPX system date */	/* data structures for directory access */        static char current_path[MAX_PATH_SIZE+1];        static int num_entries;        static struct ffblk file_block;        /* handler presence flags */	static flag sysc_hand;	static flag trm_hand;	static flag prt_hand;	static flag com_hand;        /* memory allocation table */	static struct {		void* original;		void* aligned;	} alloc_table[MAX_ALLOC];	static int alloc_ix;                /* current index */	static int num_alloc;               /* no. of allocated blocks *//*	Procedure: sys_init	Purpose: initialize mpx	Parameters: see prototype  	Return value: error code, or OK if no error	Calls: getdate    	Globals: mod_code		vec_save		sys_date		alloc_table, alloc_ix, num_alloc		sysc_hand, term_hand, prt_hand, com_hand	Errors: none*/int sys_init (    int      modules  /* module code */	     ){	mod_code = modules;        vec_save = 0L;        /* no handlers detected yet */	sysc_hand = FALSE;	trm_hand = FALSE;	prt_hand = FALSE;	com_hand = FALSE;	/* initialize allocation table */	for (alloc_ix=0; alloc_ix < MAX_ALLOC; alloc_ix++) {		alloc_table[alloc_ix].original = NULL;		alloc_table[alloc_ix].aligned = NULL;	}	alloc_ix = 0;	num_alloc = 0;	/* if we have reached Module R3, enable system call handling */	if (modules >= MODULE_R3) sysc_hand = TRUE;	/* if we have reached the final module, enable device handlers */	if (modules >= MODULE_F) {		trm_hand = TRUE;		prt_hand = TRUE;		com_hand = TRUE;	}	/* get system date */        getdate(&sys_date);	return (OK);}/*	Procedure: sys_exit	Purpose: terminate mpx	Parameters: none  	Return value: none	Calls: none       	Globals: vec_save*/void sys_exit(void){	longword *vec_p;	/* if trap vector changed, restore it */	if (vec_save != 0L) {		vec_p = (longword*) VEC_ADDR;		*vec_p = vec_save;	}	/* return to host with null error code */	exit(0);}/*	Procedure: sys_set_vec	Purpose: link trap vector to MPX system call handler	Parameters: handler: addr of handler         	Return value: error code; OK if no error	Calls: none       	Globals: vec_save	Errors: none*/int sys_set_vec   ( void interrupt (*handler)() /* system call handler */		){	longword *vec_p;			vec_p = (longword*) VEC_ADDR;		vec_save = *vec_p;		*vec_p = (longword) handler;	return (0);}/*	Procedure: sys_req	Purpose: Request a system service	Inputs:		op_code           operation code		device_id         device identifier		buf_p             addresso f data buffer		count_p           address of size of buffer	Returns: Result or error code, depending on service		Services supported:	IDLE     null operation				READ     input from a device				WRITE    output to a device				CLEAR    clear terminal screen				GOTOXY   absolute cursor position				EXIT     terminate the caller	Calls:   fgets		strlen			Globals: none		Errors:  ERR_SUP_INVDEV    invalid device		ERR_SUP_INVOPC    invalid operation code		ERR_SUP_INVPOS    invalid character position		ERR_SUP_RDFAIL    read failed		ERR_SUP_WRFAIL    write failed	Description:	For Modules R1 through R4,	this procedure is used only for terminal I/O.	Later modules support both reading and	writing for several devices.	For Modules R1 through R4,	sys_req uses the ANSI C function "fgets."	Later modules may use alternate functions and device drivers.*/int sys_req (   int      op_code, /* operation code */		int      device_id,        /* device id */		char*    buf_p,            /* I/O buffer */		int*     count_p           /* address of count */		){	int      rval;    /* result or error code */	char     *rp;     /* return pointer for fgets */	char     rc;      /* return char for fputc */        params    *param_p; /* pointer to parameter record in stack */	flag     docall;  /* true if system call interrupt wanted */	int      ix;      /* temporary index */	docall = FALSE;	rval = OK;	switch (op_code) {		case IDLE:		if (sysc_hand) docall = TRUE;		break; 				case READ:		switch (device_id) {				case TERMINAL:			if (trm_hand) docall = TRUE;			else {				rp = fgets(buf_p,*count_p,stdin);				if (rp==NULL) rval = ERR_SUP_RDFAIL;				else rval = strlen(buf_p);			}			break;					case COM_PORT:			if (com_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					default:			rval = ERR_SUP_INVDEV;					}		break;	case WRITE:		switch (device_id) {				case TERMINAL:			if (trm_hand) docall = TRUE;			else {				rval = *count_p;				for (ix=0; ix<*count_p; ix++) {					rc = fputc(buf_p[ix],stdout);					if (rc == EOF) {						rval = ERR_SUP_WRFAIL;						break;					}				}			}			break;					case COM_PORT:			if (com_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					case PRINTER:			if (prt_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					default:			rval = ERR_SUP_INVDEV;					}		break;	case CLEAR:		if (device_id==TERMINAL) {			if (trm_hand) docall = TRUE;			else {			     clrscr();				rval = 0;			}		}		else rval = ERR_SUP_INVDEV;		break;			case GOTOXY:		if (device_id==TERMINAL) {			if (trm_hand) docall = TRUE;			else {				if (*count_p != 2) rval = ERR_SUP_WRFAIL;				else if ((*buf_p<0)					|| (*buf_p > MAX_XPOS))					rval = ERR_SUP_WRFAIL;				else if ((*(buf_p+1)<0)					|| (*(buf_p+1) > MAX_YPOS))					rval = ERR_SUP_WRFAIL;				else {					gotoxy(*buf_p + 1,						*(buf_p+1) + 1);					rval = 0;				}			}		}		else rval = ERR_SUP_INVDEV;		break;			/* EXIT - terminate the calling process */	/* legal only when a system call handler is present */	case EXIT:		if (sysc_hand) docall = TRUE;		else rval = ERR_SUP_INVOPC;		break; 	default:		rval = ERR_SUP_INVOPC;			}		/* Invoke user's call handler if present.	   If the call is an IO request, return will occur	   only after the request is complete.	*/	if (docall && (rval==OK)) {		/* invoke the call handler */	_SP = _SP - sizeof(params);		param_p = (params*) MK_FP(_SS,_SP);	       param_p->op_code = op_code;	       param_p->device_id = device_id;	       param_p->buf_p = buf_p;	       param_p->count_p = count_p;	       geninterrupt(0x60);	       rval = _AX;	       _SP = _SP + sizeof(params);		/* for I/O operations, return count value */		switch(op_code) {		case READ:		case WRITE:		case CLEAR:		case GOTOXY:			rval = *count_p;		}	}	return(rval);}/*	Procedure: sys_alloc_mem	Purpose: Allocate a memory block	Parameters:			size_t size       No. of bytes to allocate	Returns: void* pointer to allocated block;		 null pointer in case of error		 	Calls: calloc		Globals: alloc_table, alloc_ix, num_alloc	For program loading (Module R-4), the blocks must be aligned.	This is achieved by requesting one extra paragraph and	returning the lowest aligned address as the base.  It is	necessary to keep a table of allocated address, original and	aligned, to support correct freeing.	It would seem simpler to use the Turbo-C function allocmem,	which always allocates aligned blocks.  However, allocmem	appears to conflict with the internal allocation of fopen	and other C library routines.*/void *sys_alloc_mem (      size_t   size     /* size in bytes to allocate */		    ){	int ix_save;      /* temp copy of table index */        void *addr;        /* addr returned by calloc (*void) */	word offset;      /* offset of unaligned address */	word seg;         /* segment addr of unaligned address */	void *addr_alig; /* aligned address */	int rem; /* temp for alignment computation */	/* ensure that allocation table is not full */	if (num_alloc >= MAX_ALLOC) {		return(NULL);	}	/* find free entry in allocation table */	ix_save = alloc_ix;	while (alloc_table[alloc_ix].original != NULL) {		alloc_ix++;		if (alloc_ix >= MAX_ALLOC) alloc_ix = 0;		/* safety check -- should never happen! */		if (alloc_ix == ix_save) return(NULL);	}	/* call allocation routine */	/* request 15 extra bytes to ensure alignment is possible */	addr = calloc(size + 15,1);	/* compute aligned base */	offset = FP_OFF(addr);        seg = FP_SEG(addr);	rem = offset % 16;	if (rem > 0) offset = offset + 16 - rem;	addr_alig = MK_FP(seg,offset);	/* insert entries in table */	alloc_table[alloc_ix].original = addr;	alloc_table[alloc_ix].aligned = addr_alig;	/* increment count */	num_alloc++;	return(addr_alig);}/*	Procedure: sys_free_mem	Purpose: free a memory block	Parameters:		void *ptr         ptr to block to allocate	Returns: integer error code; zero if OK		Calls:   free	Globals: alloc_table, num_alloc	Errors:  ERR_SUP_INVMEM    invalid memory block	This procedure receives an aligned address; it must	find and free the corresponding non-aligned one.*/int sys_free_mem (         void     *ptr     /* pointer to block */		 ){	void *free_addr;  /* true (unaligned) block address */	int free_ix;               /* temp table index */	/* ensure valid pointer */	if (ptr==NULL) return(ERR_SUP_INVMEM);	/* Look for the block in the allocation table */	free_addr = NULL;	for (free_ix=0; free_ix<MAX_ALLOC; free_ix++) {		if (alloc_table[free_ix].aligned == ptr) {			free_addr = alloc_table[free_ix].original;			break;		}	}	/* If the block wasn't found, report error */	if (free_addr == NULL) return(ERR_SUP_INVMEM);	/* free the block & clear the table entry */	alloc_table[free_ix].original = NULL;	alloc_table[free_ix].aligned = NULL;        free(free_addr);	/* decrement count */	num_alloc--;	return(OK);}        /*	Procedure: sys_get_date	Purpose: Returns the system date (month, day, year)	Parameters:		date_rec *date_p Pointer to structure of type date	Returns: void		Calls: none		Globals: sys_date        Errors: none*/void sys_get_date (  date_rec*      date_p   /* ptr to date record */		){	date_p->month = sys_date.da_mon;	date_p->day = sys_date.da_day;	date_p->year = sys_date.da_year;}/*	Procedure: sys_set_date	Purpose: Sets the system date (month, day, year)	Parameters:		date_rec *date_p ptr to structure of type date	Returns: error code; OK if no error	Calls:   none        Globals: sys_date	Errors: none*/int sys_set_date (  date_rec*       date_p   /* ptr to date record */		 ){	sys_date.da_mon = date_p->month;        sys_date.da_day = date_p->day;        sys_date.da_year = date_p->year;	return(OK);}/*	Procedure: sys_open_dir	Purpose: open a specified directory	Parameters: char dir_name[]            directory name	Returns: error code; zero if OK	Calls:   findfirst		strncpy  	Globals: current_path, file_block, num_entries	Errors:  ERR_SUP_DIROPN    directory open error		ERR_SUP_INVDIR    invalid directory*/int sys_open_dir (  char  path_name[]        /* directory name */		 ){        char temp_path[MAX_PATH_SIZE];	int res;        int len;        /* ensure there is no directory currently open */	if (current_path[0]!=NULCH) return(ERR_SUP_DIROPN);        /* check pathname for validity */        /* construct temporary search path name */	temp_path[0] = NULCH;	if (path_name != NULL) {		strncpy(temp_path,path_name,MAX_PATH_SIZE-4);	}	/* build wildcard search string */        len = strlen(temp_path);	/* if path is null, use current directory */        if (len==0) strcpy(temp_path,"*.*");	/* handle paths ending in backslash, including root */        else if (temp_path[len-1]=='\\') strcat(temp_path,"*.*");	/* handle paths not ending in backslash */        else strcat(temp_path,"\\*.*");	/* validate the directory by searching for either an ordinary	   file or a directory in it.  This should never fail; even	   empty directories contain the directories "." and ".."	*/		res = findfirst(temp_path, &file_block, FA_DIREC);	if (res!=0)  return(ERR_SUP_INVDIR);        /* save pathname as current, clear entry count */	current_path[0] = NULCH;	if (path_name != NULL) {		strncpy(current_path,path_name,MAX_PATH_SIZE-6);	}	num_entries = 0;	return(OK);}/*	Procedure: sys_get_entry	Purpose: get the next directory entry;	Parameters: char name_buf[]	name buffer		    int buf_size  	buffer capacity		    long *file_size_p	file length buffer         	Returns: error code, or zero if ok	Calls:	findfirst		findnext		strncpy, strcpy, strrchr, strcat    	Globals: current_path, num_entries, file_block	Errors:  ERR_SUP_NOENTR    no such entry*/int sys_get_entry (char    name_buf[],       /* buffer for entry */		   int   buf_size,         /* buffer size */		   long* file_size_p       /* buffer for size value */		  ){	char filename[MAX_PATH_SIZE+1];	int err;        int len;        char *cp;        /* find next MPX file entry, if any */        /* if this is the first call */	if (num_entries==0) {	       /* construct complete search path name */	       len = strlen(current_path);	       if (len==0) strcpy(current_path,"*.MPX");	       else if (current_path[len-1]=='\\') strcat(current_path,"*.MPX");	       else strcat(current_path,"\\*.MPX");	       /* find first entry */		err = findfirst (current_path,&file_block,0);        }        /* otherwise, find next entry */        else err = findnext(&file_block);        if (err<0) return(ERR_SUP_NOENTR);		/* ensure buf_size is not too large */		if (buf_size > MAX_PATH_SIZE) buf_size = MAX_PATH_SIZE;		      /* copy filename to buffer */	filename[buf_size] = NULCH;	strncpy (filename,file_block.ff_name,			 (size_t) buf_size);	/* remove ".MPX" from name */	cp = strrchr(filename, (int) '.');        *cp = NULCH;	/* copy name and size to caller's buffer */        strcpy (name_buf,filename);	*file_size_p = file_block.ff_fsize;        /* count entry */	num_entries++;	return(OK);}/*	Procedure: sys_close_dir	Purpose: close an open directory	Parameters: none	Returns: error code; zero if OK	Calls:   none	Globals: current_path	Errors:  none*/int sys_close_dir (void){	current_path[0] = NULCH;	return(OK);}/*	Procedure: sys_check_program	Purpose: locate and measure a program file	Parameters: see prototype	Returns: program size or error code	Calls:   strlen, strcat		fopen, fread	Globals: none	Errors:  ERR_SUP_NAMLNG    pathname too long		ERR_SUP_FILNFD    file not found		ERR_SUP_FILINV    file invalid*/#define HEADER_SIZE 32int sys_check_program(     char     dir_name[],       /* directory name */			char     prog_name[],      /* program name */			int*     prog_len_p,       /* ptr to prog length */			int*     start_offset_p    /* ptr to start offset */			){        /* buffer for full pathname */	char file_name[MAX_PATH_SIZE+1];        /* buffer for file header */        byte header[HEADER_SIZE];	FILE *file_p;     /* file pointer for C file routines */        int num_read;      /* number of header bytes read */	int file_size;    /* size of complete file */        int header_size;/* size of header */        int code_size;     /* size of program code */        int data_size;     /* size of program data */        int errcode;       /* error code */        /* ensure that path name is not too long */        if ((strlen(dir_name) + strlen(prog_name) + 5)		 > MAX_PATH_SIZE) return(ERR_SUP_NAMLNG);	/* construct path name */	file_name[0] = NULCH;	if (dir_name[0] != NULCH) {		strcat(file_name, dir_name);	        strcat(file_name, "\\");	}        strcat(file_name, prog_name);	strcat(file_name, ".MPX");        /* try to open the file */	errcode = OK;        file_p = fopen(file_name, "rb");        if (file_p == NULL) return(ERR_SUP_FILNFD);	/* read the header, check for EXE signature */        num_read = fread( (void*) header, 1, HEADER_SIZE, file_p);        if (num_read != HEADER_SIZE) {		errcode = ERR_SUP_FILINV;	}        else if ((header[0] != 0x4D) || (header[1] != 0x5A)) {		errcode = ERR_SUP_FILINV;	}        /* close the file, then return if error occurred */        fclose(file_p);	if (errcode!=OK) return(errcode);        /* compute allocation size needed */        file_size = (header[5]*256 + header[4] -1) * 512		+ (header[3]*256 + header[2]);        header_size =(header[9]*256 + header[8])*16;        code_size = file_size - header_size;        data_size = (header[11]*256 + header[10])*16;        /* return total length and starting offset */        *prog_len_p = code_size + data_size;	*start_offset_p = (header[23]*256 + header[22]) * 16;	return(OK);}/*	Procedure: sys_load_program	Purpose: load a program file	Parameters: see prototype	Returns: error code; zero if OK	Calls:   intdosx		segread		strlen, strcat	Globals: none 	Errors:  ERR_SUP_NAMLNG    name too long		ERR_SUP_FILNFD    file not found	       ERR_SUP_FILINV      file invalid		ERR_SUP_PROGSZ    program too large	       ERR_SUP_LDADDR      address not aligned		ERR_SUP_LDFAIL    load failed*/int sys_load_program (     void*    load_addr,        /* address for loading */			int      max_size,         /* memory size */			char     dir_name[],       /* directory name */			char     prog_name[]       /* program name */		      ){	int errcode;      /* error code */        int prog_len;      /* program length */	int offset;       /* offset for starting */	word norm_seg;    /* normalized load address segment */        word norm_off;     /* normalized load address offset */        /* full pathname for file to be loaded */	char file_name[MAX_PATH_SIZE+1];        /* parameter block for MSDOS EXEC function */	struct {		word load_seg;    /* segment address for loading */	       word reloc_seg;     /* segment address for relocation */        }p_block;	union REGS inregs;            /* input register structure */	union REGS outregs;           /* output register structure */	struct SREGS segregs;         /* segment register structure */        /* check program, get length and offset */	errcode = sys_check_program(dir_name, prog_name,					&prog_len, &offset);        if (errcode < 0) return(errcode);        /* ensure that allocated memory is large enough */        if (max_size < prog_len) return(ERR_SUP_PROGSZ);        /* get normalized segment and offset, check alignment */	norm_seg = FP_SEG(load_addr);	norm_off = FP_OFF(load_addr);	norm_seg += norm_off / 16;        norm_off %= 16;	if (norm_off != 0) return(ERR_SUP_LDADDR);        /* ensure that path name is not too long */        if ((strlen(dir_name) + strlen(prog_name) + 5)		 > MAX_PATH_SIZE) return(ERR_SUP_NAMLNG);	/* construct path name */	file_name[0] = NULCH;	if (dir_name[0] != NULCH) {		strcat(file_name, dir_name);	        strcat(file_name, "\\");	}        strcat(file_name, prog_name);	strcat(file_name, ".MPX");        /* get current segment regs */	segread(&segregs);        /* setup function codes */	inregs.h.ah = 0x4B;        /* EXEC function */	inregs.h.al = 0x03;        /* load only */        /* setup parameter block and name pointers */        segregs.ds = FP_SEG(&file_name);	inregs.x.dx = FP_OFF(&file_name);        segregs.es = FP_SEG(&p_block);	inregs.x.bx = FP_OFF(&p_block);        /* setup load segment -- must be normalized */	p_block.load_seg = norm_seg;	p_block.reloc_seg = p_block.load_seg;        /* call the MS-DOS loader */	errcode = intdosx(&inregs,&outregs,&segregs);        errcode = errcode;        /* check for error */	if (outregs.x.cflag) return(ERR_SUP_LDFAIL);	/* load successful */	return(OK);}/* END OF FILE */num_entries1,0
/***********************************************************************	MPX: The MultiProgramming eXecutive	Project to Accompany	A Practical Approach to Operating Systems	Malcolm G. Lane & James D. Mooney	Copyright 1993, P.W.S. Kent Publishing Co., Boston, MA.		File Name: mpx_supt.c	Authors: J.J. Patnesky, A. Ghosal, M. Lane, J. Mooney	Version: 2.1b	Date: 01/31/08	Purpose: Support routines for MPX-PC		Modules: all	Environment:      IBM-PC (XT, AT or PS/2)			MS-DOS 3.3 or later			TURBO-C 3.0 or TURBO-C++ 1.0 or later	Compile using the LARGE MODEL and SS NOT equal to DS.	All addresses and pointers are "far", and	CS, DS and SS are independent.	Procedures in this file:		sys_init		sys_exit		sys_set_vec		sys_req		sys_alloc_mem		sys_free_mem		sys_get_date		sys_set_date		sys_open_dir		sys_get_entry		sys_close_dir	       sys_check_program	       sys_load_program************************************************************************Change Log:	07/16/88  akg	added comments	02/25/92  jdm	full revision, UNIX version	04/14/92  jdm	Macintosh version	05/15/92  jdm	cleanup and documentation	07/14/92  jdm	update for revised specs        08/13/92  jdm 	revised IBM version; added private heap        10/14/92  jdm 	added check and load procedures        10/18/92  jdm 	revised sys_alloc_mem for alignment	11/17/92  jdm	true heap mgt, aligned, using calloc & free	11/19/92  jdm	enable device handling for final module	12/31/92  jdm	revised sys_req parameters	01/02/93  jdm	return count value after I/O	01/03/93  jdm	revised error names and codes	01/27/93  jdm	corrected count for line input in sys_req			fixed open_dir to handle null lines	02/24/93  jdm	changed sys_set_vec param to interrupt	03/08/93  jdm	corrections to sys_check & sys_load	03/20/93  jdm	stack switch in free, check, and load	04/22/93  jdm	corrected index conflict in sys_free_mem			added safety escape in alloc table search	07/28/93  jdm	conversion to large model	09/01/93  jdm	fixed allocation bug;  made date private	09/14/93  jdm	cleaned up memory allocation        09/16/93  jdm	adjusted program load for large model        09/30/93  jdm	modified for correct list of root directory	11/01/94  jdm	changed load file read to binary	09/18/95  jdm	fixed get_entry to default to current, not root	01/31/08  jdm   fixed possible overflow problem in get_entry************************************************************************/#include "mpx_supt.h"#include <stdlib.h>#include <dos.h>#include <dir.h>#include <errno.h>#include <conio.h>#include <alloc.h>#define VEC_ADDR (0x60L*4)#define MAX_ALLOC 200#define MAX_XPOS 79#define MAX_YPOS 24#define MAX_PATH_SIZE 50/*	System-dependent type definitions*/typedef unsigned char byte;typedef unsigned int word;typedef unsigned long longword;typedef byte *address;typedef struct params {	int      op_code;	int      device_id;	char     *buf_p;	int      *count_p;	} params;/*	Global variables accessed only by support routines*/	static longword vec_save;  /* saved interrupt vector */	static int mod_code;                /* module code */                                           	static struct date sys_date;        /* MPX system date */	/* data structures for directory access */        static char current_path[MAX_PATH_SIZE+1];        static int num_entries;        static struct ffblk file_block;        /* handler presence flags */	static flag sysc_hand;	static flag trm_hand;	static flag prt_hand;	static flag com_hand;        /* memory allocation table */	static struct {		void* original;		void* aligned;	} alloc_table[MAX_ALLOC];	static int alloc_ix;                /* current index */	static int num_alloc;               /* no. of allocated blocks *//*	Procedure: sys_init	Purpose: initialize mpx	Parameters: see prototype  	Return value: error code, or OK if no error	Calls: getdate    	Globals: mod_code		vec_save		sys_date		alloc_table, alloc_ix, num_alloc		sysc_hand, term_hand, prt_hand, com_hand	Errors: none*/int sys_init (    int      modules  /* module code */	     ){	mod_code = modules;        vec_save = 0L;        /* no handlers detected yet */	sysc_hand = FALSE;	trm_hand = FALSE;	prt_hand = FALSE;	com_hand = FALSE;	/* initialize allocation table */	for (alloc_ix=0; alloc_ix < MAX_ALLOC; alloc_ix++) {		alloc_table[alloc_ix].original = NULL;		alloc_table[alloc_ix].aligned = NULL;	}	alloc_ix = 0;	num_alloc = 0;	/* if we have reached Module R3, enable system call handling */	if (modules >= MODULE_R3) sysc_hand = TRUE;	/* if we have reached the final module, enable device handlers */	if (modules >= MODULE_F) {		trm_hand = TRUE;		prt_hand = TRUE;		com_hand = TRUE;	}	/* get system date */        getdate(&sys_date);	return (OK);}/*	Procedure: sys_exit	Purpose: terminate mpx	Parameters: none  	Return value: none	Calls: none       	Globals: vec_save*/void sys_exit(void){	longword *vec_p;	/* if trap vector changed, restore it */	if (vec_save != 0L) {		vec_p = (longword*) VEC_ADDR;		*vec_p = vec_save;	}	/* return to host with null error code */	exit(0);}/*	Procedure: sys_set_vec	Purpose: link trap vector to MPX system call handler	Parameters: handler: addr of handler         	Return value: error code; OK if no error	Calls: none       	Globals: vec_save	Errors: none*/int sys_set_vec   ( void interrupt (*handler)() /* system call handler */		){	longword *vec_p;			vec_p = (longword*) VEC_ADDR;		vec_save = *vec_p;		*vec_p = (longword) handler;	return (0);}/*	Procedure: sys_req	Purpose: Request a system service	Inputs:		op_code           operation code		device_id         device identifier		buf_p             addresso f data buffer		count_p           address of size of buffer	Returns: Result or error code, depending on service		Services supported:	IDLE     null operation				READ     input from a device				WRITE    output to a device				CLEAR    clear terminal screen				GOTOXY   absolute cursor position				EXIT     terminate the caller	Calls:   fgets		strlen			Globals: none		Errors:  ERR_SUP_INVDEV    invalid device		ERR_SUP_INVOPC    invalid operation code		ERR_SUP_INVPOS    invalid character position		ERR_SUP_RDFAIL    read failed		ERR_SUP_WRFAIL    write failed	Description:	For Modules R1 through R4,	this procedure is used only for terminal I/O.	Later modules support both reading and	writing for several devices.	For Modules R1 through R4,	sys_req uses the ANSI C function "fgets."	Later modules may use alternate functions and device drivers.*/int sys_req (   int      op_code, /* operation code */		int      device_id,        /* device id */		char*    buf_p,            /* I/O buffer */		int*     count_p           /* address of count */		){	int      rval;    /* result or error code */	char     *rp;     /* return pointer for fgets */	char     rc;      /* return char for fputc */        params    *param_p; /* pointer to parameter record in stack */	flag     docall;  /* true if system call interrupt wanted */	int      ix;      /* temporary index */	docall = FALSE;	rval = OK;	switch (op_code) {		case IDLE:		if (sysc_hand) docall = TRUE;		break; 				case READ:		switch (device_id) {				case TERMINAL:			if (trm_hand) docall = TRUE;			else {				rp = fgets(buf_p,*count_p,stdin);				if (rp==NULL) rval = ERR_SUP_RDFAIL;				else rval = strlen(buf_p);			}			break;					case COM_PORT:			if (com_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					default:			rval = ERR_SUP_INVDEV;					}		break;	case WRITE:		switch (device_id) {				case TERMINAL:			if (trm_hand) docall = TRUE;			else {				rval = *count_p;				for (ix=0; ix<*count_p; ix++) {					rc = fputc(buf_p[ix],stdout);					if (rc == EOF) {						rval = ERR_SUP_WRFAIL;						break;					}				}			}			break;					case COM_PORT:			if (com_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					case PRINTER:			if (prt_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					default:			rval = ERR_SUP_INVDEV;					}		break;	case CLEAR:		if (device_id==TERMINAL) {			if (trm_hand) docall = TRUE;			else {			     clrscr();				rval = 0;			}		}		else rval = ERR_SUP_INVDEV;		break;			case GOTOXY:		if (device_id==TERMINAL) {			if (trm_hand) docall = TRUE;			else {				if (*count_p != 2) rval = ERR_SUP_WRFAIL;				else if ((*buf_p<0)					|| (*buf_p > MAX_XPOS))					rval = ERR_SUP_WRFAIL;				else if ((*(buf_p+1)<0)					|| (*(buf_p+1) > MAX_YPOS))					rval = ERR_SUP_WRFAIL;				else {					gotoxy(*buf_p + 1,						*(buf_p+1) + 1);					rval = 0;				}			}		}		else rval = ERR_SUP_INVDEV;		break;			/* EXIT - terminate the calling process */	/* legal only when a system call handler is present */	case EXIT:		if (sysc_hand) docall = TRUE;		else rval = ERR_SUP_INVOPC;		break; 	default:		rval = ERR_SUP_INVOPC;			}		/* Invoke user's call handler if present.	   If the call is an IO request, return will occur	   only after the request is complete.	*/	if (docall && (rval==OK)) {		/* invoke the call handler */	_SP = _SP - sizeof(params);		param_p = (params*) MK_FP(_SS,_SP);	       param_p->op_code = op_code;	       param_p->device_id = device_id;	       param_p->buf_p = buf_p;	       param_p->count_p = count_p;	       geninterrupt(0x60);	       rval = _AX;	       _SP = _SP + sizeof(params);		/* for I/O operations, return count value */		switch(op_code) {		case READ:		case WRITE:		case CLEAR:		case GOTOXY:			rval = *count_p;		}	}	return(rval);}/*	Procedure: sys_alloc_mem	Purpose: Allocate a memory block	Parameters:			size_t size       No. of bytes to allocate	Returns: void* pointer to allocated block;		 null pointer in case of error		 	Calls: calloc		Globals: alloc_table, alloc_ix, num_alloc	For program loading (Module R-4), the blocks must be aligned.	This is achieved by requesting one extra paragraph and	returning the lowest aligned address as the base.  It is	necessary to keep a table of allocated address, original and	aligned, to support correct freeing.	It would seem simpler to use the Turbo-C function allocmem,	which always allocates aligned blocks.  However, allocmem	appears to conflict with the internal allocation of fopen	and other C library routines.*/void *sys_alloc_mem (      size_t   size     /* size in bytes to allocate */		    ){	int ix_save;      /* temp copy of table index */        void *addr;        /* addr returned by calloc (*void) */	word offset;      /* offset of unaligned address */	word seg;         /* segment addr of unaligned address */	void *addr_alig; /* aligned address */	int rem; /* temp for alignment computation */	/* ensure that allocation table is not full */	if (num_alloc >= MAX_ALLOC) {		return(NULL);	}	/* find free entry in allocation table */	ix_save = alloc_ix;	while (alloc_table[alloc_ix].original != NULL) {		alloc_ix++;		if (alloc_ix >= MAX_ALLOC) alloc_ix = 0;		/* safety check -- should never happen! */		if (alloc_ix == ix_save) return(NULL);	}	/* call allocation routine */	/* request 15 extra bytes to ensure alignment is possible */	addr = calloc(size + 15,1);	/* compute aligned base */	offset = FP_OFF(addr);        seg = FP_SEG(addr);	rem = offset % 16;	if (rem > 0) offset = offset + 16 - rem;	addr_alig = MK_FP(seg,offset);	/* insert entries in table */	alloc_table[alloc_ix].original = addr;	alloc_table[alloc_ix].aligned = addr_alig;	/* increment count */	num_alloc++;	return(addr_alig);}/*	Procedure: sys_free_mem	Purpose: free a memory block	Parameters:		void *ptr         ptr to block to allocate	Returns: integer error code; zero if OK		Calls:   free	Globals: alloc_table, num_alloc	Errors:  ERR_SUP_INVMEM    invalid memory block	This procedure receives an aligned address; it must	find and free the corresponding non-aligned one.*/int sys_free_mem (         void     *ptr     /* pointer to block */		 ){	void *free_addr;  /* true (unaligned) block address */	int free_ix;               /* temp table index */	/* ensure valid pointer */	if (ptr==NULL) return(ERR_SUP_INVMEM);	/* Look for the block in the allocation table */	free_addr = NULL;	for (free_ix=0; free_ix<MAX_ALLOC; free_ix++) {		if (alloc_table[free_ix].aligned == ptr) {			free_addr = alloc_table[free_ix].original;			break;		}	}	/* If the block wasn't found, report error */	if (free_addr == NULL) return(ERR_SUP_INVMEM);	/* free the block & clear the table entry */	alloc_table[free_ix].original = NULL;	alloc_table[free_ix].aligned = NULL;        free(free_addr);	/* decrement count */	num_alloc--;	return(OK);}        /*	Procedure: sys_get_date	Purpose: Returns the system date (month, day, year)	Parameters:		date_rec *date_p Pointer to structure of type date	Returns: void		Calls: none		Globals: sys_date        Errors: none*/void sys_get_date (  date_rec*      date_p   /* ptr to date record */		){	date_p->month = sys_date.da_mon;	date_p->day = sys_date.da_day;	date_p->year = sys_date.da_year;}/*	Procedure: sys_set_date	Purpose: Sets the system date (month, day, year)	Parameters:		date_rec *date_p ptr to structure of type date	Returns: error code; OK if no error	Calls:   none        Globals: sys_date	Errors: none*/int sys_set_date (  date_rec*       date_p   /* ptr to date record */		 ){	sys_date.da_mon = date_p->month;        sys_date.da_day = date_p->day;        sys_date.da_year = date_p->year;	return(OK);}/*	Procedure: sys_open_dir	Purpose: open a specified directory	Parameters: char dir_name[]            directory name	Returns: error code; zero if OK	Calls:   findfirst		strncpy  	Globals: current_path, file_block, num_entries	Errors:  ERR_SUP_DIROPN    directory open error		ERR_SUP_INVDIR    invalid directory*/int sys_open_dir (  char  path_name[]        /* directory name */		 ){        char temp_path[MAX_PATH_SIZE];	int res;        int len;        /* ensure there is no directory currently open */	if (current_path[0]!=NULCH) return(ERR_SUP_DIROPN);        /* check pathname for validity */        /* construct temporary search path name */	temp_path[0] = NULCH;	if (path_name != NULL) {		strncpy(temp_path,path_name,MAX_PATH_SIZE-4);	}	/* build wildcard search string */        len = strlen(temp_path);	/* if path is null, use current directory */        if (len==0) strcpy(temp_path,"*.*");	/* handle paths ending in backslash, including root */        else if (temp_path[len-1]=='\\') strcat(temp_path,"*.*");	/* handle paths not ending in backslash */        else strcat(temp_path,"\\*.*");	/* validate the directory by searching for either an ordinary	   file or a directory in it.  This should never fail; even	   empty directories contain the directories "." and ".."	*/		res = findfirst(temp_path, &file_block, FA_DIREC);	if (res!=0)  return(ERR_SUP_INVDIR);        /* save pathname as current, clear entry count */	current_path[0] = NULCH;	if (path_name != NULL) {		strncpy(current_path,path_name,MAX_PATH_SIZE-6);	}	num_entries = 0;	return(OK);}/*	Procedure: sys_get_entry	Purpose: get the next directory entry;	Parameters: char name_buf[]	name buffer		    int buf_size  	buffer capacity		    long *file_size_p	file length buffer         	Returns: error code, or zero if ok	Calls:	findfirst		findnext		strncpy, strcpy, strrchr, strcat    	Globals: current_path, num_entries, file_block	Errors:  ERR_SUP_NOENTR    no such entry*/int sys_get_entry (char    name_buf[],       /* buffer for entry */		   int   buf_size,         /* buffer size */		   long* file_size_p       /* buffer for size value */		  ){	char filename[MAX_PATH_SIZE+1];	int err;        int len;        char *cp;        /* find next MPX file entry, if any */        /* if this is the first call */	if (num_entries==0) {	       /* construct complete search path name */	       len = strlen(current_path);	       if (len==0) strcpy(current_path,"*.MPX");	       else if (current_path[len-1]=='\\') strcat(current_path,"*.MPX");	       else strcat(current_path,"\\*.MPX");	       /* find first entry */		err = findfirst (current_path,&file_block,0);        }        /* otherwise, find next entry */        else err = findnext(&file_block);        if (err<0) return(ERR_SUP_NOENTR);		/* ensure buf_size is not too large */		if (buf_size > MAX_PATH_SIZE) buf_size = MAX_PATH_SIZE;		      /* copy filename to buffer */	filename[buf_size] = NULCH;	strncpy (filename,file_block.ff_name,			 (size_t) buf_size);	/* remove ".MPX" from name */	cp = strrchr(filename, (int) '.');        *cp = NULCH;	/* copy name and size to caller's buffer */        strcpy (name_buf,filename);	*file_size_p = file_block.ff_fsize;        /* count entry */	num_entries++;	return(OK);}/*	Procedure: sys_close_dir	Purpose: close an open directory	Parameters: none	Returns: error code; zero if OK	Calls:   none	Globals: current_path	Errors:  none*/int sys_close_dir (void){	current_path[0] = NULCH;	return(OK);}/*	Procedure: sys_check_program	Purpose: locate and measure a program file	Parameters: see prototype	Returns: program size or error code	Calls:   strlen, strcat		fopen, fread	Globals: none	Errors:  ERR_SUP_NAMLNG    pathname too long		ERR_SUP_FILNFD    file not found		ERR_SUP_FILINV    file invalid*/#define HEADER_SIZE 32int sys_check_program(     char     dir_name[],       /* directory name */			char     prog_name[],      /* program name */			int*     prog_len_p,       /* ptr to prog length */			int*     start_offset_p    /* ptr to start offset */			){        /* buffer for full pathname */	char file_name[MAX_PATH_SIZE+1];        /* buffer for file header */        byte header[HEADER_SIZE];	FILE *file_p;     /* file pointer for C file routines */        int num_read;      /* number of header bytes read */	int file_size;    /* size of complete file */        int header_size;/* size of header */        int code_size;     /* size of program code */        int data_size;     /* size of program data */        int errcode;       /* error code */        /* ensure that path name is not too long */        if ((strlen(dir_name) + strlen(prog_name) + 5)		 > MAX_PATH_SIZE) return(ERR_SUP_NAMLNG);	/* construct path name */	file_name[0] = NULCH;	if (dir_name[0] != NULCH) {		strcat(file_name, dir_name);	        strcat(file_name, "\\");	}        strcat(file_name, prog_name);	strcat(file_name, ".MPX");        /* try to open the file */	errcode = OK;        file_p = fopen(file_name, "rb");        if (file_p == NULL) return(ERR_SUP_FILNFD);	/* read the header, check for EXE signature */        num_read = fread( (void*) header, 1, HEADER_SIZE, file_p);        if (num_read != HEADER_SIZE) {		errcode = ERR_SUP_FILINV;	}        else if ((header[0] != 0x4D) || (header[1] != 0x5A)) {		errcode = ERR_SUP_FILINV;	}        /* close the file, then return if error occurred */        fclose(file_p);	if (errcode!=OK) return(errcode);        /* compute allocation size needed */        file_size = (header[5]*256 + header[4] -1) * 512		+ (header[3]*256 + header[2]);        header_size =(header[9]*256 + header[8])*16;        code_size = file_size - header_size;        data_size = (header[11]*256 + header[10])*16;        /* return total length and starting offset */        *prog_len_p = code_size + data_size;	*start_offset_p = (header[23]*256 + header[22]) * 16;	return(OK);}/*	Procedure: sys_load_program	Purpose: load a program file	Parameters: see prototype	Returns: error code; zero if OK	Calls:   intdosx		segread		strlen, strcat	Globals: none 	Errors:  ERR_SUP_NAMLNG    name too long		ERR_SUP_FILNFD    file not found	       ERR_SUP_FILINV      file invalid		ERR_SUP_PROGSZ    program too large	       ERR_SUP_LDADDR      address not aligned		ERR_SUP_LDFAIL    load failed*/int sys_load_program (     void*    load_addr,        /* address for loading */			int      max_size,         /* memory size */			char     dir_name[],       /* directory name */			char     prog_name[]       /* program name */		      ){	int errcode;      /* error code */        int prog_len;      /* program length */	int offset;       /* offset for starting */	word norm_seg;    /* normalized load address segment */        word norm_off;     /* normalized load address offset */        /* full pathname for file to be loaded */	char file_name[MAX_PATH_SIZE+1];        /* parameter block for MSDOS EXEC function */	struct {		word load_seg;    /* segment address for loading */	       word reloc_seg;     /* segment address for relocation */        }p_block;	union REGS inregs;            /* input register structure */	union REGS outregs;           /* output register structure */	struct SREGS segregs;         /* segment register structure */        /* check program, get length and offset */	errcode = sys_check_program(dir_name, prog_name,					&prog_len, &offset);        if (errcode < 0) return(errcode);        /* ensure that allocated memory is large enough */        if (max_size < prog_len) return(ERR_SUP_PROGSZ);        /* get normalized segment and offset, check alignment */	norm_seg = FP_SEG(load_addr);	norm_off = FP_OFF(load_addr);	norm_seg += norm_off / 16;        norm_off %= 16;	if (norm_off != 0) return(ERR_SUP_LDADDR);        /* ensure that path name is not too long */        if ((strlen(dir_name) + strlen(prog_name) + 5)		 > MAX_PATH_SIZE) return(ERR_SUP_NAMLNG);	/* construct path name */	file_name[0] = NULCH;	if (dir_name[0] != NULCH) {		strcat(file_name, dir_name);	        strcat(file_name, "\\");	}        strcat(file_name, prog_name);	strcat(file_name, ".MPX");        /* get current segment regs */	segread(&segregs);        /* setup function codes */	inregs.h.ah = 0x4B;        /* EXEC function */	inregs.h.al = 0x03;        /* load only */        /* setup parameter block and name pointers */        segregs.ds = FP_SEG(&file_name);	inregs.x.dx = FP_OFF(&file_name);        segregs.es = FP_SEG(&p_block);	inregs.x.bx = FP_OFF(&p_block);        /* setup load segment -- must be normalized */	p_block.load_seg = norm_seg;	p_block.reloc_seg = p_block.load_seg;        /* call the MS-DOS loader */	errcode = intdosx(&inregs,&outregs,&segregs);        errcode = errcode;        /* check for error */	if (outregs.x.cflag) return(ERR_SUP_LDFAIL);	/* load successful */	return(OK);}/* END OF FILE */file_block1,0
/***********************************************************************	MPX: The MultiProgramming eXecutive	Project to Accompany	A Practical Approach to Operating Systems	Malcolm G. Lane & James D. Mooney	Copyright 1993, P.W.S. Kent Publishing Co., Boston, MA.		File Name: mpx_supt.c	Authors: J.J. Patnesky, A. Ghosal, M. Lane, J. Mooney	Version: 2.1b	Date: 01/31/08	Purpose: Support routines for MPX-PC		Modules: all	Environment:      IBM-PC (XT, AT or PS/2)			MS-DOS 3.3 or later			TURBO-C 3.0 or TURBO-C++ 1.0 or later	Compile using the LARGE MODEL and SS NOT equal to DS.	All addresses and pointers are "far", and	CS, DS and SS are independent.	Procedures in this file:		sys_init		sys_exit		sys_set_vec		sys_req		sys_alloc_mem		sys_free_mem		sys_get_date		sys_set_date		sys_open_dir		sys_get_entry		sys_close_dir	       sys_check_program	       sys_load_program************************************************************************Change Log:	07/16/88  akg	added comments	02/25/92  jdm	full revision, UNIX version	04/14/92  jdm	Macintosh version	05/15/92  jdm	cleanup and documentation	07/14/92  jdm	update for revised specs        08/13/92  jdm 	revised IBM version; added private heap        10/14/92  jdm 	added check and load procedures        10/18/92  jdm 	revised sys_alloc_mem for alignment	11/17/92  jdm	true heap mgt, aligned, using calloc & free	11/19/92  jdm	enable device handling for final module	12/31/92  jdm	revised sys_req parameters	01/02/93  jdm	return count value after I/O	01/03/93  jdm	revised error names and codes	01/27/93  jdm	corrected count for line input in sys_req			fixed open_dir to handle null lines	02/24/93  jdm	changed sys_set_vec param to interrupt	03/08/93  jdm	corrections to sys_check & sys_load	03/20/93  jdm	stack switch in free, check, and load	04/22/93  jdm	corrected index conflict in sys_free_mem			added safety escape in alloc table search	07/28/93  jdm	conversion to large model	09/01/93  jdm	fixed allocation bug;  made date private	09/14/93  jdm	cleaned up memory allocation        09/16/93  jdm	adjusted program load for large model        09/30/93  jdm	modified for correct list of root directory	11/01/94  jdm	changed load file read to binary	09/18/95  jdm	fixed get_entry to default to current, not root	01/31/08  jdm   fixed possible overflow problem in get_entry************************************************************************/#include "mpx_supt.h"#include <stdlib.h>#include <dos.h>#include <dir.h>#include <errno.h>#include <conio.h>#include <alloc.h>#define VEC_ADDR (0x60L*4)#define MAX_ALLOC 200#define MAX_XPOS 79#define MAX_YPOS 24#define MAX_PATH_SIZE 50/*	System-dependent type definitions*/typedef unsigned char byte;typedef unsigned int word;typedef unsigned long longword;typedef byte *address;typedef struct params {	int      op_code;	int      device_id;	char     *buf_p;	int      *count_p;	} params;/*	Global variables accessed only by support routines*/	static longword vec_save;  /* saved interrupt vector */	static int mod_code;                /* module code */                                           	static struct date sys_date;        /* MPX system date */	/* data structures for directory access */        static char current_path[MAX_PATH_SIZE+1];        static int num_entries;        static struct ffblk file_block;        /* handler presence flags */	static flag sysc_hand;	static flag trm_hand;	static flag prt_hand;	static flag com_hand;        /* memory allocation table */	static struct {		void* original;		void* aligned;	} alloc_table[MAX_ALLOC];	static int alloc_ix;                /* current index */	static int num_alloc;               /* no. of allocated blocks *//*	Procedure: sys_init	Purpose: initialize mpx	Parameters: see prototype  	Return value: error code, or OK if no error	Calls: getdate    	Globals: mod_code		vec_save		sys_date		alloc_table, alloc_ix, num_alloc		sysc_hand, term_hand, prt_hand, com_hand	Errors: none*/int sys_init (    int      modules  /* module code */	     ){	mod_code = modules;        vec_save = 0L;        /* no handlers detected yet */	sysc_hand = FALSE;	trm_hand = FALSE;	prt_hand = FALSE;	com_hand = FALSE;	/* initialize allocation table */	for (alloc_ix=0; alloc_ix < MAX_ALLOC; alloc_ix++) {		alloc_table[alloc_ix].original = NULL;		alloc_table[alloc_ix].aligned = NULL;	}	alloc_ix = 0;	num_alloc = 0;	/* if we have reached Module R3, enable system call handling */	if (modules >= MODULE_R3) sysc_hand = TRUE;	/* if we have reached the final module, enable device handlers */	if (modules >= MODULE_F) {		trm_hand = TRUE;		prt_hand = TRUE;		com_hand = TRUE;	}	/* get system date */        getdate(&sys_date);	return (OK);}/*	Procedure: sys_exit	Purpose: terminate mpx	Parameters: none  	Return value: none	Calls: none       	Globals: vec_save*/void sys_exit(void){	longword *vec_p;	/* if trap vector changed, restore it */	if (vec_save != 0L) {		vec_p = (longword*) VEC_ADDR;		*vec_p = vec_save;	}	/* return to host with null error code */	exit(0);}/*	Procedure: sys_set_vec	Purpose: link trap vector to MPX system call handler	Parameters: handler: addr of handler         	Return value: error code; OK if no error	Calls: none       	Globals: vec_save	Errors: none*/int sys_set_vec   ( void interrupt (*handler)() /* system call handler */		){	longword *vec_p;			vec_p = (longword*) VEC_ADDR;		vec_save = *vec_p;		*vec_p = (longword) handler;	return (0);}/*	Procedure: sys_req	Purpose: Request a system service	Inputs:		op_code           operation code		device_id         device identifier		buf_p             addresso f data buffer		count_p           address of size of buffer	Returns: Result or error code, depending on service		Services supported:	IDLE     null operation				READ     input from a device				WRITE    output to a device				CLEAR    clear terminal screen				GOTOXY   absolute cursor position				EXIT     terminate the caller	Calls:   fgets		strlen			Globals: none		Errors:  ERR_SUP_INVDEV    invalid device		ERR_SUP_INVOPC    invalid operation code		ERR_SUP_INVPOS    invalid character position		ERR_SUP_RDFAIL    read failed		ERR_SUP_WRFAIL    write failed	Description:	For Modules R1 through R4,	this procedure is used only for terminal I/O.	Later modules support both reading and	writing for several devices.	For Modules R1 through R4,	sys_req uses the ANSI C function "fgets."	Later modules may use alternate functions and device drivers.*/int sys_req (   int      op_code, /* operation code */		int      device_id,        /* device id */		char*    buf_p,            /* I/O buffer */		int*     count_p           /* address of count */		){	int      rval;    /* result or error code */	char     *rp;     /* return pointer for fgets */	char     rc;      /* return char for fputc */        params    *param_p; /* pointer to parameter record in stack */	flag     docall;  /* true if system call interrupt wanted */	int      ix;      /* temporary index */	docall = FALSE;	rval = OK;	switch (op_code) {		case IDLE:		if (sysc_hand) docall = TRUE;		break; 				case READ:		switch (device_id) {				case TERMINAL:			if (trm_hand) docall = TRUE;			else {				rp = fgets(buf_p,*count_p,stdin);				if (rp==NULL) rval = ERR_SUP_RDFAIL;				else rval = strlen(buf_p);			}			break;					case COM_PORT:			if (com_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					default:			rval = ERR_SUP_INVDEV;					}		break;	case WRITE:		switch (device_id) {				case TERMINAL:			if (trm_hand) docall = TRUE;			else {				rval = *count_p;				for (ix=0; ix<*count_p; ix++) {					rc = fputc(buf_p[ix],stdout);					if (rc == EOF) {						rval = ERR_SUP_WRFAIL;						break;					}				}			}			break;					case COM_PORT:			if (com_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					case PRINTER:			if (prt_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					default:			rval = ERR_SUP_INVDEV;					}		break;	case CLEAR:		if (device_id==TERMINAL) {			if (trm_hand) docall = TRUE;			else {			     clrscr();				rval = 0;			}		}		else rval = ERR_SUP_INVDEV;		break;			case GOTOXY:		if (device_id==TERMINAL) {			if (trm_hand) docall = TRUE;			else {				if (*count_p != 2) rval = ERR_SUP_WRFAIL;				else if ((*buf_p<0)					|| (*buf_p > MAX_XPOS))					rval = ERR_SUP_WRFAIL;				else if ((*(buf_p+1)<0)					|| (*(buf_p+1) > MAX_YPOS))					rval = ERR_SUP_WRFAIL;				else {					gotoxy(*buf_p + 1,						*(buf_p+1) + 1);					rval = 0;				}			}		}		else rval = ERR_SUP_INVDEV;		break;			/* EXIT - terminate the calling process */	/* legal only when a system call handler is present */	case EXIT:		if (sysc_hand) docall = TRUE;		else rval = ERR_SUP_INVOPC;		break; 	default:		rval = ERR_SUP_INVOPC;			}		/* Invoke user's call handler if present.	   If the call is an IO request, return will occur	   only after the request is complete.	*/	if (docall && (rval==OK)) {		/* invoke the call handler */	_SP = _SP - sizeof(params);		param_p = (params*) MK_FP(_SS,_SP);	       param_p->op_code = op_code;	       param_p->device_id = device_id;	       param_p->buf_p = buf_p;	       param_p->count_p = count_p;	       geninterrupt(0x60);	       rval = _AX;	       _SP = _SP + sizeof(params);		/* for I/O operations, return count value */		switch(op_code) {		case READ:		case WRITE:		case CLEAR:		case GOTOXY:			rval = *count_p;		}	}	return(rval);}/*	Procedure: sys_alloc_mem	Purpose: Allocate a memory block	Parameters:			size_t size       No. of bytes to allocate	Returns: void* pointer to allocated block;		 null pointer in case of error		 	Calls: calloc		Globals: alloc_table, alloc_ix, num_alloc	For program loading (Module R-4), the blocks must be aligned.	This is achieved by requesting one extra paragraph and	returning the lowest aligned address as the base.  It is	necessary to keep a table of allocated address, original and	aligned, to support correct freeing.	It would seem simpler to use the Turbo-C function allocmem,	which always allocates aligned blocks.  However, allocmem	appears to conflict with the internal allocation of fopen	and other C library routines.*/void *sys_alloc_mem (      size_t   size     /* size in bytes to allocate */		    ){	int ix_save;      /* temp copy of table index */        void *addr;        /* addr returned by calloc (*void) */	word offset;      /* offset of unaligned address */	word seg;         /* segment addr of unaligned address */	void *addr_alig; /* aligned address */	int rem; /* temp for alignment computation */	/* ensure that allocation table is not full */	if (num_alloc >= MAX_ALLOC) {		return(NULL);	}	/* find free entry in allocation table */	ix_save = alloc_ix;	while (alloc_table[alloc_ix].original != NULL) {		alloc_ix++;		if (alloc_ix >= MAX_ALLOC) alloc_ix = 0;		/* safety check -- should never happen! */		if (alloc_ix == ix_save) return(NULL);	}	/* call allocation routine */	/* request 15 extra bytes to ensure alignment is possible */	addr = calloc(size + 15,1);	/* compute aligned base */	offset = FP_OFF(addr);        seg = FP_SEG(addr);	rem = offset % 16;	if (rem > 0) offset = offset + 16 - rem;	addr_alig = MK_FP(seg,offset);	/* insert entries in table */	alloc_table[alloc_ix].original = addr;	alloc_table[alloc_ix].aligned = addr_alig;	/* increment count */	num_alloc++;	return(addr_alig);}/*	Procedure: sys_free_mem	Purpose: free a memory block	Parameters:		void *ptr         ptr to block to allocate	Returns: integer error code; zero if OK		Calls:   free	Globals: alloc_table, num_alloc	Errors:  ERR_SUP_INVMEM    invalid memory block	This procedure receives an aligned address; it must	find and free the corresponding non-aligned one.*/int sys_free_mem (         void     *ptr     /* pointer to block */		 ){	void *free_addr;  /* true (unaligned) block address */	int free_ix;               /* temp table index */	/* ensure valid pointer */	if (ptr==NULL) return(ERR_SUP_INVMEM);	/* Look for the block in the allocation table */	free_addr = NULL;	for (free_ix=0; free_ix<MAX_ALLOC; free_ix++) {		if (alloc_table[free_ix].aligned == ptr) {			free_addr = alloc_table[free_ix].original;			break;		}	}	/* If the block wasn't found, report error */	if (free_addr == NULL) return(ERR_SUP_INVMEM);	/* free the block & clear the table entry */	alloc_table[free_ix].original = NULL;	alloc_table[free_ix].aligned = NULL;        free(free_addr);	/* decrement count */	num_alloc--;	return(OK);}        /*	Procedure: sys_get_date	Purpose: Returns the system date (month, day, year)	Parameters:		date_rec *date_p Pointer to structure of type date	Returns: void		Calls: none		Globals: sys_date        Errors: none*/void sys_get_date (  date_rec*      date_p   /* ptr to date record */		){	date_p->month = sys_date.da_mon;	date_p->day = sys_date.da_day;	date_p->year = sys_date.da_year;}/*	Procedure: sys_set_date	Purpose: Sets the system date (month, day, year)	Parameters:		date_rec *date_p ptr to structure of type date	Returns: error code; OK if no error	Calls:   none        Globals: sys_date	Errors: none*/int sys_set_date (  date_rec*       date_p   /* ptr to date record */		 ){	sys_date.da_mon = date_p->month;        sys_date.da_day = date_p->day;        sys_date.da_year = date_p->year;	return(OK);}/*	Procedure: sys_open_dir	Purpose: open a specified directory	Parameters: char dir_name[]            directory name	Returns: error code; zero if OK	Calls:   findfirst		strncpy  	Globals: current_path, file_block, num_entries	Errors:  ERR_SUP_DIROPN    directory open error		ERR_SUP_INVDIR    invalid directory*/int sys_open_dir (  char  path_name[]        /* directory name */		 ){        char temp_path[MAX_PATH_SIZE];	int res;        int len;        /* ensure there is no directory currently open */	if (current_path[0]!=NULCH) return(ERR_SUP_DIROPN);        /* check pathname for validity */        /* construct temporary search path name */	temp_path[0] = NULCH;	if (path_name != NULL) {		strncpy(temp_path,path_name,MAX_PATH_SIZE-4);	}	/* build wildcard search string */        len = strlen(temp_path);	/* if path is null, use current directory */        if (len==0) strcpy(temp_path,"*.*");	/* handle paths ending in backslash, including root */        else if (temp_path[len-1]=='\\') strcat(temp_path,"*.*");	/* handle paths not ending in backslash */        else strcat(temp_path,"\\*.*");	/* validate the directory by searching for either an ordinary	   file or a directory in it.  This should never fail; even	   empty directories contain the directories "." and ".."	*/		res = findfirst(temp_path, &file_block, FA_DIREC);	if (res!=0)  return(ERR_SUP_INVDIR);        /* save pathname as current, clear entry count */	current_path[0] = NULCH;	if (path_name != NULL) {		strncpy(current_path,path_name,MAX_PATH_SIZE-6);	}	num_entries = 0;	return(OK);}/*	Procedure: sys_get_entry	Purpose: get the next directory entry;	Parameters: char name_buf[]	name buffer		    int buf_size  	buffer capacity		    long *file_size_p	file length buffer         	Returns: error code, or zero if ok	Calls:	findfirst		findnext		strncpy, strcpy, strrchr, strcat    	Globals: current_path, num_entries, file_block	Errors:  ERR_SUP_NOENTR    no such entry*/int sys_get_entry (char    name_buf[],       /* buffer for entry */		   int   buf_size,         /* buffer size */		   long* file_size_p       /* buffer for size value */		  ){	char filename[MAX_PATH_SIZE+1];	int err;        int len;        char *cp;        /* find next MPX file entry, if any */        /* if this is the first call */	if (num_entries==0) {	       /* construct complete search path name */	       len = strlen(current_path);	       if (len==0) strcpy(current_path,"*.MPX");	       else if (current_path[len-1]=='\\') strcat(current_path,"*.MPX");	       else strcat(current_path,"\\*.MPX");	       /* find first entry */		err = findfirst (current_path,&file_block,0);        }        /* otherwise, find next entry */        else err = findnext(&file_block);        if (err<0) return(ERR_SUP_NOENTR);		/* ensure buf_size is not too large */		if (buf_size > MAX_PATH_SIZE) buf_size = MAX_PATH_SIZE;		      /* copy filename to buffer */	filename[buf_size] = NULCH;	strncpy (filename,file_block.ff_name,			 (size_t) buf_size);	/* remove ".MPX" from name */	cp = strrchr(filename, (int) '.');        *cp = NULCH;	/* copy name and size to caller's buffer */        strcpy (name_buf,filename);	*file_size_p = file_block.ff_fsize;        /* count entry */	num_entries++;	return(OK);}/*	Procedure: sys_close_dir	Purpose: close an open directory	Parameters: none	Returns: error code; zero if OK	Calls:   none	Globals: current_path	Errors:  none*/int sys_close_dir (void){	current_path[0] = NULCH;	return(OK);}/*	Procedure: sys_check_program	Purpose: locate and measure a program file	Parameters: see prototype	Returns: program size or error code	Calls:   strlen, strcat		fopen, fread	Globals: none	Errors:  ERR_SUP_NAMLNG    pathname too long		ERR_SUP_FILNFD    file not found		ERR_SUP_FILINV    file invalid*/#define HEADER_SIZE 32int sys_check_program(     char     dir_name[],       /* directory name */			char     prog_name[],      /* program name */			int*     prog_len_p,       /* ptr to prog length */			int*     start_offset_p    /* ptr to start offset */			){        /* buffer for full pathname */	char file_name[MAX_PATH_SIZE+1];        /* buffer for file header */        byte header[HEADER_SIZE];	FILE *file_p;     /* file pointer for C file routines */        int num_read;      /* number of header bytes read */	int file_size;    /* size of complete file */        int header_size;/* size of header */        int code_size;     /* size of program code */        int data_size;     /* size of program data */        int errcode;       /* error code */        /* ensure that path name is not too long */        if ((strlen(dir_name) + strlen(prog_name) + 5)		 > MAX_PATH_SIZE) return(ERR_SUP_NAMLNG);	/* construct path name */	file_name[0] = NULCH;	if (dir_name[0] != NULCH) {		strcat(file_name, dir_name);	        strcat(file_name, "\\");	}        strcat(file_name, prog_name);	strcat(file_name, ".MPX");        /* try to open the file */	errcode = OK;        file_p = fopen(file_name, "rb");        if (file_p == NULL) return(ERR_SUP_FILNFD);	/* read the header, check for EXE signature */        num_read = fread( (void*) header, 1, HEADER_SIZE, file_p);        if (num_read != HEADER_SIZE) {		errcode = ERR_SUP_FILINV;	}        else if ((header[0] != 0x4D) || (header[1] != 0x5A)) {		errcode = ERR_SUP_FILINV;	}        /* close the file, then return if error occurred */        fclose(file_p);	if (errcode!=OK) return(errcode);        /* compute allocation size needed */        file_size = (header[5]*256 + header[4] -1) * 512		+ (header[3]*256 + header[2]);        header_size =(header[9]*256 + header[8])*16;        code_size = file_size - header_size;        data_size = (header[11]*256 + header[10])*16;        /* return total length and starting offset */        *prog_len_p = code_size + data_size;	*start_offset_p = (header[23]*256 + header[22]) * 16;	return(OK);}/*	Procedure: sys_load_program	Purpose: load a program file	Parameters: see prototype	Returns: error code; zero if OK	Calls:   intdosx		segread		strlen, strcat	Globals: none 	Errors:  ERR_SUP_NAMLNG    name too long		ERR_SUP_FILNFD    file not found	       ERR_SUP_FILINV      file invalid		ERR_SUP_PROGSZ    program too large	       ERR_SUP_LDADDR      address not aligned		ERR_SUP_LDFAIL    load failed*/int sys_load_program (     void*    load_addr,        /* address for loading */			int      max_size,         /* memory size */			char     dir_name[],       /* directory name */			char     prog_name[]       /* program name */		      ){	int errcode;      /* error code */        int prog_len;      /* program length */	int offset;       /* offset for starting */	word norm_seg;    /* normalized load address segment */        word norm_off;     /* normalized load address offset */        /* full pathname for file to be loaded */	char file_name[MAX_PATH_SIZE+1];        /* parameter block for MSDOS EXEC function */	struct {		word load_seg;    /* segment address for loading */	       word reloc_seg;     /* segment address for relocation */        }p_block;	union REGS inregs;            /* input register structure */	union REGS outregs;           /* output register structure */	struct SREGS segregs;         /* segment register structure */        /* check program, get length and offset */	errcode = sys_check_program(dir_name, prog_name,					&prog_len, &offset);        if (errcode < 0) return(errcode);        /* ensure that allocated memory is large enough */        if (max_size < prog_len) return(ERR_SUP_PROGSZ);        /* get normalized segment and offset, check alignment */	norm_seg = FP_SEG(load_addr);	norm_off = FP_OFF(load_addr);	norm_seg += norm_off / 16;        norm_off %= 16;	if (norm_off != 0) return(ERR_SUP_LDADDR);        /* ensure that path name is not too long */        if ((strlen(dir_name) + strlen(prog_name) + 5)		 > MAX_PATH_SIZE) return(ERR_SUP_NAMLNG);	/* construct path name */	file_name[0] = NULCH;	if (dir_name[0] != NULCH) {		strcat(file_name, dir_name);	        strcat(file_name, "\\");	}        strcat(file_name, prog_name);	strcat(file_name, ".MPX");        /* get current segment regs */	segread(&segregs);        /* setup function codes */	inregs.h.ah = 0x4B;        /* EXEC function */	inregs.h.al = 0x03;        /* load only */        /* setup parameter block and name pointers */        segregs.ds = FP_SEG(&file_name);	inregs.x.dx = FP_OFF(&file_name);        segregs.es = FP_SEG(&p_block);	inregs.x.bx = FP_OFF(&p_block);        /* setup load segment -- must be normalized */	p_block.load_seg = norm_seg;	p_block.reloc_seg = p_block.load_seg;        /* call the MS-DOS loader */	errcode = intdosx(&inregs,&outregs,&segregs);        errcode = errcode;        /* check for error */	if (outregs.x.cflag) return(ERR_SUP_LDFAIL);	/* load successful */	return(OK);}/* END OF FILE */sysc_hand1,0
/***********************************************************************	MPX: The MultiProgramming eXecutive	Project to Accompany	A Practical Approach to Operating Systems	Malcolm G. Lane & James D. Mooney	Copyright 1993, P.W.S. Kent Publishing Co., Boston, MA.		File Name: mpx_supt.c	Authors: J.J. Patnesky, A. Ghosal, M. Lane, J. Mooney	Version: 2.1b	Date: 01/31/08	Purpose: Support routines for MPX-PC		Modules: all	Environment:      IBM-PC (XT, AT or PS/2)			MS-DOS 3.3 or later			TURBO-C 3.0 or TURBO-C++ 1.0 or later	Compile using the LARGE MODEL and SS NOT equal to DS.	All addresses and pointers are "far", and	CS, DS and SS are independent.	Procedures in this file:		sys_init		sys_exit		sys_set_vec		sys_req		sys_alloc_mem		sys_free_mem		sys_get_date		sys_set_date		sys_open_dir		sys_get_entry		sys_close_dir	       sys_check_program	       sys_load_program************************************************************************Change Log:	07/16/88  akg	added comments	02/25/92  jdm	full revision, UNIX version	04/14/92  jdm	Macintosh version	05/15/92  jdm	cleanup and documentation	07/14/92  jdm	update for revised specs        08/13/92  jdm 	revised IBM version; added private heap        10/14/92  jdm 	added check and load procedures        10/18/92  jdm 	revised sys_alloc_mem for alignment	11/17/92  jdm	true heap mgt, aligned, using calloc & free	11/19/92  jdm	enable device handling for final module	12/31/92  jdm	revised sys_req parameters	01/02/93  jdm	return count value after I/O	01/03/93  jdm	revised error names and codes	01/27/93  jdm	corrected count for line input in sys_req			fixed open_dir to handle null lines	02/24/93  jdm	changed sys_set_vec param to interrupt	03/08/93  jdm	corrections to sys_check & sys_load	03/20/93  jdm	stack switch in free, check, and load	04/22/93  jdm	corrected index conflict in sys_free_mem			added safety escape in alloc table search	07/28/93  jdm	conversion to large model	09/01/93  jdm	fixed allocation bug;  made date private	09/14/93  jdm	cleaned up memory allocation        09/16/93  jdm	adjusted program load for large model        09/30/93  jdm	modified for correct list of root directory	11/01/94  jdm	changed load file read to binary	09/18/95  jdm	fixed get_entry to default to current, not root	01/31/08  jdm   fixed possible overflow problem in get_entry************************************************************************/#include "mpx_supt.h"#include <stdlib.h>#include <dos.h>#include <dir.h>#include <errno.h>#include <conio.h>#include <alloc.h>#define VEC_ADDR (0x60L*4)#define MAX_ALLOC 200#define MAX_XPOS 79#define MAX_YPOS 24#define MAX_PATH_SIZE 50/*	System-dependent type definitions*/typedef unsigned char byte;typedef unsigned int word;typedef unsigned long longword;typedef byte *address;typedef struct params {	int      op_code;	int      device_id;	char     *buf_p;	int      *count_p;	} params;/*	Global variables accessed only by support routines*/	static longword vec_save;  /* saved interrupt vector */	static int mod_code;                /* module code */                                           	static struct date sys_date;        /* MPX system date */	/* data structures for directory access */        static char current_path[MAX_PATH_SIZE+1];        static int num_entries;        static struct ffblk file_block;        /* handler presence flags */	static flag sysc_hand;	static flag trm_hand;	static flag prt_hand;	static flag com_hand;        /* memory allocation table */	static struct {		void* original;		void* aligned;	} alloc_table[MAX_ALLOC];	static int alloc_ix;                /* current index */	static int num_alloc;               /* no. of allocated blocks *//*	Procedure: sys_init	Purpose: initialize mpx	Parameters: see prototype  	Return value: error code, or OK if no error	Calls: getdate    	Globals: mod_code		vec_save		sys_date		alloc_table, alloc_ix, num_alloc		sysc_hand, term_hand, prt_hand, com_hand	Errors: none*/int sys_init (    int      modules  /* module code */	     ){	mod_code = modules;        vec_save = 0L;        /* no handlers detected yet */	sysc_hand = FALSE;	trm_hand = FALSE;	prt_hand = FALSE;	com_hand = FALSE;	/* initialize allocation table */	for (alloc_ix=0; alloc_ix < MAX_ALLOC; alloc_ix++) {		alloc_table[alloc_ix].original = NULL;		alloc_table[alloc_ix].aligned = NULL;	}	alloc_ix = 0;	num_alloc = 0;	/* if we have reached Module R3, enable system call handling */	if (modules >= MODULE_R3) sysc_hand = TRUE;	/* if we have reached the final module, enable device handlers */	if (modules >= MODULE_F) {		trm_hand = TRUE;		prt_hand = TRUE;		com_hand = TRUE;	}	/* get system date */        getdate(&sys_date);	return (OK);}/*	Procedure: sys_exit	Purpose: terminate mpx	Parameters: none  	Return value: none	Calls: none       	Globals: vec_save*/void sys_exit(void){	longword *vec_p;	/* if trap vector changed, restore it */	if (vec_save != 0L) {		vec_p = (longword*) VEC_ADDR;		*vec_p = vec_save;	}	/* return to host with null error code */	exit(0);}/*	Procedure: sys_set_vec	Purpose: link trap vector to MPX system call handler	Parameters: handler: addr of handler         	Return value: error code; OK if no error	Calls: none       	Globals: vec_save	Errors: none*/int sys_set_vec   ( void interrupt (*handler)() /* system call handler */		){	longword *vec_p;			vec_p = (longword*) VEC_ADDR;		vec_save = *vec_p;		*vec_p = (longword) handler;	return (0);}/*	Procedure: sys_req	Purpose: Request a system service	Inputs:		op_code           operation code		device_id         device identifier		buf_p             addresso f data buffer		count_p           address of size of buffer	Returns: Result or error code, depending on service		Services supported:	IDLE     null operation				READ     input from a device				WRITE    output to a device				CLEAR    clear terminal screen				GOTOXY   absolute cursor position				EXIT     terminate the caller	Calls:   fgets		strlen			Globals: none		Errors:  ERR_SUP_INVDEV    invalid device		ERR_SUP_INVOPC    invalid operation code		ERR_SUP_INVPOS    invalid character position		ERR_SUP_RDFAIL    read failed		ERR_SUP_WRFAIL    write failed	Description:	For Modules R1 through R4,	this procedure is used only for terminal I/O.	Later modules support both reading and	writing for several devices.	For Modules R1 through R4,	sys_req uses the ANSI C function "fgets."	Later modules may use alternate functions and device drivers.*/int sys_req (   int      op_code, /* operation code */		int      device_id,        /* device id */		char*    buf_p,            /* I/O buffer */		int*     count_p           /* address of count */		){	int      rval;    /* result or error code */	char     *rp;     /* return pointer for fgets */	char     rc;      /* return char for fputc */        params    *param_p; /* pointer to parameter record in stack */	flag     docall;  /* true if system call interrupt wanted */	int      ix;      /* temporary index */	docall = FALSE;	rval = OK;	switch (op_code) {		case IDLE:		if (sysc_hand) docall = TRUE;		break; 				case READ:		switch (device_id) {				case TERMINAL:			if (trm_hand) docall = TRUE;			else {				rp = fgets(buf_p,*count_p,stdin);				if (rp==NULL) rval = ERR_SUP_RDFAIL;				else rval = strlen(buf_p);			}			break;					case COM_PORT:			if (com_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					default:			rval = ERR_SUP_INVDEV;					}		break;	case WRITE:		switch (device_id) {				case TERMINAL:			if (trm_hand) docall = TRUE;			else {				rval = *count_p;				for (ix=0; ix<*count_p; ix++) {					rc = fputc(buf_p[ix],stdout);					if (rc == EOF) {						rval = ERR_SUP_WRFAIL;						break;					}				}			}			break;					case COM_PORT:			if (com_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					case PRINTER:			if (prt_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					default:			rval = ERR_SUP_INVDEV;					}		break;	case CLEAR:		if (device_id==TERMINAL) {			if (trm_hand) docall = TRUE;			else {			     clrscr();				rval = 0;			}		}		else rval = ERR_SUP_INVDEV;		break;			case GOTOXY:		if (device_id==TERMINAL) {			if (trm_hand) docall = TRUE;			else {				if (*count_p != 2) rval = ERR_SUP_WRFAIL;				else if ((*buf_p<0)					|| (*buf_p > MAX_XPOS))					rval = ERR_SUP_WRFAIL;				else if ((*(buf_p+1)<0)					|| (*(buf_p+1) > MAX_YPOS))					rval = ERR_SUP_WRFAIL;				else {					gotoxy(*buf_p + 1,						*(buf_p+1) + 1);					rval = 0;				}			}		}		else rval = ERR_SUP_INVDEV;		break;			/* EXIT - terminate the calling process */	/* legal only when a system call handler is present */	case EXIT:		if (sysc_hand) docall = TRUE;		else rval = ERR_SUP_INVOPC;		break; 	default:		rval = ERR_SUP_INVOPC;			}		/* Invoke user's call handler if present.	   If the call is an IO request, return will occur	   only after the request is complete.	*/	if (docall && (rval==OK)) {		/* invoke the call handler */	_SP = _SP - sizeof(params);		param_p = (params*) MK_FP(_SS,_SP);	       param_p->op_code = op_code;	       param_p->device_id = device_id;	       param_p->buf_p = buf_p;	       param_p->count_p = count_p;	       geninterrupt(0x60);	       rval = _AX;	       _SP = _SP + sizeof(params);		/* for I/O operations, return count value */		switch(op_code) {		case READ:		case WRITE:		case CLEAR:		case GOTOXY:			rval = *count_p;		}	}	return(rval);}/*	Procedure: sys_alloc_mem	Purpose: Allocate a memory block	Parameters:			size_t size       No. of bytes to allocate	Returns: void* pointer to allocated block;		 null pointer in case of error		 	Calls: calloc		Globals: alloc_table, alloc_ix, num_alloc	For program loading (Module R-4), the blocks must be aligned.	This is achieved by requesting one extra paragraph and	returning the lowest aligned address as the base.  It is	necessary to keep a table of allocated address, original and	aligned, to support correct freeing.	It would seem simpler to use the Turbo-C function allocmem,	which always allocates aligned blocks.  However, allocmem	appears to conflict with the internal allocation of fopen	and other C library routines.*/void *sys_alloc_mem (      size_t   size     /* size in bytes to allocate */		    ){	int ix_save;      /* temp copy of table index */        void *addr;        /* addr returned by calloc (*void) */	word offset;      /* offset of unaligned address */	word seg;         /* segment addr of unaligned address */	void *addr_alig; /* aligned address */	int rem; /* temp for alignment computation */	/* ensure that allocation table is not full */	if (num_alloc >= MAX_ALLOC) {		return(NULL);	}	/* find free entry in allocation table */	ix_save = alloc_ix;	while (alloc_table[alloc_ix].original != NULL) {		alloc_ix++;		if (alloc_ix >= MAX_ALLOC) alloc_ix = 0;		/* safety check -- should never happen! */		if (alloc_ix == ix_save) return(NULL);	}	/* call allocation routine */	/* request 15 extra bytes to ensure alignment is possible */	addr = calloc(size + 15,1);	/* compute aligned base */	offset = FP_OFF(addr);        seg = FP_SEG(addr);	rem = offset % 16;	if (rem > 0) offset = offset + 16 - rem;	addr_alig = MK_FP(seg,offset);	/* insert entries in table */	alloc_table[alloc_ix].original = addr;	alloc_table[alloc_ix].aligned = addr_alig;	/* increment count */	num_alloc++;	return(addr_alig);}/*	Procedure: sys_free_mem	Purpose: free a memory block	Parameters:		void *ptr         ptr to block to allocate	Returns: integer error code; zero if OK		Calls:   free	Globals: alloc_table, num_alloc	Errors:  ERR_SUP_INVMEM    invalid memory block	This procedure receives an aligned address; it must	find and free the corresponding non-aligned one.*/int sys_free_mem (         void     *ptr     /* pointer to block */		 ){	void *free_addr;  /* true (unaligned) block address */	int free_ix;               /* temp table index */	/* ensure valid pointer */	if (ptr==NULL) return(ERR_SUP_INVMEM);	/* Look for the block in the allocation table */	free_addr = NULL;	for (free_ix=0; free_ix<MAX_ALLOC; free_ix++) {		if (alloc_table[free_ix].aligned == ptr) {			free_addr = alloc_table[free_ix].original;			break;		}	}	/* If the block wasn't found, report error */	if (free_addr == NULL) return(ERR_SUP_INVMEM);	/* free the block & clear the table entry */	alloc_table[free_ix].original = NULL;	alloc_table[free_ix].aligned = NULL;        free(free_addr);	/* decrement count */	num_alloc--;	return(OK);}        /*	Procedure: sys_get_date	Purpose: Returns the system date (month, day, year)	Parameters:		date_rec *date_p Pointer to structure of type date	Returns: void		Calls: none		Globals: sys_date        Errors: none*/void sys_get_date (  date_rec*      date_p   /* ptr to date record */		){	date_p->month = sys_date.da_mon;	date_p->day = sys_date.da_day;	date_p->year = sys_date.da_year;}/*	Procedure: sys_set_date	Purpose: Sets the system date (month, day, year)	Parameters:		date_rec *date_p ptr to structure of type date	Returns: error code; OK if no error	Calls:   none        Globals: sys_date	Errors: none*/int sys_set_date (  date_rec*       date_p   /* ptr to date record */		 ){	sys_date.da_mon = date_p->month;        sys_date.da_day = date_p->day;        sys_date.da_year = date_p->year;	return(OK);}/*	Procedure: sys_open_dir	Purpose: open a specified directory	Parameters: char dir_name[]            directory name	Returns: error code; zero if OK	Calls:   findfirst		strncpy  	Globals: current_path, file_block, num_entries	Errors:  ERR_SUP_DIROPN    directory open error		ERR_SUP_INVDIR    invalid directory*/int sys_open_dir (  char  path_name[]        /* directory name */		 ){        char temp_path[MAX_PATH_SIZE];	int res;        int len;        /* ensure there is no directory currently open */	if (current_path[0]!=NULCH) return(ERR_SUP_DIROPN);        /* check pathname for validity */        /* construct temporary search path name */	temp_path[0] = NULCH;	if (path_name != NULL) {		strncpy(temp_path,path_name,MAX_PATH_SIZE-4);	}	/* build wildcard search string */        len = strlen(temp_path);	/* if path is null, use current directory */        if (len==0) strcpy(temp_path,"*.*");	/* handle paths ending in backslash, including root */        else if (temp_path[len-1]=='\\') strcat(temp_path,"*.*");	/* handle paths not ending in backslash */        else strcat(temp_path,"\\*.*");	/* validate the directory by searching for either an ordinary	   file or a directory in it.  This should never fail; even	   empty directories contain the directories "." and ".."	*/		res = findfirst(temp_path, &file_block, FA_DIREC);	if (res!=0)  return(ERR_SUP_INVDIR);        /* save pathname as current, clear entry count */	current_path[0] = NULCH;	if (path_name != NULL) {		strncpy(current_path,path_name,MAX_PATH_SIZE-6);	}	num_entries = 0;	return(OK);}/*	Procedure: sys_get_entry	Purpose: get the next directory entry;	Parameters: char name_buf[]	name buffer		    int buf_size  	buffer capacity		    long *file_size_p	file length buffer         	Returns: error code, or zero if ok	Calls:	findfirst		findnext		strncpy, strcpy, strrchr, strcat    	Globals: current_path, num_entries, file_block	Errors:  ERR_SUP_NOENTR    no such entry*/int sys_get_entry (char    name_buf[],       /* buffer for entry */		   int   buf_size,         /* buffer size */		   long* file_size_p       /* buffer for size value */		  ){	char filename[MAX_PATH_SIZE+1];	int err;        int len;        char *cp;        /* find next MPX file entry, if any */        /* if this is the first call */	if (num_entries==0) {	       /* construct complete search path name */	       len = strlen(current_path);	       if (len==0) strcpy(current_path,"*.MPX");	       else if (current_path[len-1]=='\\') strcat(current_path,"*.MPX");	       else strcat(current_path,"\\*.MPX");	       /* find first entry */		err = findfirst (current_path,&file_block,0);        }        /* otherwise, find next entry */        else err = findnext(&file_block);        if (err<0) return(ERR_SUP_NOENTR);		/* ensure buf_size is not too large */		if (buf_size > MAX_PATH_SIZE) buf_size = MAX_PATH_SIZE;		      /* copy filename to buffer */	filename[buf_size] = NULCH;	strncpy (filename,file_block.ff_name,			 (size_t) buf_size);	/* remove ".MPX" from name */	cp = strrchr(filename, (int) '.');        *cp = NULCH;	/* copy name and size to caller's buffer */        strcpy (name_buf,filename);	*file_size_p = file_block.ff_fsize;        /* count entry */	num_entries++;	return(OK);}/*	Procedure: sys_close_dir	Purpose: close an open directory	Parameters: none	Returns: error code; zero if OK	Calls:   none	Globals: current_path	Errors:  none*/int sys_close_dir (void){	current_path[0] = NULCH;	return(OK);}/*	Procedure: sys_check_program	Purpose: locate and measure a program file	Parameters: see prototype	Returns: program size or error code	Calls:   strlen, strcat		fopen, fread	Globals: none	Errors:  ERR_SUP_NAMLNG    pathname too long		ERR_SUP_FILNFD    file not found		ERR_SUP_FILINV    file invalid*/#define HEADER_SIZE 32int sys_check_program(     char     dir_name[],       /* directory name */			char     prog_name[],      /* program name */			int*     prog_len_p,       /* ptr to prog length */			int*     start_offset_p    /* ptr to start offset */			){        /* buffer for full pathname */	char file_name[MAX_PATH_SIZE+1];        /* buffer for file header */        byte header[HEADER_SIZE];	FILE *file_p;     /* file pointer for C file routines */        int num_read;      /* number of header bytes read */	int file_size;    /* size of complete file */        int header_size;/* size of header */        int code_size;     /* size of program code */        int data_size;     /* size of program data */        int errcode;       /* error code */        /* ensure that path name is not too long */        if ((strlen(dir_name) + strlen(prog_name) + 5)		 > MAX_PATH_SIZE) return(ERR_SUP_NAMLNG);	/* construct path name */	file_name[0] = NULCH;	if (dir_name[0] != NULCH) {		strcat(file_name, dir_name);	        strcat(file_name, "\\");	}        strcat(file_name, prog_name);	strcat(file_name, ".MPX");        /* try to open the file */	errcode = OK;        file_p = fopen(file_name, "rb");        if (file_p == NULL) return(ERR_SUP_FILNFD);	/* read the header, check for EXE signature */        num_read = fread( (void*) header, 1, HEADER_SIZE, file_p);        if (num_read != HEADER_SIZE) {		errcode = ERR_SUP_FILINV;	}        else if ((header[0] != 0x4D) || (header[1] != 0x5A)) {		errcode = ERR_SUP_FILINV;	}        /* close the file, then return if error occurred */        fclose(file_p);	if (errcode!=OK) return(errcode);        /* compute allocation size needed */        file_size = (header[5]*256 + header[4] -1) * 512		+ (header[3]*256 + header[2]);        header_size =(header[9]*256 + header[8])*16;        code_size = file_size - header_size;        data_size = (header[11]*256 + header[10])*16;        /* return total length and starting offset */        *prog_len_p = code_size + data_size;	*start_offset_p = (header[23]*256 + header[22]) * 16;	return(OK);}/*	Procedure: sys_load_program	Purpose: load a program file	Parameters: see prototype	Returns: error code; zero if OK	Calls:   intdosx		segread		strlen, strcat	Globals: none 	Errors:  ERR_SUP_NAMLNG    name too long		ERR_SUP_FILNFD    file not found	       ERR_SUP_FILINV      file invalid		ERR_SUP_PROGSZ    program too large	       ERR_SUP_LDADDR      address not aligned		ERR_SUP_LDFAIL    load failed*/int sys_load_program (     void*    load_addr,        /* address for loading */			int      max_size,         /* memory size */			char     dir_name[],       /* directory name */			char     prog_name[]       /* program name */		      ){	int errcode;      /* error code */        int prog_len;      /* program length */	int offset;       /* offset for starting */	word norm_seg;    /* normalized load address segment */        word norm_off;     /* normalized load address offset */        /* full pathname for file to be loaded */	char file_name[MAX_PATH_SIZE+1];        /* parameter block for MSDOS EXEC function */	struct {		word load_seg;    /* segment address for loading */	       word reloc_seg;     /* segment address for relocation */        }p_block;	union REGS inregs;            /* input register structure */	union REGS outregs;           /* output register structure */	struct SREGS segregs;         /* segment register structure */        /* check program, get length and offset */	errcode = sys_check_program(dir_name, prog_name,					&prog_len, &offset);        if (errcode < 0) return(errcode);        /* ensure that allocated memory is large enough */        if (max_size < prog_len) return(ERR_SUP_PROGSZ);        /* get normalized segment and offset, check alignment */	norm_seg = FP_SEG(load_addr);	norm_off = FP_OFF(load_addr);	norm_seg += norm_off / 16;        norm_off %= 16;	if (norm_off != 0) return(ERR_SUP_LDADDR);        /* ensure that path name is not too long */        if ((strlen(dir_name) + strlen(prog_name) + 5)		 > MAX_PATH_SIZE) return(ERR_SUP_NAMLNG);	/* construct path name */	file_name[0] = NULCH;	if (dir_name[0] != NULCH) {		strcat(file_name, dir_name);	        strcat(file_name, "\\");	}        strcat(file_name, prog_name);	strcat(file_name, ".MPX");        /* get current segment regs */	segread(&segregs);        /* setup function codes */	inregs.h.ah = 0x4B;        /* EXEC function */	inregs.h.al = 0x03;        /* load only */        /* setup parameter block and name pointers */        segregs.ds = FP_SEG(&file_name);	inregs.x.dx = FP_OFF(&file_name);        segregs.es = FP_SEG(&p_block);	inregs.x.bx = FP_OFF(&p_block);        /* setup load segment -- must be normalized */	p_block.load_seg = norm_seg;	p_block.reloc_seg = p_block.load_seg;        /* call the MS-DOS loader */	errcode = intdosx(&inregs,&outregs,&segregs);        errcode = errcode;        /* check for error */	if (outregs.x.cflag) return(ERR_SUP_LDFAIL);	/* load successful */	return(OK);}/* END OF FILE */trm_hand1,0
/***********************************************************************	MPX: The MultiProgramming eXecutive	Project to Accompany	A Practical Approach to Operating Systems	Malcolm G. Lane & James D. Mooney	Copyright 1993, P.W.S. Kent Publishing Co., Boston, MA.		File Name: mpx_supt.c	Authors: J.J. Patnesky, A. Ghosal, M. Lane, J. Mooney	Version: 2.1b	Date: 01/31/08	Purpose: Support routines for MPX-PC		Modules: all	Environment:      IBM-PC (XT, AT or PS/2)			MS-DOS 3.3 or later			TURBO-C 3.0 or TURBO-C++ 1.0 or later	Compile using the LARGE MODEL and SS NOT equal to DS.	All addresses and pointers are "far", and	CS, DS and SS are independent.	Procedures in this file:		sys_init		sys_exit		sys_set_vec		sys_req		sys_alloc_mem		sys_free_mem		sys_get_date		sys_set_date		sys_open_dir		sys_get_entry		sys_close_dir	       sys_check_program	       sys_load_program************************************************************************Change Log:	07/16/88  akg	added comments	02/25/92  jdm	full revision, UNIX version	04/14/92  jdm	Macintosh version	05/15/92  jdm	cleanup and documentation	07/14/92  jdm	update for revised specs        08/13/92  jdm 	revised IBM version; added private heap        10/14/92  jdm 	added check and load procedures        10/18/92  jdm 	revised sys_alloc_mem for alignment	11/17/92  jdm	true heap mgt, aligned, using calloc & free	11/19/92  jdm	enable device handling for final module	12/31/92  jdm	revised sys_req parameters	01/02/93  jdm	return count value after I/O	01/03/93  jdm	revised error names and codes	01/27/93  jdm	corrected count for line input in sys_req			fixed open_dir to handle null lines	02/24/93  jdm	changed sys_set_vec param to interrupt	03/08/93  jdm	corrections to sys_check & sys_load	03/20/93  jdm	stack switch in free, check, and load	04/22/93  jdm	corrected index conflict in sys_free_mem			added safety escape in alloc table search	07/28/93  jdm	conversion to large model	09/01/93  jdm	fixed allocation bug;  made date private	09/14/93  jdm	cleaned up memory allocation        09/16/93  jdm	adjusted program load for large model        09/30/93  jdm	modified for correct list of root directory	11/01/94  jdm	changed load file read to binary	09/18/95  jdm	fixed get_entry to default to current, not root	01/31/08  jdm   fixed possible overflow problem in get_entry************************************************************************/#include "mpx_supt.h"#include <stdlib.h>#include <dos.h>#include <dir.h>#include <errno.h>#include <conio.h>#include <alloc.h>#define VEC_ADDR (0x60L*4)#define MAX_ALLOC 200#define MAX_XPOS 79#define MAX_YPOS 24#define MAX_PATH_SIZE 50/*	System-dependent type definitions*/typedef unsigned char byte;typedef unsigned int word;typedef unsigned long longword;typedef byte *address;typedef struct params {	int      op_code;	int      device_id;	char     *buf_p;	int      *count_p;	} params;/*	Global variables accessed only by support routines*/	static longword vec_save;  /* saved interrupt vector */	static int mod_code;                /* module code */                                           	static struct date sys_date;        /* MPX system date */	/* data structures for directory access */        static char current_path[MAX_PATH_SIZE+1];        static int num_entries;        static struct ffblk file_block;        /* handler presence flags */	static flag sysc_hand;	static flag trm_hand;	static flag prt_hand;	static flag com_hand;        /* memory allocation table */	static struct {		void* original;		void* aligned;	} alloc_table[MAX_ALLOC];	static int alloc_ix;                /* current index */	static int num_alloc;               /* no. of allocated blocks *//*	Procedure: sys_init	Purpose: initialize mpx	Parameters: see prototype  	Return value: error code, or OK if no error	Calls: getdate    	Globals: mod_code		vec_save		sys_date		alloc_table, alloc_ix, num_alloc		sysc_hand, term_hand, prt_hand, com_hand	Errors: none*/int sys_init (    int      modules  /* module code */	     ){	mod_code = modules;        vec_save = 0L;        /* no handlers detected yet */	sysc_hand = FALSE;	trm_hand = FALSE;	prt_hand = FALSE;	com_hand = FALSE;	/* initialize allocation table */	for (alloc_ix=0; alloc_ix < MAX_ALLOC; alloc_ix++) {		alloc_table[alloc_ix].original = NULL;		alloc_table[alloc_ix].aligned = NULL;	}	alloc_ix = 0;	num_alloc = 0;	/* if we have reached Module R3, enable system call handling */	if (modules >= MODULE_R3) sysc_hand = TRUE;	/* if we have reached the final module, enable device handlers */	if (modules >= MODULE_F) {		trm_hand = TRUE;		prt_hand = TRUE;		com_hand = TRUE;	}	/* get system date */        getdate(&sys_date);	return (OK);}/*	Procedure: sys_exit	Purpose: terminate mpx	Parameters: none  	Return value: none	Calls: none       	Globals: vec_save*/void sys_exit(void){	longword *vec_p;	/* if trap vector changed, restore it */	if (vec_save != 0L) {		vec_p = (longword*) VEC_ADDR;		*vec_p = vec_save;	}	/* return to host with null error code */	exit(0);}/*	Procedure: sys_set_vec	Purpose: link trap vector to MPX system call handler	Parameters: handler: addr of handler         	Return value: error code; OK if no error	Calls: none       	Globals: vec_save	Errors: none*/int sys_set_vec   ( void interrupt (*handler)() /* system call handler */		){	longword *vec_p;			vec_p = (longword*) VEC_ADDR;		vec_save = *vec_p;		*vec_p = (longword) handler;	return (0);}/*	Procedure: sys_req	Purpose: Request a system service	Inputs:		op_code           operation code		device_id         device identifier		buf_p             addresso f data buffer		count_p           address of size of buffer	Returns: Result or error code, depending on service		Services supported:	IDLE     null operation				READ     input from a device				WRITE    output to a device				CLEAR    clear terminal screen				GOTOXY   absolute cursor position				EXIT     terminate the caller	Calls:   fgets		strlen			Globals: none		Errors:  ERR_SUP_INVDEV    invalid device		ERR_SUP_INVOPC    invalid operation code		ERR_SUP_INVPOS    invalid character position		ERR_SUP_RDFAIL    read failed		ERR_SUP_WRFAIL    write failed	Description:	For Modules R1 through R4,	this procedure is used only for terminal I/O.	Later modules support both reading and	writing for several devices.	For Modules R1 through R4,	sys_req uses the ANSI C function "fgets."	Later modules may use alternate functions and device drivers.*/int sys_req (   int      op_code, /* operation code */		int      device_id,        /* device id */		char*    buf_p,            /* I/O buffer */		int*     count_p           /* address of count */		){	int      rval;    /* result or error code */	char     *rp;     /* return pointer for fgets */	char     rc;      /* return char for fputc */        params    *param_p; /* pointer to parameter record in stack */	flag     docall;  /* true if system call interrupt wanted */	int      ix;      /* temporary index */	docall = FALSE;	rval = OK;	switch (op_code) {		case IDLE:		if (sysc_hand) docall = TRUE;		break; 				case READ:		switch (device_id) {				case TERMINAL:			if (trm_hand) docall = TRUE;			else {				rp = fgets(buf_p,*count_p,stdin);				if (rp==NULL) rval = ERR_SUP_RDFAIL;				else rval = strlen(buf_p);			}			break;					case COM_PORT:			if (com_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					default:			rval = ERR_SUP_INVDEV;					}		break;	case WRITE:		switch (device_id) {				case TERMINAL:			if (trm_hand) docall = TRUE;			else {				rval = *count_p;				for (ix=0; ix<*count_p; ix++) {					rc = fputc(buf_p[ix],stdout);					if (rc == EOF) {						rval = ERR_SUP_WRFAIL;						break;					}				}			}			break;					case COM_PORT:			if (com_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					case PRINTER:			if (prt_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					default:			rval = ERR_SUP_INVDEV;					}		break;	case CLEAR:		if (device_id==TERMINAL) {			if (trm_hand) docall = TRUE;			else {			     clrscr();				rval = 0;			}		}		else rval = ERR_SUP_INVDEV;		break;			case GOTOXY:		if (device_id==TERMINAL) {			if (trm_hand) docall = TRUE;			else {				if (*count_p != 2) rval = ERR_SUP_WRFAIL;				else if ((*buf_p<0)					|| (*buf_p > MAX_XPOS))					rval = ERR_SUP_WRFAIL;				else if ((*(buf_p+1)<0)					|| (*(buf_p+1) > MAX_YPOS))					rval = ERR_SUP_WRFAIL;				else {					gotoxy(*buf_p + 1,						*(buf_p+1) + 1);					rval = 0;				}			}		}		else rval = ERR_SUP_INVDEV;		break;			/* EXIT - terminate the calling process */	/* legal only when a system call handler is present */	case EXIT:		if (sysc_hand) docall = TRUE;		else rval = ERR_SUP_INVOPC;		break; 	default:		rval = ERR_SUP_INVOPC;			}		/* Invoke user's call handler if present.	   If the call is an IO request, return will occur	   only after the request is complete.	*/	if (docall && (rval==OK)) {		/* invoke the call handler */	_SP = _SP - sizeof(params);		param_p = (params*) MK_FP(_SS,_SP);	       param_p->op_code = op_code;	       param_p->device_id = device_id;	       param_p->buf_p = buf_p;	       param_p->count_p = count_p;	       geninterrupt(0x60);	       rval = _AX;	       _SP = _SP + sizeof(params);		/* for I/O operations, return count value */		switch(op_code) {		case READ:		case WRITE:		case CLEAR:		case GOTOXY:			rval = *count_p;		}	}	return(rval);}/*	Procedure: sys_alloc_mem	Purpose: Allocate a memory block	Parameters:			size_t size       No. of bytes to allocate	Returns: void* pointer to allocated block;		 null pointer in case of error		 	Calls: calloc		Globals: alloc_table, alloc_ix, num_alloc	For program loading (Module R-4), the blocks must be aligned.	This is achieved by requesting one extra paragraph and	returning the lowest aligned address as the base.  It is	necessary to keep a table of allocated address, original and	aligned, to support correct freeing.	It would seem simpler to use the Turbo-C function allocmem,	which always allocates aligned blocks.  However, allocmem	appears to conflict with the internal allocation of fopen	and other C library routines.*/void *sys_alloc_mem (      size_t   size     /* size in bytes to allocate */		    ){	int ix_save;      /* temp copy of table index */        void *addr;        /* addr returned by calloc (*void) */	word offset;      /* offset of unaligned address */	word seg;         /* segment addr of unaligned address */	void *addr_alig; /* aligned address */	int rem; /* temp for alignment computation */	/* ensure that allocation table is not full */	if (num_alloc >= MAX_ALLOC) {		return(NULL);	}	/* find free entry in allocation table */	ix_save = alloc_ix;	while (alloc_table[alloc_ix].original != NULL) {		alloc_ix++;		if (alloc_ix >= MAX_ALLOC) alloc_ix = 0;		/* safety check -- should never happen! */		if (alloc_ix == ix_save) return(NULL);	}	/* call allocation routine */	/* request 15 extra bytes to ensure alignment is possible */	addr = calloc(size + 15,1);	/* compute aligned base */	offset = FP_OFF(addr);        seg = FP_SEG(addr);	rem = offset % 16;	if (rem > 0) offset = offset + 16 - rem;	addr_alig = MK_FP(seg,offset);	/* insert entries in table */	alloc_table[alloc_ix].original = addr;	alloc_table[alloc_ix].aligned = addr_alig;	/* increment count */	num_alloc++;	return(addr_alig);}/*	Procedure: sys_free_mem	Purpose: free a memory block	Parameters:		void *ptr         ptr to block to allocate	Returns: integer error code; zero if OK		Calls:   free	Globals: alloc_table, num_alloc	Errors:  ERR_SUP_INVMEM    invalid memory block	This procedure receives an aligned address; it must	find and free the corresponding non-aligned one.*/int sys_free_mem (         void     *ptr     /* pointer to block */		 ){	void *free_addr;  /* true (unaligned) block address */	int free_ix;               /* temp table index */	/* ensure valid pointer */	if (ptr==NULL) return(ERR_SUP_INVMEM);	/* Look for the block in the allocation table */	free_addr = NULL;	for (free_ix=0; free_ix<MAX_ALLOC; free_ix++) {		if (alloc_table[free_ix].aligned == ptr) {			free_addr = alloc_table[free_ix].original;			break;		}	}	/* If the block wasn't found, report error */	if (free_addr == NULL) return(ERR_SUP_INVMEM);	/* free the block & clear the table entry */	alloc_table[free_ix].original = NULL;	alloc_table[free_ix].aligned = NULL;        free(free_addr);	/* decrement count */	num_alloc--;	return(OK);}        /*	Procedure: sys_get_date	Purpose: Returns the system date (month, day, year)	Parameters:		date_rec *date_p Pointer to structure of type date	Returns: void		Calls: none		Globals: sys_date        Errors: none*/void sys_get_date (  date_rec*      date_p   /* ptr to date record */		){	date_p->month = sys_date.da_mon;	date_p->day = sys_date.da_day;	date_p->year = sys_date.da_year;}/*	Procedure: sys_set_date	Purpose: Sets the system date (month, day, year)	Parameters:		date_rec *date_p ptr to structure of type date	Returns: error code; OK if no error	Calls:   none        Globals: sys_date	Errors: none*/int sys_set_date (  date_rec*       date_p   /* ptr to date record */		 ){	sys_date.da_mon = date_p->month;        sys_date.da_day = date_p->day;        sys_date.da_year = date_p->year;	return(OK);}/*	Procedure: sys_open_dir	Purpose: open a specified directory	Parameters: char dir_name[]            directory name	Returns: error code; zero if OK	Calls:   findfirst		strncpy  	Globals: current_path, file_block, num_entries	Errors:  ERR_SUP_DIROPN    directory open error		ERR_SUP_INVDIR    invalid directory*/int sys_open_dir (  char  path_name[]        /* directory name */		 ){        char temp_path[MAX_PATH_SIZE];	int res;        int len;        /* ensure there is no directory currently open */	if (current_path[0]!=NULCH) return(ERR_SUP_DIROPN);        /* check pathname for validity */        /* construct temporary search path name */	temp_path[0] = NULCH;	if (path_name != NULL) {		strncpy(temp_path,path_name,MAX_PATH_SIZE-4);	}	/* build wildcard search string */        len = strlen(temp_path);	/* if path is null, use current directory */        if (len==0) strcpy(temp_path,"*.*");	/* handle paths ending in backslash, including root */        else if (temp_path[len-1]=='\\') strcat(temp_path,"*.*");	/* handle paths not ending in backslash */        else strcat(temp_path,"\\*.*");	/* validate the directory by searching for either an ordinary	   file or a directory in it.  This should never fail; even	   empty directories contain the directories "." and ".."	*/		res = findfirst(temp_path, &file_block, FA_DIREC);	if (res!=0)  return(ERR_SUP_INVDIR);        /* save pathname as current, clear entry count */	current_path[0] = NULCH;	if (path_name != NULL) {		strncpy(current_path,path_name,MAX_PATH_SIZE-6);	}	num_entries = 0;	return(OK);}/*	Procedure: sys_get_entry	Purpose: get the next directory entry;	Parameters: char name_buf[]	name buffer		    int buf_size  	buffer capacity		    long *file_size_p	file length buffer         	Returns: error code, or zero if ok	Calls:	findfirst		findnext		strncpy, strcpy, strrchr, strcat    	Globals: current_path, num_entries, file_block	Errors:  ERR_SUP_NOENTR    no such entry*/int sys_get_entry (char    name_buf[],       /* buffer for entry */		   int   buf_size,         /* buffer size */		   long* file_size_p       /* buffer for size value */		  ){	char filename[MAX_PATH_SIZE+1];	int err;        int len;        char *cp;        /* find next MPX file entry, if any */        /* if this is the first call */	if (num_entries==0) {	       /* construct complete search path name */	       len = strlen(current_path);	       if (len==0) strcpy(current_path,"*.MPX");	       else if (current_path[len-1]=='\\') strcat(current_path,"*.MPX");	       else strcat(current_path,"\\*.MPX");	       /* find first entry */		err = findfirst (current_path,&file_block,0);        }        /* otherwise, find next entry */        else err = findnext(&file_block);        if (err<0) return(ERR_SUP_NOENTR);		/* ensure buf_size is not too large */		if (buf_size > MAX_PATH_SIZE) buf_size = MAX_PATH_SIZE;		      /* copy filename to buffer */	filename[buf_size] = NULCH;	strncpy (filename,file_block.ff_name,			 (size_t) buf_size);	/* remove ".MPX" from name */	cp = strrchr(filename, (int) '.');        *cp = NULCH;	/* copy name and size to caller's buffer */        strcpy (name_buf,filename);	*file_size_p = file_block.ff_fsize;        /* count entry */	num_entries++;	return(OK);}/*	Procedure: sys_close_dir	Purpose: close an open directory	Parameters: none	Returns: error code; zero if OK	Calls:   none	Globals: current_path	Errors:  none*/int sys_close_dir (void){	current_path[0] = NULCH;	return(OK);}/*	Procedure: sys_check_program	Purpose: locate and measure a program file	Parameters: see prototype	Returns: program size or error code	Calls:   strlen, strcat		fopen, fread	Globals: none	Errors:  ERR_SUP_NAMLNG    pathname too long		ERR_SUP_FILNFD    file not found		ERR_SUP_FILINV    file invalid*/#define HEADER_SIZE 32int sys_check_program(     char     dir_name[],       /* directory name */			char     prog_name[],      /* program name */			int*     prog_len_p,       /* ptr to prog length */			int*     start_offset_p    /* ptr to start offset */			){        /* buffer for full pathname */	char file_name[MAX_PATH_SIZE+1];        /* buffer for file header */        byte header[HEADER_SIZE];	FILE *file_p;     /* file pointer for C file routines */        int num_read;      /* number of header bytes read */	int file_size;    /* size of complete file */        int header_size;/* size of header */        int code_size;     /* size of program code */        int data_size;     /* size of program data */        int errcode;       /* error code */        /* ensure that path name is not too long */        if ((strlen(dir_name) + strlen(prog_name) + 5)		 > MAX_PATH_SIZE) return(ERR_SUP_NAMLNG);	/* construct path name */	file_name[0] = NULCH;	if (dir_name[0] != NULCH) {		strcat(file_name, dir_name);	        strcat(file_name, "\\");	}        strcat(file_name, prog_name);	strcat(file_name, ".MPX");        /* try to open the file */	errcode = OK;        file_p = fopen(file_name, "rb");        if (file_p == NULL) return(ERR_SUP_FILNFD);	/* read the header, check for EXE signature */        num_read = fread( (void*) header, 1, HEADER_SIZE, file_p);        if (num_read != HEADER_SIZE) {		errcode = ERR_SUP_FILINV;	}        else if ((header[0] != 0x4D) || (header[1] != 0x5A)) {		errcode = ERR_SUP_FILINV;	}        /* close the file, then return if error occurred */        fclose(file_p);	if (errcode!=OK) return(errcode);        /* compute allocation size needed */        file_size = (header[5]*256 + header[4] -1) * 512		+ (header[3]*256 + header[2]);        header_size =(header[9]*256 + header[8])*16;        code_size = file_size - header_size;        data_size = (header[11]*256 + header[10])*16;        /* return total length and starting offset */        *prog_len_p = code_size + data_size;	*start_offset_p = (header[23]*256 + header[22]) * 16;	return(OK);}/*	Procedure: sys_load_program	Purpose: load a program file	Parameters: see prototype	Returns: error code; zero if OK	Calls:   intdosx		segread		strlen, strcat	Globals: none 	Errors:  ERR_SUP_NAMLNG    name too long		ERR_SUP_FILNFD    file not found	       ERR_SUP_FILINV      file invalid		ERR_SUP_PROGSZ    program too large	       ERR_SUP_LDADDR      address not aligned		ERR_SUP_LDFAIL    load failed*/int sys_load_program (     void*    load_addr,        /* address for loading */			int      max_size,         /* memory size */			char     dir_name[],       /* directory name */			char     prog_name[]       /* program name */		      ){	int errcode;      /* error code */        int prog_len;      /* program length */	int offset;       /* offset for starting */	word norm_seg;    /* normalized load address segment */        word norm_off;     /* normalized load address offset */        /* full pathname for file to be loaded */	char file_name[MAX_PATH_SIZE+1];        /* parameter block for MSDOS EXEC function */	struct {		word load_seg;    /* segment address for loading */	       word reloc_seg;     /* segment address for relocation */        }p_block;	union REGS inregs;            /* input register structure */	union REGS outregs;           /* output register structure */	struct SREGS segregs;         /* segment register structure */        /* check program, get length and offset */	errcode = sys_check_program(dir_name, prog_name,					&prog_len, &offset);        if (errcode < 0) return(errcode);        /* ensure that allocated memory is large enough */        if (max_size < prog_len) return(ERR_SUP_PROGSZ);        /* get normalized segment and offset, check alignment */	norm_seg = FP_SEG(load_addr);	norm_off = FP_OFF(load_addr);	norm_seg += norm_off / 16;        norm_off %= 16;	if (norm_off != 0) return(ERR_SUP_LDADDR);        /* ensure that path name is not too long */        if ((strlen(dir_name) + strlen(prog_name) + 5)		 > MAX_PATH_SIZE) return(ERR_SUP_NAMLNG);	/* construct path name */	file_name[0] = NULCH;	if (dir_name[0] != NULCH) {		strcat(file_name, dir_name);	        strcat(file_name, "\\");	}        strcat(file_name, prog_name);	strcat(file_name, ".MPX");        /* get current segment regs */	segread(&segregs);        /* setup function codes */	inregs.h.ah = 0x4B;        /* EXEC function */	inregs.h.al = 0x03;        /* load only */        /* setup parameter block and name pointers */        segregs.ds = FP_SEG(&file_name);	inregs.x.dx = FP_OFF(&file_name);        segregs.es = FP_SEG(&p_block);	inregs.x.bx = FP_OFF(&p_block);        /* setup load segment -- must be normalized */	p_block.load_seg = norm_seg;	p_block.reloc_seg = p_block.load_seg;        /* call the MS-DOS loader */	errcode = intdosx(&inregs,&outregs,&segregs);        errcode = errcode;        /* check for error */	if (outregs.x.cflag) return(ERR_SUP_LDFAIL);	/* load successful */	return(OK);}/* END OF FILE */prt_hand1,0
/***********************************************************************	MPX: The MultiProgramming eXecutive	Project to Accompany	A Practical Approach to Operating Systems	Malcolm G. Lane & James D. Mooney	Copyright 1993, P.W.S. Kent Publishing Co., Boston, MA.		File Name: mpx_supt.c	Authors: J.J. Patnesky, A. Ghosal, M. Lane, J. Mooney	Version: 2.1b	Date: 01/31/08	Purpose: Support routines for MPX-PC		Modules: all	Environment:      IBM-PC (XT, AT or PS/2)			MS-DOS 3.3 or later			TURBO-C 3.0 or TURBO-C++ 1.0 or later	Compile using the LARGE MODEL and SS NOT equal to DS.	All addresses and pointers are "far", and	CS, DS and SS are independent.	Procedures in this file:		sys_init		sys_exit		sys_set_vec		sys_req		sys_alloc_mem		sys_free_mem		sys_get_date		sys_set_date		sys_open_dir		sys_get_entry		sys_close_dir	       sys_check_program	       sys_load_program************************************************************************Change Log:	07/16/88  akg	added comments	02/25/92  jdm	full revision, UNIX version	04/14/92  jdm	Macintosh version	05/15/92  jdm	cleanup and documentation	07/14/92  jdm	update for revised specs        08/13/92  jdm 	revised IBM version; added private heap        10/14/92  jdm 	added check and load procedures        10/18/92  jdm 	revised sys_alloc_mem for alignment	11/17/92  jdm	true heap mgt, aligned, using calloc & free	11/19/92  jdm	enable device handling for final module	12/31/92  jdm	revised sys_req parameters	01/02/93  jdm	return count value after I/O	01/03/93  jdm	revised error names and codes	01/27/93  jdm	corrected count for line input in sys_req			fixed open_dir to handle null lines	02/24/93  jdm	changed sys_set_vec param to interrupt	03/08/93  jdm	corrections to sys_check & sys_load	03/20/93  jdm	stack switch in free, check, and load	04/22/93  jdm	corrected index conflict in sys_free_mem			added safety escape in alloc table search	07/28/93  jdm	conversion to large model	09/01/93  jdm	fixed allocation bug;  made date private	09/14/93  jdm	cleaned up memory allocation        09/16/93  jdm	adjusted program load for large model        09/30/93  jdm	modified for correct list of root directory	11/01/94  jdm	changed load file read to binary	09/18/95  jdm	fixed get_entry to default to current, not root	01/31/08  jdm   fixed possible overflow problem in get_entry************************************************************************/#include "mpx_supt.h"#include <stdlib.h>#include <dos.h>#include <dir.h>#include <errno.h>#include <conio.h>#include <alloc.h>#define VEC_ADDR (0x60L*4)#define MAX_ALLOC 200#define MAX_XPOS 79#define MAX_YPOS 24#define MAX_PATH_SIZE 50/*	System-dependent type definitions*/typedef unsigned char byte;typedef unsigned int word;typedef unsigned long longword;typedef byte *address;typedef struct params {	int      op_code;	int      device_id;	char     *buf_p;	int      *count_p;	} params;/*	Global variables accessed only by support routines*/	static longword vec_save;  /* saved interrupt vector */	static int mod_code;                /* module code */                                           	static struct date sys_date;        /* MPX system date */	/* data structures for directory access */        static char current_path[MAX_PATH_SIZE+1];        static int num_entries;        static struct ffblk file_block;        /* handler presence flags */	static flag sysc_hand;	static flag trm_hand;	static flag prt_hand;	static flag com_hand;        /* memory allocation table */	static struct {		void* original;		void* aligned;	} alloc_table[MAX_ALLOC];	static int alloc_ix;                /* current index */	static int num_alloc;               /* no. of allocated blocks *//*	Procedure: sys_init	Purpose: initialize mpx	Parameters: see prototype  	Return value: error code, or OK if no error	Calls: getdate    	Globals: mod_code		vec_save		sys_date		alloc_table, alloc_ix, num_alloc		sysc_hand, term_hand, prt_hand, com_hand	Errors: none*/int sys_init (    int      modules  /* module code */	     ){	mod_code = modules;        vec_save = 0L;        /* no handlers detected yet */	sysc_hand = FALSE;	trm_hand = FALSE;	prt_hand = FALSE;	com_hand = FALSE;	/* initialize allocation table */	for (alloc_ix=0; alloc_ix < MAX_ALLOC; alloc_ix++) {		alloc_table[alloc_ix].original = NULL;		alloc_table[alloc_ix].aligned = NULL;	}	alloc_ix = 0;	num_alloc = 0;	/* if we have reached Module R3, enable system call handling */	if (modules >= MODULE_R3) sysc_hand = TRUE;	/* if we have reached the final module, enable device handlers */	if (modules >= MODULE_F) {		trm_hand = TRUE;		prt_hand = TRUE;		com_hand = TRUE;	}	/* get system date */        getdate(&sys_date);	return (OK);}/*	Procedure: sys_exit	Purpose: terminate mpx	Parameters: none  	Return value: none	Calls: none       	Globals: vec_save*/void sys_exit(void){	longword *vec_p;	/* if trap vector changed, restore it */	if (vec_save != 0L) {		vec_p = (longword*) VEC_ADDR;		*vec_p = vec_save;	}	/* return to host with null error code */	exit(0);}/*	Procedure: sys_set_vec	Purpose: link trap vector to MPX system call handler	Parameters: handler: addr of handler         	Return value: error code; OK if no error	Calls: none       	Globals: vec_save	Errors: none*/int sys_set_vec   ( void interrupt (*handler)() /* system call handler */		){	longword *vec_p;			vec_p = (longword*) VEC_ADDR;		vec_save = *vec_p;		*vec_p = (longword) handler;	return (0);}/*	Procedure: sys_req	Purpose: Request a system service	Inputs:		op_code           operation code		device_id         device identifier		buf_p             addresso f data buffer		count_p           address of size of buffer	Returns: Result or error code, depending on service		Services supported:	IDLE     null operation				READ     input from a device				WRITE    output to a device				CLEAR    clear terminal screen				GOTOXY   absolute cursor position				EXIT     terminate the caller	Calls:   fgets		strlen			Globals: none		Errors:  ERR_SUP_INVDEV    invalid device		ERR_SUP_INVOPC    invalid operation code		ERR_SUP_INVPOS    invalid character position		ERR_SUP_RDFAIL    read failed		ERR_SUP_WRFAIL    write failed	Description:	For Modules R1 through R4,	this procedure is used only for terminal I/O.	Later modules support both reading and	writing for several devices.	For Modules R1 through R4,	sys_req uses the ANSI C function "fgets."	Later modules may use alternate functions and device drivers.*/int sys_req (   int      op_code, /* operation code */		int      device_id,        /* device id */		char*    buf_p,            /* I/O buffer */		int*     count_p           /* address of count */		){	int      rval;    /* result or error code */	char     *rp;     /* return pointer for fgets */	char     rc;      /* return char for fputc */        params    *param_p; /* pointer to parameter record in stack */	flag     docall;  /* true if system call interrupt wanted */	int      ix;      /* temporary index */	docall = FALSE;	rval = OK;	switch (op_code) {		case IDLE:		if (sysc_hand) docall = TRUE;		break; 				case READ:		switch (device_id) {				case TERMINAL:			if (trm_hand) docall = TRUE;			else {				rp = fgets(buf_p,*count_p,stdin);				if (rp==NULL) rval = ERR_SUP_RDFAIL;				else rval = strlen(buf_p);			}			break;					case COM_PORT:			if (com_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					default:			rval = ERR_SUP_INVDEV;					}		break;	case WRITE:		switch (device_id) {				case TERMINAL:			if (trm_hand) docall = TRUE;			else {				rval = *count_p;				for (ix=0; ix<*count_p; ix++) {					rc = fputc(buf_p[ix],stdout);					if (rc == EOF) {						rval = ERR_SUP_WRFAIL;						break;					}				}			}			break;					case COM_PORT:			if (com_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					case PRINTER:			if (prt_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					default:			rval = ERR_SUP_INVDEV;					}		break;	case CLEAR:		if (device_id==TERMINAL) {			if (trm_hand) docall = TRUE;			else {			     clrscr();				rval = 0;			}		}		else rval = ERR_SUP_INVDEV;		break;			case GOTOXY:		if (device_id==TERMINAL) {			if (trm_hand) docall = TRUE;			else {				if (*count_p != 2) rval = ERR_SUP_WRFAIL;				else if ((*buf_p<0)					|| (*buf_p > MAX_XPOS))					rval = ERR_SUP_WRFAIL;				else if ((*(buf_p+1)<0)					|| (*(buf_p+1) > MAX_YPOS))					rval = ERR_SUP_WRFAIL;				else {					gotoxy(*buf_p + 1,						*(buf_p+1) + 1);					rval = 0;				}			}		}		else rval = ERR_SUP_INVDEV;		break;			/* EXIT - terminate the calling process */	/* legal only when a system call handler is present */	case EXIT:		if (sysc_hand) docall = TRUE;		else rval = ERR_SUP_INVOPC;		break; 	default:		rval = ERR_SUP_INVOPC;			}		/* Invoke user's call handler if present.	   If the call is an IO request, return will occur	   only after the request is complete.	*/	if (docall && (rval==OK)) {		/* invoke the call handler */	_SP = _SP - sizeof(params);		param_p = (params*) MK_FP(_SS,_SP);	       param_p->op_code = op_code;	       param_p->device_id = device_id;	       param_p->buf_p = buf_p;	       param_p->count_p = count_p;	       geninterrupt(0x60);	       rval = _AX;	       _SP = _SP + sizeof(params);		/* for I/O operations, return count value */		switch(op_code) {		case READ:		case WRITE:		case CLEAR:		case GOTOXY:			rval = *count_p;		}	}	return(rval);}/*	Procedure: sys_alloc_mem	Purpose: Allocate a memory block	Parameters:			size_t size       No. of bytes to allocate	Returns: void* pointer to allocated block;		 null pointer in case of error		 	Calls: calloc		Globals: alloc_table, alloc_ix, num_alloc	For program loading (Module R-4), the blocks must be aligned.	This is achieved by requesting one extra paragraph and	returning the lowest aligned address as the base.  It is	necessary to keep a table of allocated address, original and	aligned, to support correct freeing.	It would seem simpler to use the Turbo-C function allocmem,	which always allocates aligned blocks.  However, allocmem	appears to conflict with the internal allocation of fopen	and other C library routines.*/void *sys_alloc_mem (      size_t   size     /* size in bytes to allocate */		    ){	int ix_save;      /* temp copy of table index */        void *addr;        /* addr returned by calloc (*void) */	word offset;      /* offset of unaligned address */	word seg;         /* segment addr of unaligned address */	void *addr_alig; /* aligned address */	int rem; /* temp for alignment computation */	/* ensure that allocation table is not full */	if (num_alloc >= MAX_ALLOC) {		return(NULL);	}	/* find free entry in allocation table */	ix_save = alloc_ix;	while (alloc_table[alloc_ix].original != NULL) {		alloc_ix++;		if (alloc_ix >= MAX_ALLOC) alloc_ix = 0;		/* safety check -- should never happen! */		if (alloc_ix == ix_save) return(NULL);	}	/* call allocation routine */	/* request 15 extra bytes to ensure alignment is possible */	addr = calloc(size + 15,1);	/* compute aligned base */	offset = FP_OFF(addr);        seg = FP_SEG(addr);	rem = offset % 16;	if (rem > 0) offset = offset + 16 - rem;	addr_alig = MK_FP(seg,offset);	/* insert entries in table */	alloc_table[alloc_ix].original = addr;	alloc_table[alloc_ix].aligned = addr_alig;	/* increment count */	num_alloc++;	return(addr_alig);}/*	Procedure: sys_free_mem	Purpose: free a memory block	Parameters:		void *ptr         ptr to block to allocate	Returns: integer error code; zero if OK		Calls:   free	Globals: alloc_table, num_alloc	Errors:  ERR_SUP_INVMEM    invalid memory block	This procedure receives an aligned address; it must	find and free the corresponding non-aligned one.*/int sys_free_mem (         void     *ptr     /* pointer to block */		 ){	void *free_addr;  /* true (unaligned) block address */	int free_ix;               /* temp table index */	/* ensure valid pointer */	if (ptr==NULL) return(ERR_SUP_INVMEM);	/* Look for the block in the allocation table */	free_addr = NULL;	for (free_ix=0; free_ix<MAX_ALLOC; free_ix++) {		if (alloc_table[free_ix].aligned == ptr) {			free_addr = alloc_table[free_ix].original;			break;		}	}	/* If the block wasn't found, report error */	if (free_addr == NULL) return(ERR_SUP_INVMEM);	/* free the block & clear the table entry */	alloc_table[free_ix].original = NULL;	alloc_table[free_ix].aligned = NULL;        free(free_addr);	/* decrement count */	num_alloc--;	return(OK);}        /*	Procedure: sys_get_date	Purpose: Returns the system date (month, day, year)	Parameters:		date_rec *date_p Pointer to structure of type date	Returns: void		Calls: none		Globals: sys_date        Errors: none*/void sys_get_date (  date_rec*      date_p   /* ptr to date record */		){	date_p->month = sys_date.da_mon;	date_p->day = sys_date.da_day;	date_p->year = sys_date.da_year;}/*	Procedure: sys_set_date	Purpose: Sets the system date (month, day, year)	Parameters:		date_rec *date_p ptr to structure of type date	Returns: error code; OK if no error	Calls:   none        Globals: sys_date	Errors: none*/int sys_set_date (  date_rec*       date_p   /* ptr to date record */		 ){	sys_date.da_mon = date_p->month;        sys_date.da_day = date_p->day;        sys_date.da_year = date_p->year;	return(OK);}/*	Procedure: sys_open_dir	Purpose: open a specified directory	Parameters: char dir_name[]            directory name	Returns: error code; zero if OK	Calls:   findfirst		strncpy  	Globals: current_path, file_block, num_entries	Errors:  ERR_SUP_DIROPN    directory open error		ERR_SUP_INVDIR    invalid directory*/int sys_open_dir (  char  path_name[]        /* directory name */		 ){        char temp_path[MAX_PATH_SIZE];	int res;        int len;        /* ensure there is no directory currently open */	if (current_path[0]!=NULCH) return(ERR_SUP_DIROPN);        /* check pathname for validity */        /* construct temporary search path name */	temp_path[0] = NULCH;	if (path_name != NULL) {		strncpy(temp_path,path_name,MAX_PATH_SIZE-4);	}	/* build wildcard search string */        len = strlen(temp_path);	/* if path is null, use current directory */        if (len==0) strcpy(temp_path,"*.*");	/* handle paths ending in backslash, including root */        else if (temp_path[len-1]=='\\') strcat(temp_path,"*.*");	/* handle paths not ending in backslash */        else strcat(temp_path,"\\*.*");	/* validate the directory by searching for either an ordinary	   file or a directory in it.  This should never fail; even	   empty directories contain the directories "." and ".."	*/		res = findfirst(temp_path, &file_block, FA_DIREC);	if (res!=0)  return(ERR_SUP_INVDIR);        /* save pathname as current, clear entry count */	current_path[0] = NULCH;	if (path_name != NULL) {		strncpy(current_path,path_name,MAX_PATH_SIZE-6);	}	num_entries = 0;	return(OK);}/*	Procedure: sys_get_entry	Purpose: get the next directory entry;	Parameters: char name_buf[]	name buffer		    int buf_size  	buffer capacity		    long *file_size_p	file length buffer         	Returns: error code, or zero if ok	Calls:	findfirst		findnext		strncpy, strcpy, strrchr, strcat    	Globals: current_path, num_entries, file_block	Errors:  ERR_SUP_NOENTR    no such entry*/int sys_get_entry (char    name_buf[],       /* buffer for entry */		   int   buf_size,         /* buffer size */		   long* file_size_p       /* buffer for size value */		  ){	char filename[MAX_PATH_SIZE+1];	int err;        int len;        char *cp;        /* find next MPX file entry, if any */        /* if this is the first call */	if (num_entries==0) {	       /* construct complete search path name */	       len = strlen(current_path);	       if (len==0) strcpy(current_path,"*.MPX");	       else if (current_path[len-1]=='\\') strcat(current_path,"*.MPX");	       else strcat(current_path,"\\*.MPX");	       /* find first entry */		err = findfirst (current_path,&file_block,0);        }        /* otherwise, find next entry */        else err = findnext(&file_block);        if (err<0) return(ERR_SUP_NOENTR);		/* ensure buf_size is not too large */		if (buf_size > MAX_PATH_SIZE) buf_size = MAX_PATH_SIZE;		      /* copy filename to buffer */	filename[buf_size] = NULCH;	strncpy (filename,file_block.ff_name,			 (size_t) buf_size);	/* remove ".MPX" from name */	cp = strrchr(filename, (int) '.');        *cp = NULCH;	/* copy name and size to caller's buffer */        strcpy (name_buf,filename);	*file_size_p = file_block.ff_fsize;        /* count entry */	num_entries++;	return(OK);}/*	Procedure: sys_close_dir	Purpose: close an open directory	Parameters: none	Returns: error code; zero if OK	Calls:   none	Globals: current_path	Errors:  none*/int sys_close_dir (void){	current_path[0] = NULCH;	return(OK);}/*	Procedure: sys_check_program	Purpose: locate and measure a program file	Parameters: see prototype	Returns: program size or error code	Calls:   strlen, strcat		fopen, fread	Globals: none	Errors:  ERR_SUP_NAMLNG    pathname too long		ERR_SUP_FILNFD    file not found		ERR_SUP_FILINV    file invalid*/#define HEADER_SIZE 32int sys_check_program(     char     dir_name[],       /* directory name */			char     prog_name[],      /* program name */			int*     prog_len_p,       /* ptr to prog length */			int*     start_offset_p    /* ptr to start offset */			){        /* buffer for full pathname */	char file_name[MAX_PATH_SIZE+1];        /* buffer for file header */        byte header[HEADER_SIZE];	FILE *file_p;     /* file pointer for C file routines */        int num_read;      /* number of header bytes read */	int file_size;    /* size of complete file */        int header_size;/* size of header */        int code_size;     /* size of program code */        int data_size;     /* size of program data */        int errcode;       /* error code */        /* ensure that path name is not too long */        if ((strlen(dir_name) + strlen(prog_name) + 5)		 > MAX_PATH_SIZE) return(ERR_SUP_NAMLNG);	/* construct path name */	file_name[0] = NULCH;	if (dir_name[0] != NULCH) {		strcat(file_name, dir_name);	        strcat(file_name, "\\");	}        strcat(file_name, prog_name);	strcat(file_name, ".MPX");        /* try to open the file */	errcode = OK;        file_p = fopen(file_name, "rb");        if (file_p == NULL) return(ERR_SUP_FILNFD);	/* read the header, check for EXE signature */        num_read = fread( (void*) header, 1, HEADER_SIZE, file_p);        if (num_read != HEADER_SIZE) {		errcode = ERR_SUP_FILINV;	}        else if ((header[0] != 0x4D) || (header[1] != 0x5A)) {		errcode = ERR_SUP_FILINV;	}        /* close the file, then return if error occurred */        fclose(file_p);	if (errcode!=OK) return(errcode);        /* compute allocation size needed */        file_size = (header[5]*256 + header[4] -1) * 512		+ (header[3]*256 + header[2]);        header_size =(header[9]*256 + header[8])*16;        code_size = file_size - header_size;        data_size = (header[11]*256 + header[10])*16;        /* return total length and starting offset */        *prog_len_p = code_size + data_size;	*start_offset_p = (header[23]*256 + header[22]) * 16;	return(OK);}/*	Procedure: sys_load_program	Purpose: load a program file	Parameters: see prototype	Returns: error code; zero if OK	Calls:   intdosx		segread		strlen, strcat	Globals: none 	Errors:  ERR_SUP_NAMLNG    name too long		ERR_SUP_FILNFD    file not found	       ERR_SUP_FILINV      file invalid		ERR_SUP_PROGSZ    program too large	       ERR_SUP_LDADDR      address not aligned		ERR_SUP_LDFAIL    load failed*/int sys_load_program (     void*    load_addr,        /* address for loading */			int      max_size,         /* memory size */			char     dir_name[],       /* directory name */			char     prog_name[]       /* program name */		      ){	int errcode;      /* error code */        int prog_len;      /* program length */	int offset;       /* offset for starting */	word norm_seg;    /* normalized load address segment */        word norm_off;     /* normalized load address offset */        /* full pathname for file to be loaded */	char file_name[MAX_PATH_SIZE+1];        /* parameter block for MSDOS EXEC function */	struct {		word load_seg;    /* segment address for loading */	       word reloc_seg;     /* segment address for relocation */        }p_block;	union REGS inregs;            /* input register structure */	union REGS outregs;           /* output register structure */	struct SREGS segregs;         /* segment register structure */        /* check program, get length and offset */	errcode = sys_check_program(dir_name, prog_name,					&prog_len, &offset);        if (errcode < 0) return(errcode);        /* ensure that allocated memory is large enough */        if (max_size < prog_len) return(ERR_SUP_PROGSZ);        /* get normalized segment and offset, check alignment */	norm_seg = FP_SEG(load_addr);	norm_off = FP_OFF(load_addr);	norm_seg += norm_off / 16;        norm_off %= 16;	if (norm_off != 0) return(ERR_SUP_LDADDR);        /* ensure that path name is not too long */        if ((strlen(dir_name) + strlen(prog_name) + 5)		 > MAX_PATH_SIZE) return(ERR_SUP_NAMLNG);	/* construct path name */	file_name[0] = NULCH;	if (dir_name[0] != NULCH) {		strcat(file_name, dir_name);	        strcat(file_name, "\\");	}        strcat(file_name, prog_name);	strcat(file_name, ".MPX");        /* get current segment regs */	segread(&segregs);        /* setup function codes */	inregs.h.ah = 0x4B;        /* EXEC function */	inregs.h.al = 0x03;        /* load only */        /* setup parameter block and name pointers */        segregs.ds = FP_SEG(&file_name);	inregs.x.dx = FP_OFF(&file_name);        segregs.es = FP_SEG(&p_block);	inregs.x.bx = FP_OFF(&p_block);        /* setup load segment -- must be normalized */	p_block.load_seg = norm_seg;	p_block.reloc_seg = p_block.load_seg;        /* call the MS-DOS loader */	errcode = intdosx(&inregs,&outregs,&segregs);        errcode = errcode;        /* check for error */	if (outregs.x.cflag) return(ERR_SUP_LDFAIL);	/* load successful */	return(OK);}/* END OF FILE */com_hand1,0
/***********************************************************************	MPX: The MultiProgramming eXecutive	Project to Accompany	A Practical Approach to Operating Systems	Malcolm G. Lane & James D. Mooney	Copyright 1993, P.W.S. Kent Publishing Co., Boston, MA.		File Name: mpx_supt.c	Authors: J.J. Patnesky, A. Ghosal, M. Lane, J. Mooney	Version: 2.1b	Date: 01/31/08	Purpose: Support routines for MPX-PC		Modules: all	Environment:      IBM-PC (XT, AT or PS/2)			MS-DOS 3.3 or later			TURBO-C 3.0 or TURBO-C++ 1.0 or later	Compile using the LARGE MODEL and SS NOT equal to DS.	All addresses and pointers are "far", and	CS, DS and SS are independent.	Procedures in this file:		sys_init		sys_exit		sys_set_vec		sys_req		sys_alloc_mem		sys_free_mem		sys_get_date		sys_set_date		sys_open_dir		sys_get_entry		sys_close_dir	       sys_check_program	       sys_load_program************************************************************************Change Log:	07/16/88  akg	added comments	02/25/92  jdm	full revision, UNIX version	04/14/92  jdm	Macintosh version	05/15/92  jdm	cleanup and documentation	07/14/92  jdm	update for revised specs        08/13/92  jdm 	revised IBM version; added private heap        10/14/92  jdm 	added check and load procedures        10/18/92  jdm 	revised sys_alloc_mem for alignment	11/17/92  jdm	true heap mgt, aligned, using calloc & free	11/19/92  jdm	enable device handling for final module	12/31/92  jdm	revised sys_req parameters	01/02/93  jdm	return count value after I/O	01/03/93  jdm	revised error names and codes	01/27/93  jdm	corrected count for line input in sys_req			fixed open_dir to handle null lines	02/24/93  jdm	changed sys_set_vec param to interrupt	03/08/93  jdm	corrections to sys_check & sys_load	03/20/93  jdm	stack switch in free, check, and load	04/22/93  jdm	corrected index conflict in sys_free_mem			added safety escape in alloc table search	07/28/93  jdm	conversion to large model	09/01/93  jdm	fixed allocation bug;  made date private	09/14/93  jdm	cleaned up memory allocation        09/16/93  jdm	adjusted program load for large model        09/30/93  jdm	modified for correct list of root directory	11/01/94  jdm	changed load file read to binary	09/18/95  jdm	fixed get_entry to default to current, not root	01/31/08  jdm   fixed possible overflow problem in get_entry************************************************************************/#include "mpx_supt.h"#include <stdlib.h>#include <dos.h>#include <dir.h>#include <errno.h>#include <conio.h>#include <alloc.h>#define VEC_ADDR (0x60L*4)#define MAX_ALLOC 200#define MAX_XPOS 79#define MAX_YPOS 24#define MAX_PATH_SIZE 50/*	System-dependent type definitions*/typedef unsigned char byte;typedef unsigned int word;typedef unsigned long longword;typedef byte *address;typedef struct params {	int      op_code;	int      device_id;	char     *buf_p;	int      *count_p;	} params;/*	Global variables accessed only by support routines*/	static longword vec_save;  /* saved interrupt vector */	static int mod_code;                /* module code */                                           	static struct date sys_date;        /* MPX system date */	/* data structures for directory access */        static char current_path[MAX_PATH_SIZE+1];        static int num_entries;        static struct ffblk file_block;        /* handler presence flags */	static flag sysc_hand;	static flag trm_hand;	static flag prt_hand;	static flag com_hand;        /* memory allocation table */	static struct {		void* original;		void* aligned;	} alloc_table[MAX_ALLOC];	static int alloc_ix;                /* current index */	static int num_alloc;               /* no. of allocated blocks *//*	Procedure: sys_init	Purpose: initialize mpx	Parameters: see prototype  	Return value: error code, or OK if no error	Calls: getdate    	Globals: mod_code		vec_save		sys_date		alloc_table, alloc_ix, num_alloc		sysc_hand, term_hand, prt_hand, com_hand	Errors: none*/int sys_init (    int      modules  /* module code */	     ){	mod_code = modules;        vec_save = 0L;        /* no handlers detected yet */	sysc_hand = FALSE;	trm_hand = FALSE;	prt_hand = FALSE;	com_hand = FALSE;	/* initialize allocation table */	for (alloc_ix=0; alloc_ix < MAX_ALLOC; alloc_ix++) {		alloc_table[alloc_ix].original = NULL;		alloc_table[alloc_ix].aligned = NULL;	}	alloc_ix = 0;	num_alloc = 0;	/* if we have reached Module R3, enable system call handling */	if (modules >= MODULE_R3) sysc_hand = TRUE;	/* if we have reached the final module, enable device handlers */	if (modules >= MODULE_F) {		trm_hand = TRUE;		prt_hand = TRUE;		com_hand = TRUE;	}	/* get system date */        getdate(&sys_date);	return (OK);}/*	Procedure: sys_exit	Purpose: terminate mpx	Parameters: none  	Return value: none	Calls: none       	Globals: vec_save*/void sys_exit(void){	longword *vec_p;	/* if trap vector changed, restore it */	if (vec_save != 0L) {		vec_p = (longword*) VEC_ADDR;		*vec_p = vec_save;	}	/* return to host with null error code */	exit(0);}/*	Procedure: sys_set_vec	Purpose: link trap vector to MPX system call handler	Parameters: handler: addr of handler         	Return value: error code; OK if no error	Calls: none       	Globals: vec_save	Errors: none*/int sys_set_vec   ( void interrupt (*handler)() /* system call handler */		){	longword *vec_p;			vec_p = (longword*) VEC_ADDR;		vec_save = *vec_p;		*vec_p = (longword) handler;	return (0);}/*	Procedure: sys_req	Purpose: Request a system service	Inputs:		op_code           operation code		device_id         device identifier		buf_p             addresso f data buffer		count_p           address of size of buffer	Returns: Result or error code, depending on service		Services supported:	IDLE     null operation				READ     input from a device				WRITE    output to a device				CLEAR    clear terminal screen				GOTOXY   absolute cursor position				EXIT     terminate the caller	Calls:   fgets		strlen			Globals: none		Errors:  ERR_SUP_INVDEV    invalid device		ERR_SUP_INVOPC    invalid operation code		ERR_SUP_INVPOS    invalid character position		ERR_SUP_RDFAIL    read failed		ERR_SUP_WRFAIL    write failed	Description:	For Modules R1 through R4,	this procedure is used only for terminal I/O.	Later modules support both reading and	writing for several devices.	For Modules R1 through R4,	sys_req uses the ANSI C function "fgets."	Later modules may use alternate functions and device drivers.*/int sys_req (   int      op_code, /* operation code */		int      device_id,        /* device id */		char*    buf_p,            /* I/O buffer */		int*     count_p           /* address of count */		){	int      rval;    /* result or error code */	char     *rp;     /* return pointer for fgets */	char     rc;      /* return char for fputc */        params    *param_p; /* pointer to parameter record in stack */	flag     docall;  /* true if system call interrupt wanted */	int      ix;      /* temporary index */	docall = FALSE;	rval = OK;	switch (op_code) {		case IDLE:		if (sysc_hand) docall = TRUE;		break; 				case READ:		switch (device_id) {				case TERMINAL:			if (trm_hand) docall = TRUE;			else {				rp = fgets(buf_p,*count_p,stdin);				if (rp==NULL) rval = ERR_SUP_RDFAIL;				else rval = strlen(buf_p);			}			break;					case COM_PORT:			if (com_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					default:			rval = ERR_SUP_INVDEV;					}		break;	case WRITE:		switch (device_id) {				case TERMINAL:			if (trm_hand) docall = TRUE;			else {				rval = *count_p;				for (ix=0; ix<*count_p; ix++) {					rc = fputc(buf_p[ix],stdout);					if (rc == EOF) {						rval = ERR_SUP_WRFAIL;						break;					}				}			}			break;					case COM_PORT:			if (com_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					case PRINTER:			if (prt_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					default:			rval = ERR_SUP_INVDEV;					}		break;	case CLEAR:		if (device_id==TERMINAL) {			if (trm_hand) docall = TRUE;			else {			     clrscr();				rval = 0;			}		}		else rval = ERR_SUP_INVDEV;		break;			case GOTOXY:		if (device_id==TERMINAL) {			if (trm_hand) docall = TRUE;			else {				if (*count_p != 2) rval = ERR_SUP_WRFAIL;				else if ((*buf_p<0)					|| (*buf_p > MAX_XPOS))					rval = ERR_SUP_WRFAIL;				else if ((*(buf_p+1)<0)					|| (*(buf_p+1) > MAX_YPOS))					rval = ERR_SUP_WRFAIL;				else {					gotoxy(*buf_p + 1,						*(buf_p+1) + 1);					rval = 0;				}			}		}		else rval = ERR_SUP_INVDEV;		break;			/* EXIT - terminate the calling process */	/* legal only when a system call handler is present */	case EXIT:		if (sysc_hand) docall = TRUE;		else rval = ERR_SUP_INVOPC;		break; 	default:		rval = ERR_SUP_INVOPC;			}		/* Invoke user's call handler if present.	   If the call is an IO request, return will occur	   only after the request is complete.	*/	if (docall && (rval==OK)) {		/* invoke the call handler */	_SP = _SP - sizeof(params);		param_p = (params*) MK_FP(_SS,_SP);	       param_p->op_code = op_code;	       param_p->device_id = device_id;	       param_p->buf_p = buf_p;	       param_p->count_p = count_p;	       geninterrupt(0x60);	       rval = _AX;	       _SP = _SP + sizeof(params);		/* for I/O operations, return count value */		switch(op_code) {		case READ:		case WRITE:		case CLEAR:		case GOTOXY:			rval = *count_p;		}	}	return(rval);}/*	Procedure: sys_alloc_mem	Purpose: Allocate a memory block	Parameters:			size_t size       No. of bytes to allocate	Returns: void* pointer to allocated block;		 null pointer in case of error		 	Calls: calloc		Globals: alloc_table, alloc_ix, num_alloc	For program loading (Module R-4), the blocks must be aligned.	This is achieved by requesting one extra paragraph and	returning the lowest aligned address as the base.  It is	necessary to keep a table of allocated address, original and	aligned, to support correct freeing.	It would seem simpler to use the Turbo-C function allocmem,	which always allocates aligned blocks.  However, allocmem	appears to conflict with the internal allocation of fopen	and other C library routines.*/void *sys_alloc_mem (      size_t   size     /* size in bytes to allocate */		    ){	int ix_save;      /* temp copy of table index */        void *addr;        /* addr returned by calloc (*void) */	word offset;      /* offset of unaligned address */	word seg;         /* segment addr of unaligned address */	void *addr_alig; /* aligned address */	int rem; /* temp for alignment computation */	/* ensure that allocation table is not full */	if (num_alloc >= MAX_ALLOC) {		return(NULL);	}	/* find free entry in allocation table */	ix_save = alloc_ix;	while (alloc_table[alloc_ix].original != NULL) {		alloc_ix++;		if (alloc_ix >= MAX_ALLOC) alloc_ix = 0;		/* safety check -- should never happen! */		if (alloc_ix == ix_save) return(NULL);	}	/* call allocation routine */	/* request 15 extra bytes to ensure alignment is possible */	addr = calloc(size + 15,1);	/* compute aligned base */	offset = FP_OFF(addr);        seg = FP_SEG(addr);	rem = offset % 16;	if (rem > 0) offset = offset + 16 - rem;	addr_alig = MK_FP(seg,offset);	/* insert entries in table */	alloc_table[alloc_ix].original = addr;	alloc_table[alloc_ix].aligned = addr_alig;	/* increment count */	num_alloc++;	return(addr_alig);}/*	Procedure: sys_free_mem	Purpose: free a memory block	Parameters:		void *ptr         ptr to block to allocate	Returns: integer error code; zero if OK		Calls:   free	Globals: alloc_table, num_alloc	Errors:  ERR_SUP_INVMEM    invalid memory block	This procedure receives an aligned address; it must	find and free the corresponding non-aligned one.*/int sys_free_mem (         void     *ptr     /* pointer to block */		 ){	void *free_addr;  /* true (unaligned) block address */	int free_ix;               /* temp table index */	/* ensure valid pointer */	if (ptr==NULL) return(ERR_SUP_INVMEM);	/* Look for the block in the allocation table */	free_addr = NULL;	for (free_ix=0; free_ix<MAX_ALLOC; free_ix++) {		if (alloc_table[free_ix].aligned == ptr) {			free_addr = alloc_table[free_ix].original;			break;		}	}	/* If the block wasn't found, report error */	if (free_addr == NULL) return(ERR_SUP_INVMEM);	/* free the block & clear the table entry */	alloc_table[free_ix].original = NULL;	alloc_table[free_ix].aligned = NULL;        free(free_addr);	/* decrement count */	num_alloc--;	return(OK);}        /*	Procedure: sys_get_date	Purpose: Returns the system date (month, day, year)	Parameters:		date_rec *date_p Pointer to structure of type date	Returns: void		Calls: none		Globals: sys_date        Errors: none*/void sys_get_date (  date_rec*      date_p   /* ptr to date record */		){	date_p->month = sys_date.da_mon;	date_p->day = sys_date.da_day;	date_p->year = sys_date.da_year;}/*	Procedure: sys_set_date	Purpose: Sets the system date (month, day, year)	Parameters:		date_rec *date_p ptr to structure of type date	Returns: error code; OK if no error	Calls:   none        Globals: sys_date	Errors: none*/int sys_set_date (  date_rec*       date_p   /* ptr to date record */		 ){	sys_date.da_mon = date_p->month;        sys_date.da_day = date_p->day;        sys_date.da_year = date_p->year;	return(OK);}/*	Procedure: sys_open_dir	Purpose: open a specified directory	Parameters: char dir_name[]            directory name	Returns: error code; zero if OK	Calls:   findfirst		strncpy  	Globals: current_path, file_block, num_entries	Errors:  ERR_SUP_DIROPN    directory open error		ERR_SUP_INVDIR    invalid directory*/int sys_open_dir (  char  path_name[]        /* directory name */		 ){        char temp_path[MAX_PATH_SIZE];	int res;        int len;        /* ensure there is no directory currently open */	if (current_path[0]!=NULCH) return(ERR_SUP_DIROPN);        /* check pathname for validity */        /* construct temporary search path name */	temp_path[0] = NULCH;	if (path_name != NULL) {		strncpy(temp_path,path_name,MAX_PATH_SIZE-4);	}	/* build wildcard search string */        len = strlen(temp_path);	/* if path is null, use current directory */        if (len==0) strcpy(temp_path,"*.*");	/* handle paths ending in backslash, including root */        else if (temp_path[len-1]=='\\') strcat(temp_path,"*.*");	/* handle paths not ending in backslash */        else strcat(temp_path,"\\*.*");	/* validate the directory by searching for either an ordinary	   file or a directory in it.  This should never fail; even	   empty directories contain the directories "." and ".."	*/		res = findfirst(temp_path, &file_block, FA_DIREC);	if (res!=0)  return(ERR_SUP_INVDIR);        /* save pathname as current, clear entry count */	current_path[0] = NULCH;	if (path_name != NULL) {		strncpy(current_path,path_name,MAX_PATH_SIZE-6);	}	num_entries = 0;	return(OK);}/*	Procedure: sys_get_entry	Purpose: get the next directory entry;	Parameters: char name_buf[]	name buffer		    int buf_size  	buffer capacity		    long *file_size_p	file length buffer         	Returns: error code, or zero if ok	Calls:	findfirst		findnext		strncpy, strcpy, strrchr, strcat    	Globals: current_path, num_entries, file_block	Errors:  ERR_SUP_NOENTR    no such entry*/int sys_get_entry (char    name_buf[],       /* buffer for entry */		   int   buf_size,         /* buffer size */		   long* file_size_p       /* buffer for size value */		  ){	char filename[MAX_PATH_SIZE+1];	int err;        int len;        char *cp;        /* find next MPX file entry, if any */        /* if this is the first call */	if (num_entries==0) {	       /* construct complete search path name */	       len = strlen(current_path);	       if (len==0) strcpy(current_path,"*.MPX");	       else if (current_path[len-1]=='\\') strcat(current_path,"*.MPX");	       else strcat(current_path,"\\*.MPX");	       /* find first entry */		err = findfirst (current_path,&file_block,0);        }        /* otherwise, find next entry */        else err = findnext(&file_block);        if (err<0) return(ERR_SUP_NOENTR);		/* ensure buf_size is not too large */		if (buf_size > MAX_PATH_SIZE) buf_size = MAX_PATH_SIZE;		      /* copy filename to buffer */	filename[buf_size] = NULCH;	strncpy (filename,file_block.ff_name,			 (size_t) buf_size);	/* remove ".MPX" from name */	cp = strrchr(filename, (int) '.');        *cp = NULCH;	/* copy name and size to caller's buffer */        strcpy (name_buf,filename);	*file_size_p = file_block.ff_fsize;        /* count entry */	num_entries++;	return(OK);}/*	Procedure: sys_close_dir	Purpose: close an open directory	Parameters: none	Returns: error code; zero if OK	Calls:   none	Globals: current_path	Errors:  none*/int sys_close_dir (void){	current_path[0] = NULCH;	return(OK);}/*	Procedure: sys_check_program	Purpose: locate and measure a program file	Parameters: see prototype	Returns: program size or error code	Calls:   strlen, strcat		fopen, fread	Globals: none	Errors:  ERR_SUP_NAMLNG    pathname too long		ERR_SUP_FILNFD    file not found		ERR_SUP_FILINV    file invalid*/#define HEADER_SIZE 32int sys_check_program(     char     dir_name[],       /* directory name */			char     prog_name[],      /* program name */			int*     prog_len_p,       /* ptr to prog length */			int*     start_offset_p    /* ptr to start offset */			){        /* buffer for full pathname */	char file_name[MAX_PATH_SIZE+1];        /* buffer for file header */        byte header[HEADER_SIZE];	FILE *file_p;     /* file pointer for C file routines */        int num_read;      /* number of header bytes read */	int file_size;    /* size of complete file */        int header_size;/* size of header */        int code_size;     /* size of program code */        int data_size;     /* size of program data */        int errcode;       /* error code */        /* ensure that path name is not too long */        if ((strlen(dir_name) + strlen(prog_name) + 5)		 > MAX_PATH_SIZE) return(ERR_SUP_NAMLNG);	/* construct path name */	file_name[0] = NULCH;	if (dir_name[0] != NULCH) {		strcat(file_name, dir_name);	        strcat(file_name, "\\");	}        strcat(file_name, prog_name);	strcat(file_name, ".MPX");        /* try to open the file */	errcode = OK;        file_p = fopen(file_name, "rb");        if (file_p == NULL) return(ERR_SUP_FILNFD);	/* read the header, check for EXE signature */        num_read = fread( (void*) header, 1, HEADER_SIZE, file_p);        if (num_read != HEADER_SIZE) {		errcode = ERR_SUP_FILINV;	}        else if ((header[0] != 0x4D) || (header[1] != 0x5A)) {		errcode = ERR_SUP_FILINV;	}        /* close the file, then return if error occurred */        fclose(file_p);	if (errcode!=OK) return(errcode);        /* compute allocation size needed */        file_size = (header[5]*256 + header[4] -1) * 512		+ (header[3]*256 + header[2]);        header_size =(header[9]*256 + header[8])*16;        code_size = file_size - header_size;        data_size = (header[11]*256 + header[10])*16;        /* return total length and starting offset */        *prog_len_p = code_size + data_size;	*start_offset_p = (header[23]*256 + header[22]) * 16;	return(OK);}/*	Procedure: sys_load_program	Purpose: load a program file	Parameters: see prototype	Returns: error code; zero if OK	Calls:   intdosx		segread		strlen, strcat	Globals: none 	Errors:  ERR_SUP_NAMLNG    name too long		ERR_SUP_FILNFD    file not found	       ERR_SUP_FILINV      file invalid		ERR_SUP_PROGSZ    program too large	       ERR_SUP_LDADDR      address not aligned		ERR_SUP_LDFAIL    load failed*/int sys_load_program (     void*    load_addr,        /* address for loading */			int      max_size,         /* memory size */			char     dir_name[],       /* directory name */			char     prog_name[]       /* program name */		      ){	int errcode;      /* error code */        int prog_len;      /* program length */	int offset;       /* offset for starting */	word norm_seg;    /* normalized load address segment */        word norm_off;     /* normalized load address offset */        /* full pathname for file to be loaded */	char file_name[MAX_PATH_SIZE+1];        /* parameter block for MSDOS EXEC function */	struct {		word load_seg;    /* segment address for loading */	       word reloc_seg;     /* segment address for relocation */        }p_block;	union REGS inregs;            /* input register structure */	union REGS outregs;           /* output register structure */	struct SREGS segregs;         /* segment register structure */        /* check program, get length and offset */	errcode = sys_check_program(dir_name, prog_name,					&prog_len, &offset);        if (errcode < 0) return(errcode);        /* ensure that allocated memory is large enough */        if (max_size < prog_len) return(ERR_SUP_PROGSZ);        /* get normalized segment and offset, check alignment */	norm_seg = FP_SEG(load_addr);	norm_off = FP_OFF(load_addr);	norm_seg += norm_off / 16;        norm_off %= 16;	if (norm_off != 0) return(ERR_SUP_LDADDR);        /* ensure that path name is not too long */        if ((strlen(dir_name) + strlen(prog_name) + 5)		 > MAX_PATH_SIZE) return(ERR_SUP_NAMLNG);	/* construct path name */	file_name[0] = NULCH;	if (dir_name[0] != NULCH) {		strcat(file_name, dir_name);	        strcat(file_name, "\\");	}        strcat(file_name, prog_name);	strcat(file_name, ".MPX");        /* get current segment regs */	segread(&segregs);        /* setup function codes */	inregs.h.ah = 0x4B;        /* EXEC function */	inregs.h.al = 0x03;        /* load only */        /* setup parameter block and name pointers */        segregs.ds = FP_SEG(&file_name);	inregs.x.dx = FP_OFF(&file_name);        segregs.es = FP_SEG(&p_block);	inregs.x.bx = FP_OFF(&p_block);        /* setup load segment -- must be normalized */	p_block.load_seg = norm_seg;	p_block.reloc_seg = p_block.load_seg;        /* call the MS-DOS loader */	errcode = intdosx(&inregs,&outregs,&segregs);        errcode = errcode;        /* check for error */	if (outregs.x.cflag) return(ERR_SUP_LDFAIL);	/* load successful */	return(OK);}/* END OF FILE */original1,0
/***********************************************************************	MPX: The MultiProgramming eXecutive	Project to Accompany	A Practical Approach to Operating Systems	Malcolm G. Lane & James D. Mooney	Copyright 1993, P.W.S. Kent Publishing Co., Boston, MA.		File Name: mpx_supt.c	Authors: J.J. Patnesky, A. Ghosal, M. Lane, J. Mooney	Version: 2.1b	Date: 01/31/08	Purpose: Support routines for MPX-PC		Modules: all	Environment:      IBM-PC (XT, AT or PS/2)			MS-DOS 3.3 or later			TURBO-C 3.0 or TURBO-C++ 1.0 or later	Compile using the LARGE MODEL and SS NOT equal to DS.	All addresses and pointers are "far", and	CS, DS and SS are independent.	Procedures in this file:		sys_init		sys_exit		sys_set_vec		sys_req		sys_alloc_mem		sys_free_mem		sys_get_date		sys_set_date		sys_open_dir		sys_get_entry		sys_close_dir	       sys_check_program	       sys_load_program************************************************************************Change Log:	07/16/88  akg	added comments	02/25/92  jdm	full revision, UNIX version	04/14/92  jdm	Macintosh version	05/15/92  jdm	cleanup and documentation	07/14/92  jdm	update for revised specs        08/13/92  jdm 	revised IBM version; added private heap        10/14/92  jdm 	added check and load procedures        10/18/92  jdm 	revised sys_alloc_mem for alignment	11/17/92  jdm	true heap mgt, aligned, using calloc & free	11/19/92  jdm	enable device handling for final module	12/31/92  jdm	revised sys_req parameters	01/02/93  jdm	return count value after I/O	01/03/93  jdm	revised error names and codes	01/27/93  jdm	corrected count for line input in sys_req			fixed open_dir to handle null lines	02/24/93  jdm	changed sys_set_vec param to interrupt	03/08/93  jdm	corrections to sys_check & sys_load	03/20/93  jdm	stack switch in free, check, and load	04/22/93  jdm	corrected index conflict in sys_free_mem			added safety escape in alloc table search	07/28/93  jdm	conversion to large model	09/01/93  jdm	fixed allocation bug;  made date private	09/14/93  jdm	cleaned up memory allocation        09/16/93  jdm	adjusted program load for large model        09/30/93  jdm	modified for correct list of root directory	11/01/94  jdm	changed load file read to binary	09/18/95  jdm	fixed get_entry to default to current, not root	01/31/08  jdm   fixed possible overflow problem in get_entry************************************************************************/#include "mpx_supt.h"#include <stdlib.h>#include <dos.h>#include <dir.h>#include <errno.h>#include <conio.h>#include <alloc.h>#define VEC_ADDR (0x60L*4)#define MAX_ALLOC 200#define MAX_XPOS 79#define MAX_YPOS 24#define MAX_PATH_SIZE 50/*	System-dependent type definitions*/typedef unsigned char byte;typedef unsigned int word;typedef unsigned long longword;typedef byte *address;typedef struct params {	int      op_code;	int      device_id;	char     *buf_p;	int      *count_p;	} params;/*	Global variables accessed only by support routines*/	static longword vec_save;  /* saved interrupt vector */	static int mod_code;                /* module code */                                           	static struct date sys_date;        /* MPX system date */	/* data structures for directory access */        static char current_path[MAX_PATH_SIZE+1];        static int num_entries;        static struct ffblk file_block;        /* handler presence flags */	static flag sysc_hand;	static flag trm_hand;	static flag prt_hand;	static flag com_hand;        /* memory allocation table */	static struct {		void* original;		void* aligned;	} alloc_table[MAX_ALLOC];	static int alloc_ix;                /* current index */	static int num_alloc;               /* no. of allocated blocks *//*	Procedure: sys_init	Purpose: initialize mpx	Parameters: see prototype  	Return value: error code, or OK if no error	Calls: getdate    	Globals: mod_code		vec_save		sys_date		alloc_table, alloc_ix, num_alloc		sysc_hand, term_hand, prt_hand, com_hand	Errors: none*/int sys_init (    int      modules  /* module code */	     ){	mod_code = modules;        vec_save = 0L;        /* no handlers detected yet */	sysc_hand = FALSE;	trm_hand = FALSE;	prt_hand = FALSE;	com_hand = FALSE;	/* initialize allocation table */	for (alloc_ix=0; alloc_ix < MAX_ALLOC; alloc_ix++) {		alloc_table[alloc_ix].original = NULL;		alloc_table[alloc_ix].aligned = NULL;	}	alloc_ix = 0;	num_alloc = 0;	/* if we have reached Module R3, enable system call handling */	if (modules >= MODULE_R3) sysc_hand = TRUE;	/* if we have reached the final module, enable device handlers */	if (modules >= MODULE_F) {		trm_hand = TRUE;		prt_hand = TRUE;		com_hand = TRUE;	}	/* get system date */        getdate(&sys_date);	return (OK);}/*	Procedure: sys_exit	Purpose: terminate mpx	Parameters: none  	Return value: none	Calls: none       	Globals: vec_save*/void sys_exit(void){	longword *vec_p;	/* if trap vector changed, restore it */	if (vec_save != 0L) {		vec_p = (longword*) VEC_ADDR;		*vec_p = vec_save;	}	/* return to host with null error code */	exit(0);}/*	Procedure: sys_set_vec	Purpose: link trap vector to MPX system call handler	Parameters: handler: addr of handler         	Return value: error code; OK if no error	Calls: none       	Globals: vec_save	Errors: none*/int sys_set_vec   ( void interrupt (*handler)() /* system call handler */		){	longword *vec_p;			vec_p = (longword*) VEC_ADDR;		vec_save = *vec_p;		*vec_p = (longword) handler;	return (0);}/*	Procedure: sys_req	Purpose: Request a system service	Inputs:		op_code           operation code		device_id         device identifier		buf_p             addresso f data buffer		count_p           address of size of buffer	Returns: Result or error code, depending on service		Services supported:	IDLE     null operation				READ     input from a device				WRITE    output to a device				CLEAR    clear terminal screen				GOTOXY   absolute cursor position				EXIT     terminate the caller	Calls:   fgets		strlen			Globals: none		Errors:  ERR_SUP_INVDEV    invalid device		ERR_SUP_INVOPC    invalid operation code		ERR_SUP_INVPOS    invalid character position		ERR_SUP_RDFAIL    read failed		ERR_SUP_WRFAIL    write failed	Description:	For Modules R1 through R4,	this procedure is used only for terminal I/O.	Later modules support both reading and	writing for several devices.	For Modules R1 through R4,	sys_req uses the ANSI C function "fgets."	Later modules may use alternate functions and device drivers.*/int sys_req (   int      op_code, /* operation code */		int      device_id,        /* device id */		char*    buf_p,            /* I/O buffer */		int*     count_p           /* address of count */		){	int      rval;    /* result or error code */	char     *rp;     /* return pointer for fgets */	char     rc;      /* return char for fputc */        params    *param_p; /* pointer to parameter record in stack */	flag     docall;  /* true if system call interrupt wanted */	int      ix;      /* temporary index */	docall = FALSE;	rval = OK;	switch (op_code) {		case IDLE:		if (sysc_hand) docall = TRUE;		break; 				case READ:		switch (device_id) {				case TERMINAL:			if (trm_hand) docall = TRUE;			else {				rp = fgets(buf_p,*count_p,stdin);				if (rp==NULL) rval = ERR_SUP_RDFAIL;				else rval = strlen(buf_p);			}			break;					case COM_PORT:			if (com_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					default:			rval = ERR_SUP_INVDEV;					}		break;	case WRITE:		switch (device_id) {				case TERMINAL:			if (trm_hand) docall = TRUE;			else {				rval = *count_p;				for (ix=0; ix<*count_p; ix++) {					rc = fputc(buf_p[ix],stdout);					if (rc == EOF) {						rval = ERR_SUP_WRFAIL;						break;					}				}			}			break;					case COM_PORT:			if (com_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					case PRINTER:			if (prt_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					default:			rval = ERR_SUP_INVDEV;					}		break;	case CLEAR:		if (device_id==TERMINAL) {			if (trm_hand) docall = TRUE;			else {			     clrscr();				rval = 0;			}		}		else rval = ERR_SUP_INVDEV;		break;			case GOTOXY:		if (device_id==TERMINAL) {			if (trm_hand) docall = TRUE;			else {				if (*count_p != 2) rval = ERR_SUP_WRFAIL;				else if ((*buf_p<0)					|| (*buf_p > MAX_XPOS))					rval = ERR_SUP_WRFAIL;				else if ((*(buf_p+1)<0)					|| (*(buf_p+1) > MAX_YPOS))					rval = ERR_SUP_WRFAIL;				else {					gotoxy(*buf_p + 1,						*(buf_p+1) + 1);					rval = 0;				}			}		}		else rval = ERR_SUP_INVDEV;		break;			/* EXIT - terminate the calling process */	/* legal only when a system call handler is present */	case EXIT:		if (sysc_hand) docall = TRUE;		else rval = ERR_SUP_INVOPC;		break; 	default:		rval = ERR_SUP_INVOPC;			}		/* Invoke user's call handler if present.	   If the call is an IO request, return will occur	   only after the request is complete.	*/	if (docall && (rval==OK)) {		/* invoke the call handler */	_SP = _SP - sizeof(params);		param_p = (params*) MK_FP(_SS,_SP);	       param_p->op_code = op_code;	       param_p->device_id = device_id;	       param_p->buf_p = buf_p;	       param_p->count_p = count_p;	       geninterrupt(0x60);	       rval = _AX;	       _SP = _SP + sizeof(params);		/* for I/O operations, return count value */		switch(op_code) {		case READ:		case WRITE:		case CLEAR:		case GOTOXY:			rval = *count_p;		}	}	return(rval);}/*	Procedure: sys_alloc_mem	Purpose: Allocate a memory block	Parameters:			size_t size       No. of bytes to allocate	Returns: void* pointer to allocated block;		 null pointer in case of error		 	Calls: calloc		Globals: alloc_table, alloc_ix, num_alloc	For program loading (Module R-4), the blocks must be aligned.	This is achieved by requesting one extra paragraph and	returning the lowest aligned address as the base.  It is	necessary to keep a table of allocated address, original and	aligned, to support correct freeing.	It would seem simpler to use the Turbo-C function allocmem,	which always allocates aligned blocks.  However, allocmem	appears to conflict with the internal allocation of fopen	and other C library routines.*/void *sys_alloc_mem (      size_t   size     /* size in bytes to allocate */		    ){	int ix_save;      /* temp copy of table index */        void *addr;        /* addr returned by calloc (*void) */	word offset;      /* offset of unaligned address */	word seg;         /* segment addr of unaligned address */	void *addr_alig; /* aligned address */	int rem; /* temp for alignment computation */	/* ensure that allocation table is not full */	if (num_alloc >= MAX_ALLOC) {		return(NULL);	}	/* find free entry in allocation table */	ix_save = alloc_ix;	while (alloc_table[alloc_ix].original != NULL) {		alloc_ix++;		if (alloc_ix >= MAX_ALLOC) alloc_ix = 0;		/* safety check -- should never happen! */		if (alloc_ix == ix_save) return(NULL);	}	/* call allocation routine */	/* request 15 extra bytes to ensure alignment is possible */	addr = calloc(size + 15,1);	/* compute aligned base */	offset = FP_OFF(addr);        seg = FP_SEG(addr);	rem = offset % 16;	if (rem > 0) offset = offset + 16 - rem;	addr_alig = MK_FP(seg,offset);	/* insert entries in table */	alloc_table[alloc_ix].original = addr;	alloc_table[alloc_ix].aligned = addr_alig;	/* increment count */	num_alloc++;	return(addr_alig);}/*	Procedure: sys_free_mem	Purpose: free a memory block	Parameters:		void *ptr         ptr to block to allocate	Returns: integer error code; zero if OK		Calls:   free	Globals: alloc_table, num_alloc	Errors:  ERR_SUP_INVMEM    invalid memory block	This procedure receives an aligned address; it must	find and free the corresponding non-aligned one.*/int sys_free_mem (         void     *ptr     /* pointer to block */		 ){	void *free_addr;  /* true (unaligned) block address */	int free_ix;               /* temp table index */	/* ensure valid pointer */	if (ptr==NULL) return(ERR_SUP_INVMEM);	/* Look for the block in the allocation table */	free_addr = NULL;	for (free_ix=0; free_ix<MAX_ALLOC; free_ix++) {		if (alloc_table[free_ix].aligned == ptr) {			free_addr = alloc_table[free_ix].original;			break;		}	}	/* If the block wasn't found, report error */	if (free_addr == NULL) return(ERR_SUP_INVMEM);	/* free the block & clear the table entry */	alloc_table[free_ix].original = NULL;	alloc_table[free_ix].aligned = NULL;        free(free_addr);	/* decrement count */	num_alloc--;	return(OK);}        /*	Procedure: sys_get_date	Purpose: Returns the system date (month, day, year)	Parameters:		date_rec *date_p Pointer to structure of type date	Returns: void		Calls: none		Globals: sys_date        Errors: none*/void sys_get_date (  date_rec*      date_p   /* ptr to date record */		){	date_p->month = sys_date.da_mon;	date_p->day = sys_date.da_day;	date_p->year = sys_date.da_year;}/*	Procedure: sys_set_date	Purpose: Sets the system date (month, day, year)	Parameters:		date_rec *date_p ptr to structure of type date	Returns: error code; OK if no error	Calls:   none        Globals: sys_date	Errors: none*/int sys_set_date (  date_rec*       date_p   /* ptr to date record */		 ){	sys_date.da_mon = date_p->month;        sys_date.da_day = date_p->day;        sys_date.da_year = date_p->year;	return(OK);}/*	Procedure: sys_open_dir	Purpose: open a specified directory	Parameters: char dir_name[]            directory name	Returns: error code; zero if OK	Calls:   findfirst		strncpy  	Globals: current_path, file_block, num_entries	Errors:  ERR_SUP_DIROPN    directory open error		ERR_SUP_INVDIR    invalid directory*/int sys_open_dir (  char  path_name[]        /* directory name */		 ){        char temp_path[MAX_PATH_SIZE];	int res;        int len;        /* ensure there is no directory currently open */	if (current_path[0]!=NULCH) return(ERR_SUP_DIROPN);        /* check pathname for validity */        /* construct temporary search path name */	temp_path[0] = NULCH;	if (path_name != NULL) {		strncpy(temp_path,path_name,MAX_PATH_SIZE-4);	}	/* build wildcard search string */        len = strlen(temp_path);	/* if path is null, use current directory */        if (len==0) strcpy(temp_path,"*.*");	/* handle paths ending in backslash, including root */        else if (temp_path[len-1]=='\\') strcat(temp_path,"*.*");	/* handle paths not ending in backslash */        else strcat(temp_path,"\\*.*");	/* validate the directory by searching for either an ordinary	   file or a directory in it.  This should never fail; even	   empty directories contain the directories "." and ".."	*/		res = findfirst(temp_path, &file_block, FA_DIREC);	if (res!=0)  return(ERR_SUP_INVDIR);        /* save pathname as current, clear entry count */	current_path[0] = NULCH;	if (path_name != NULL) {		strncpy(current_path,path_name,MAX_PATH_SIZE-6);	}	num_entries = 0;	return(OK);}/*	Procedure: sys_get_entry	Purpose: get the next directory entry;	Parameters: char name_buf[]	name buffer		    int buf_size  	buffer capacity		    long *file_size_p	file length buffer         	Returns: error code, or zero if ok	Calls:	findfirst		findnext		strncpy, strcpy, strrchr, strcat    	Globals: current_path, num_entries, file_block	Errors:  ERR_SUP_NOENTR    no such entry*/int sys_get_entry (char    name_buf[],       /* buffer for entry */		   int   buf_size,         /* buffer size */		   long* file_size_p       /* buffer for size value */		  ){	char filename[MAX_PATH_SIZE+1];	int err;        int len;        char *cp;        /* find next MPX file entry, if any */        /* if this is the first call */	if (num_entries==0) {	       /* construct complete search path name */	       len = strlen(current_path);	       if (len==0) strcpy(current_path,"*.MPX");	       else if (current_path[len-1]=='\\') strcat(current_path,"*.MPX");	       else strcat(current_path,"\\*.MPX");	       /* find first entry */		err = findfirst (current_path,&file_block,0);        }        /* otherwise, find next entry */        else err = findnext(&file_block);        if (err<0) return(ERR_SUP_NOENTR);		/* ensure buf_size is not too large */		if (buf_size > MAX_PATH_SIZE) buf_size = MAX_PATH_SIZE;		      /* copy filename to buffer */	filename[buf_size] = NULCH;	strncpy (filename,file_block.ff_name,			 (size_t) buf_size);	/* remove ".MPX" from name */	cp = strrchr(filename, (int) '.');        *cp = NULCH;	/* copy name and size to caller's buffer */        strcpy (name_buf,filename);	*file_size_p = file_block.ff_fsize;        /* count entry */	num_entries++;	return(OK);}/*	Procedure: sys_close_dir	Purpose: close an open directory	Parameters: none	Returns: error code; zero if OK	Calls:   none	Globals: current_path	Errors:  none*/int sys_close_dir (void){	current_path[0] = NULCH;	return(OK);}/*	Procedure: sys_check_program	Purpose: locate and measure a program file	Parameters: see prototype	Returns: program size or error code	Calls:   strlen, strcat		fopen, fread	Globals: none	Errors:  ERR_SUP_NAMLNG    pathname too long		ERR_SUP_FILNFD    file not found		ERR_SUP_FILINV    file invalid*/#define HEADER_SIZE 32int sys_check_program(     char     dir_name[],       /* directory name */			char     prog_name[],      /* program name */			int*     prog_len_p,       /* ptr to prog length */			int*     start_offset_p    /* ptr to start offset */			){        /* buffer for full pathname */	char file_name[MAX_PATH_SIZE+1];        /* buffer for file header */        byte header[HEADER_SIZE];	FILE *file_p;     /* file pointer for C file routines */        int num_read;      /* number of header bytes read */	int file_size;    /* size of complete file */        int header_size;/* size of header */        int code_size;     /* size of program code */        int data_size;     /* size of program data */        int errcode;       /* error code */        /* ensure that path name is not too long */        if ((strlen(dir_name) + strlen(prog_name) + 5)		 > MAX_PATH_SIZE) return(ERR_SUP_NAMLNG);	/* construct path name */	file_name[0] = NULCH;	if (dir_name[0] != NULCH) {		strcat(file_name, dir_name);	        strcat(file_name, "\\");	}        strcat(file_name, prog_name);	strcat(file_name, ".MPX");        /* try to open the file */	errcode = OK;        file_p = fopen(file_name, "rb");        if (file_p == NULL) return(ERR_SUP_FILNFD);	/* read the header, check for EXE signature */        num_read = fread( (void*) header, 1, HEADER_SIZE, file_p);        if (num_read != HEADER_SIZE) {		errcode = ERR_SUP_FILINV;	}        else if ((header[0] != 0x4D) || (header[1] != 0x5A)) {		errcode = ERR_SUP_FILINV;	}        /* close the file, then return if error occurred */        fclose(file_p);	if (errcode!=OK) return(errcode);        /* compute allocation size needed */        file_size = (header[5]*256 + header[4] -1) * 512		+ (header[3]*256 + header[2]);        header_size =(header[9]*256 + header[8])*16;        code_size = file_size - header_size;        data_size = (header[11]*256 + header[10])*16;        /* return total length and starting offset */        *prog_len_p = code_size + data_size;	*start_offset_p = (header[23]*256 + header[22]) * 16;	return(OK);}/*	Procedure: sys_load_program	Purpose: load a program file	Parameters: see prototype	Returns: error code; zero if OK	Calls:   intdosx		segread		strlen, strcat	Globals: none 	Errors:  ERR_SUP_NAMLNG    name too long		ERR_SUP_FILNFD    file not found	       ERR_SUP_FILINV      file invalid		ERR_SUP_PROGSZ    program too large	       ERR_SUP_LDADDR      address not aligned		ERR_SUP_LDFAIL    load failed*/int sys_load_program (     void*    load_addr,        /* address for loading */			int      max_size,         /* memory size */			char     dir_name[],       /* directory name */			char     prog_name[]       /* program name */		      ){	int errcode;      /* error code */        int prog_len;      /* program length */	int offset;       /* offset for starting */	word norm_seg;    /* normalized load address segment */        word norm_off;     /* normalized load address offset */        /* full pathname for file to be loaded */	char file_name[MAX_PATH_SIZE+1];        /* parameter block for MSDOS EXEC function */	struct {		word load_seg;    /* segment address for loading */	       word reloc_seg;     /* segment address for relocation */        }p_block;	union REGS inregs;            /* input register structure */	union REGS outregs;           /* output register structure */	struct SREGS segregs;         /* segment register structure */        /* check program, get length and offset */	errcode = sys_check_program(dir_name, prog_name,					&prog_len, &offset);        if (errcode < 0) return(errcode);        /* ensure that allocated memory is large enough */        if (max_size < prog_len) return(ERR_SUP_PROGSZ);        /* get normalized segment and offset, check alignment */	norm_seg = FP_SEG(load_addr);	norm_off = FP_OFF(load_addr);	norm_seg += norm_off / 16;        norm_off %= 16;	if (norm_off != 0) return(ERR_SUP_LDADDR);        /* ensure that path name is not too long */        if ((strlen(dir_name) + strlen(prog_name) + 5)		 > MAX_PATH_SIZE) return(ERR_SUP_NAMLNG);	/* construct path name */	file_name[0] = NULCH;	if (dir_name[0] != NULCH) {		strcat(file_name, dir_name);	        strcat(file_name, "\\");	}        strcat(file_name, prog_name);	strcat(file_name, ".MPX");        /* get current segment regs */	segread(&segregs);        /* setup function codes */	inregs.h.ah = 0x4B;        /* EXEC function */	inregs.h.al = 0x03;        /* load only */        /* setup parameter block and name pointers */        segregs.ds = FP_SEG(&file_name);	inregs.x.dx = FP_OFF(&file_name);        segregs.es = FP_SEG(&p_block);	inregs.x.bx = FP_OFF(&p_block);        /* setup load segment -- must be normalized */	p_block.load_seg = norm_seg;	p_block.reloc_seg = p_block.load_seg;        /* call the MS-DOS loader */	errcode = intdosx(&inregs,&outregs,&segregs);        errcode = errcode;        /* check for error */	if (outregs.x.cflag) return(ERR_SUP_LDFAIL);	/* load successful */	return(OK);}/* END OF FILE */aligned1,0
/***********************************************************************	MPX: The MultiProgramming eXecutive	Project to Accompany	A Practical Approach to Operating Systems	Malcolm G. Lane & James D. Mooney	Copyright 1993, P.W.S. Kent Publishing Co., Boston, MA.		File Name: mpx_supt.c	Authors: J.J. Patnesky, A. Ghosal, M. Lane, J. Mooney	Version: 2.1b	Date: 01/31/08	Purpose: Support routines for MPX-PC		Modules: all	Environment:      IBM-PC (XT, AT or PS/2)			MS-DOS 3.3 or later			TURBO-C 3.0 or TURBO-C++ 1.0 or later	Compile using the LARGE MODEL and SS NOT equal to DS.	All addresses and pointers are "far", and	CS, DS and SS are independent.	Procedures in this file:		sys_init		sys_exit		sys_set_vec		sys_req		sys_alloc_mem		sys_free_mem		sys_get_date		sys_set_date		sys_open_dir		sys_get_entry		sys_close_dir	       sys_check_program	       sys_load_program************************************************************************Change Log:	07/16/88  akg	added comments	02/25/92  jdm	full revision, UNIX version	04/14/92  jdm	Macintosh version	05/15/92  jdm	cleanup and documentation	07/14/92  jdm	update for revised specs        08/13/92  jdm 	revised IBM version; added private heap        10/14/92  jdm 	added check and load procedures        10/18/92  jdm 	revised sys_alloc_mem for alignment	11/17/92  jdm	true heap mgt, aligned, using calloc & free	11/19/92  jdm	enable device handling for final module	12/31/92  jdm	revised sys_req parameters	01/02/93  jdm	return count value after I/O	01/03/93  jdm	revised error names and codes	01/27/93  jdm	corrected count for line input in sys_req			fixed open_dir to handle null lines	02/24/93  jdm	changed sys_set_vec param to interrupt	03/08/93  jdm	corrections to sys_check & sys_load	03/20/93  jdm	stack switch in free, check, and load	04/22/93  jdm	corrected index conflict in sys_free_mem			added safety escape in alloc table search	07/28/93  jdm	conversion to large model	09/01/93  jdm	fixed allocation bug;  made date private	09/14/93  jdm	cleaned up memory allocation        09/16/93  jdm	adjusted program load for large model        09/30/93  jdm	modified for correct list of root directory	11/01/94  jdm	changed load file read to binary	09/18/95  jdm	fixed get_entry to default to current, not root	01/31/08  jdm   fixed possible overflow problem in get_entry************************************************************************/#include "mpx_supt.h"#include <stdlib.h>#include <dos.h>#include <dir.h>#include <errno.h>#include <conio.h>#include <alloc.h>#define VEC_ADDR (0x60L*4)#define MAX_ALLOC 200#define MAX_XPOS 79#define MAX_YPOS 24#define MAX_PATH_SIZE 50/*	System-dependent type definitions*/typedef unsigned char byte;typedef unsigned int word;typedef unsigned long longword;typedef byte *address;typedef struct params {	int      op_code;	int      device_id;	char     *buf_p;	int      *count_p;	} params;/*	Global variables accessed only by support routines*/	static longword vec_save;  /* saved interrupt vector */	static int mod_code;                /* module code */                                           	static struct date sys_date;        /* MPX system date */	/* data structures for directory access */        static char current_path[MAX_PATH_SIZE+1];        static int num_entries;        static struct ffblk file_block;        /* handler presence flags */	static flag sysc_hand;	static flag trm_hand;	static flag prt_hand;	static flag com_hand;        /* memory allocation table */	static struct {		void* original;		void* aligned;	} alloc_table[MAX_ALLOC];	static int alloc_ix;                /* current index */	static int num_alloc;               /* no. of allocated blocks *//*	Procedure: sys_init	Purpose: initialize mpx	Parameters: see prototype  	Return value: error code, or OK if no error	Calls: getdate    	Globals: mod_code		vec_save		sys_date		alloc_table, alloc_ix, num_alloc		sysc_hand, term_hand, prt_hand, com_hand	Errors: none*/int sys_init (    int      modules  /* module code */	     ){	mod_code = modules;        vec_save = 0L;        /* no handlers detected yet */	sysc_hand = FALSE;	trm_hand = FALSE;	prt_hand = FALSE;	com_hand = FALSE;	/* initialize allocation table */	for (alloc_ix=0; alloc_ix < MAX_ALLOC; alloc_ix++) {		alloc_table[alloc_ix].original = NULL;		alloc_table[alloc_ix].aligned = NULL;	}	alloc_ix = 0;	num_alloc = 0;	/* if we have reached Module R3, enable system call handling */	if (modules >= MODULE_R3) sysc_hand = TRUE;	/* if we have reached the final module, enable device handlers */	if (modules >= MODULE_F) {		trm_hand = TRUE;		prt_hand = TRUE;		com_hand = TRUE;	}	/* get system date */        getdate(&sys_date);	return (OK);}/*	Procedure: sys_exit	Purpose: terminate mpx	Parameters: none  	Return value: none	Calls: none       	Globals: vec_save*/void sys_exit(void){	longword *vec_p;	/* if trap vector changed, restore it */	if (vec_save != 0L) {		vec_p = (longword*) VEC_ADDR;		*vec_p = vec_save;	}	/* return to host with null error code */	exit(0);}/*	Procedure: sys_set_vec	Purpose: link trap vector to MPX system call handler	Parameters: handler: addr of handler         	Return value: error code; OK if no error	Calls: none       	Globals: vec_save	Errors: none*/int sys_set_vec   ( void interrupt (*handler)() /* system call handler */		){	longword *vec_p;			vec_p = (longword*) VEC_ADDR;		vec_save = *vec_p;		*vec_p = (longword) handler;	return (0);}/*	Procedure: sys_req	Purpose: Request a system service	Inputs:		op_code           operation code		device_id         device identifier		buf_p             addresso f data buffer		count_p           address of size of buffer	Returns: Result or error code, depending on service		Services supported:	IDLE     null operation				READ     input from a device				WRITE    output to a device				CLEAR    clear terminal screen				GOTOXY   absolute cursor position				EXIT     terminate the caller	Calls:   fgets		strlen			Globals: none		Errors:  ERR_SUP_INVDEV    invalid device		ERR_SUP_INVOPC    invalid operation code		ERR_SUP_INVPOS    invalid character position		ERR_SUP_RDFAIL    read failed		ERR_SUP_WRFAIL    write failed	Description:	For Modules R1 through R4,	this procedure is used only for terminal I/O.	Later modules support both reading and	writing for several devices.	For Modules R1 through R4,	sys_req uses the ANSI C function "fgets."	Later modules may use alternate functions and device drivers.*/int sys_req (   int      op_code, /* operation code */		int      device_id,        /* device id */		char*    buf_p,            /* I/O buffer */		int*     count_p           /* address of count */		){	int      rval;    /* result or error code */	char     *rp;     /* return pointer for fgets */	char     rc;      /* return char for fputc */        params    *param_p; /* pointer to parameter record in stack */	flag     docall;  /* true if system call interrupt wanted */	int      ix;      /* temporary index */	docall = FALSE;	rval = OK;	switch (op_code) {		case IDLE:		if (sysc_hand) docall = TRUE;		break; 				case READ:		switch (device_id) {				case TERMINAL:			if (trm_hand) docall = TRUE;			else {				rp = fgets(buf_p,*count_p,stdin);				if (rp==NULL) rval = ERR_SUP_RDFAIL;				else rval = strlen(buf_p);			}			break;					case COM_PORT:			if (com_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					default:			rval = ERR_SUP_INVDEV;					}		break;	case WRITE:		switch (device_id) {				case TERMINAL:			if (trm_hand) docall = TRUE;			else {				rval = *count_p;				for (ix=0; ix<*count_p; ix++) {					rc = fputc(buf_p[ix],stdout);					if (rc == EOF) {						rval = ERR_SUP_WRFAIL;						break;					}				}			}			break;					case COM_PORT:			if (com_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					case PRINTER:			if (prt_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					default:			rval = ERR_SUP_INVDEV;					}		break;	case CLEAR:		if (device_id==TERMINAL) {			if (trm_hand) docall = TRUE;			else {			     clrscr();				rval = 0;			}		}		else rval = ERR_SUP_INVDEV;		break;			case GOTOXY:		if (device_id==TERMINAL) {			if (trm_hand) docall = TRUE;			else {				if (*count_p != 2) rval = ERR_SUP_WRFAIL;				else if ((*buf_p<0)					|| (*buf_p > MAX_XPOS))					rval = ERR_SUP_WRFAIL;				else if ((*(buf_p+1)<0)					|| (*(buf_p+1) > MAX_YPOS))					rval = ERR_SUP_WRFAIL;				else {					gotoxy(*buf_p + 1,						*(buf_p+1) + 1);					rval = 0;				}			}		}		else rval = ERR_SUP_INVDEV;		break;			/* EXIT - terminate the calling process */	/* legal only when a system call handler is present */	case EXIT:		if (sysc_hand) docall = TRUE;		else rval = ERR_SUP_INVOPC;		break; 	default:		rval = ERR_SUP_INVOPC;			}		/* Invoke user's call handler if present.	   If the call is an IO request, return will occur	   only after the request is complete.	*/	if (docall && (rval==OK)) {		/* invoke the call handler */	_SP = _SP - sizeof(params);		param_p = (params*) MK_FP(_SS,_SP);	       param_p->op_code = op_code;	       param_p->device_id = device_id;	       param_p->buf_p = buf_p;	       param_p->count_p = count_p;	       geninterrupt(0x60);	       rval = _AX;	       _SP = _SP + sizeof(params);		/* for I/O operations, return count value */		switch(op_code) {		case READ:		case WRITE:		case CLEAR:		case GOTOXY:			rval = *count_p;		}	}	return(rval);}/*	Procedure: sys_alloc_mem	Purpose: Allocate a memory block	Parameters:			size_t size       No. of bytes to allocate	Returns: void* pointer to allocated block;		 null pointer in case of error		 	Calls: calloc		Globals: alloc_table, alloc_ix, num_alloc	For program loading (Module R-4), the blocks must be aligned.	This is achieved by requesting one extra paragraph and	returning the lowest aligned address as the base.  It is	necessary to keep a table of allocated address, original and	aligned, to support correct freeing.	It would seem simpler to use the Turbo-C function allocmem,	which always allocates aligned blocks.  However, allocmem	appears to conflict with the internal allocation of fopen	and other C library routines.*/void *sys_alloc_mem (      size_t   size     /* size in bytes to allocate */		    ){	int ix_save;      /* temp copy of table index */        void *addr;        /* addr returned by calloc (*void) */	word offset;      /* offset of unaligned address */	word seg;         /* segment addr of unaligned address */	void *addr_alig; /* aligned address */	int rem; /* temp for alignment computation */	/* ensure that allocation table is not full */	if (num_alloc >= MAX_ALLOC) {		return(NULL);	}	/* find free entry in allocation table */	ix_save = alloc_ix;	while (alloc_table[alloc_ix].original != NULL) {		alloc_ix++;		if (alloc_ix >= MAX_ALLOC) alloc_ix = 0;		/* safety check -- should never happen! */		if (alloc_ix == ix_save) return(NULL);	}	/* call allocation routine */	/* request 15 extra bytes to ensure alignment is possible */	addr = calloc(size + 15,1);	/* compute aligned base */	offset = FP_OFF(addr);        seg = FP_SEG(addr);	rem = offset % 16;	if (rem > 0) offset = offset + 16 - rem;	addr_alig = MK_FP(seg,offset);	/* insert entries in table */	alloc_table[alloc_ix].original = addr;	alloc_table[alloc_ix].aligned = addr_alig;	/* increment count */	num_alloc++;	return(addr_alig);}/*	Procedure: sys_free_mem	Purpose: free a memory block	Parameters:		void *ptr         ptr to block to allocate	Returns: integer error code; zero if OK		Calls:   free	Globals: alloc_table, num_alloc	Errors:  ERR_SUP_INVMEM    invalid memory block	This procedure receives an aligned address; it must	find and free the corresponding non-aligned one.*/int sys_free_mem (         void     *ptr     /* pointer to block */		 ){	void *free_addr;  /* true (unaligned) block address */	int free_ix;               /* temp table index */	/* ensure valid pointer */	if (ptr==NULL) return(ERR_SUP_INVMEM);	/* Look for the block in the allocation table */	free_addr = NULL;	for (free_ix=0; free_ix<MAX_ALLOC; free_ix++) {		if (alloc_table[free_ix].aligned == ptr) {			free_addr = alloc_table[free_ix].original;			break;		}	}	/* If the block wasn't found, report error */	if (free_addr == NULL) return(ERR_SUP_INVMEM);	/* free the block & clear the table entry */	alloc_table[free_ix].original = NULL;	alloc_table[free_ix].aligned = NULL;        free(free_addr);	/* decrement count */	num_alloc--;	return(OK);}        /*	Procedure: sys_get_date	Purpose: Returns the system date (month, day, year)	Parameters:		date_rec *date_p Pointer to structure of type date	Returns: void		Calls: none		Globals: sys_date        Errors: none*/void sys_get_date (  date_rec*      date_p   /* ptr to date record */		){	date_p->month = sys_date.da_mon;	date_p->day = sys_date.da_day;	date_p->year = sys_date.da_year;}/*	Procedure: sys_set_date	Purpose: Sets the system date (month, day, year)	Parameters:		date_rec *date_p ptr to structure of type date	Returns: error code; OK if no error	Calls:   none        Globals: sys_date	Errors: none*/int sys_set_date (  date_rec*       date_p   /* ptr to date record */		 ){	sys_date.da_mon = date_p->month;        sys_date.da_day = date_p->day;        sys_date.da_year = date_p->year;	return(OK);}/*	Procedure: sys_open_dir	Purpose: open a specified directory	Parameters: char dir_name[]            directory name	Returns: error code; zero if OK	Calls:   findfirst		strncpy  	Globals: current_path, file_block, num_entries	Errors:  ERR_SUP_DIROPN    directory open error		ERR_SUP_INVDIR    invalid directory*/int sys_open_dir (  char  path_name[]        /* directory name */		 ){        char temp_path[MAX_PATH_SIZE];	int res;        int len;        /* ensure there is no directory currently open */	if (current_path[0]!=NULCH) return(ERR_SUP_DIROPN);        /* check pathname for validity */        /* construct temporary search path name */	temp_path[0] = NULCH;	if (path_name != NULL) {		strncpy(temp_path,path_name,MAX_PATH_SIZE-4);	}	/* build wildcard search string */        len = strlen(temp_path);	/* if path is null, use current directory */        if (len==0) strcpy(temp_path,"*.*");	/* handle paths ending in backslash, including root */        else if (temp_path[len-1]=='\\') strcat(temp_path,"*.*");	/* handle paths not ending in backslash */        else strcat(temp_path,"\\*.*");	/* validate the directory by searching for either an ordinary	   file or a directory in it.  This should never fail; even	   empty directories contain the directories "." and ".."	*/		res = findfirst(temp_path, &file_block, FA_DIREC);	if (res!=0)  return(ERR_SUP_INVDIR);        /* save pathname as current, clear entry count */	current_path[0] = NULCH;	if (path_name != NULL) {		strncpy(current_path,path_name,MAX_PATH_SIZE-6);	}	num_entries = 0;	return(OK);}/*	Procedure: sys_get_entry	Purpose: get the next directory entry;	Parameters: char name_buf[]	name buffer		    int buf_size  	buffer capacity		    long *file_size_p	file length buffer         	Returns: error code, or zero if ok	Calls:	findfirst		findnext		strncpy, strcpy, strrchr, strcat    	Globals: current_path, num_entries, file_block	Errors:  ERR_SUP_NOENTR    no such entry*/int sys_get_entry (char    name_buf[],       /* buffer for entry */		   int   buf_size,         /* buffer size */		   long* file_size_p       /* buffer for size value */		  ){	char filename[MAX_PATH_SIZE+1];	int err;        int len;        char *cp;        /* find next MPX file entry, if any */        /* if this is the first call */	if (num_entries==0) {	       /* construct complete search path name */	       len = strlen(current_path);	       if (len==0) strcpy(current_path,"*.MPX");	       else if (current_path[len-1]=='\\') strcat(current_path,"*.MPX");	       else strcat(current_path,"\\*.MPX");	       /* find first entry */		err = findfirst (current_path,&file_block,0);        }        /* otherwise, find next entry */        else err = findnext(&file_block);        if (err<0) return(ERR_SUP_NOENTR);		/* ensure buf_size is not too large */		if (buf_size > MAX_PATH_SIZE) buf_size = MAX_PATH_SIZE;		      /* copy filename to buffer */	filename[buf_size] = NULCH;	strncpy (filename,file_block.ff_name,			 (size_t) buf_size);	/* remove ".MPX" from name */	cp = strrchr(filename, (int) '.');        *cp = NULCH;	/* copy name and size to caller's buffer */        strcpy (name_buf,filename);	*file_size_p = file_block.ff_fsize;        /* count entry */	num_entries++;	return(OK);}/*	Procedure: sys_close_dir	Purpose: close an open directory	Parameters: none	Returns: error code; zero if OK	Calls:   none	Globals: current_path	Errors:  none*/int sys_close_dir (void){	current_path[0] = NULCH;	return(OK);}/*	Procedure: sys_check_program	Purpose: locate and measure a program file	Parameters: see prototype	Returns: program size or error code	Calls:   strlen, strcat		fopen, fread	Globals: none	Errors:  ERR_SUP_NAMLNG    pathname too long		ERR_SUP_FILNFD    file not found		ERR_SUP_FILINV    file invalid*/#define HEADER_SIZE 32int sys_check_program(     char     dir_name[],       /* directory name */			char     prog_name[],      /* program name */			int*     prog_len_p,       /* ptr to prog length */			int*     start_offset_p    /* ptr to start offset */			){        /* buffer for full pathname */	char file_name[MAX_PATH_SIZE+1];        /* buffer for file header */        byte header[HEADER_SIZE];	FILE *file_p;     /* file pointer for C file routines */        int num_read;      /* number of header bytes read */	int file_size;    /* size of complete file */        int header_size;/* size of header */        int code_size;     /* size of program code */        int data_size;     /* size of program data */        int errcode;       /* error code */        /* ensure that path name is not too long */        if ((strlen(dir_name) + strlen(prog_name) + 5)		 > MAX_PATH_SIZE) return(ERR_SUP_NAMLNG);	/* construct path name */	file_name[0] = NULCH;	if (dir_name[0] != NULCH) {		strcat(file_name, dir_name);	        strcat(file_name, "\\");	}        strcat(file_name, prog_name);	strcat(file_name, ".MPX");        /* try to open the file */	errcode = OK;        file_p = fopen(file_name, "rb");        if (file_p == NULL) return(ERR_SUP_FILNFD);	/* read the header, check for EXE signature */        num_read = fread( (void*) header, 1, HEADER_SIZE, file_p);        if (num_read != HEADER_SIZE) {		errcode = ERR_SUP_FILINV;	}        else if ((header[0] != 0x4D) || (header[1] != 0x5A)) {		errcode = ERR_SUP_FILINV;	}        /* close the file, then return if error occurred */        fclose(file_p);	if (errcode!=OK) return(errcode);        /* compute allocation size needed */        file_size = (header[5]*256 + header[4] -1) * 512		+ (header[3]*256 + header[2]);        header_size =(header[9]*256 + header[8])*16;        code_size = file_size - header_size;        data_size = (header[11]*256 + header[10])*16;        /* return total length and starting offset */        *prog_len_p = code_size + data_size;	*start_offset_p = (header[23]*256 + header[22]) * 16;	return(OK);}/*	Procedure: sys_load_program	Purpose: load a program file	Parameters: see prototype	Returns: error code; zero if OK	Calls:   intdosx		segread		strlen, strcat	Globals: none 	Errors:  ERR_SUP_NAMLNG    name too long		ERR_SUP_FILNFD    file not found	       ERR_SUP_FILINV      file invalid		ERR_SUP_PROGSZ    program too large	       ERR_SUP_LDADDR      address not aligned		ERR_SUP_LDFAIL    load failed*/int sys_load_program (     void*    load_addr,        /* address for loading */			int      max_size,         /* memory size */			char     dir_name[],       /* directory name */			char     prog_name[]       /* program name */		      ){	int errcode;      /* error code */        int prog_len;      /* program length */	int offset;       /* offset for starting */	word norm_seg;    /* normalized load address segment */        word norm_off;     /* normalized load address offset */        /* full pathname for file to be loaded */	char file_name[MAX_PATH_SIZE+1];        /* parameter block for MSDOS EXEC function */	struct {		word load_seg;    /* segment address for loading */	       word reloc_seg;     /* segment address for relocation */        }p_block;	union REGS inregs;            /* input register structure */	union REGS outregs;           /* output register structure */	struct SREGS segregs;         /* segment register structure */        /* check program, get length and offset */	errcode = sys_check_program(dir_name, prog_name,					&prog_len, &offset);        if (errcode < 0) return(errcode);        /* ensure that allocated memory is large enough */        if (max_size < prog_len) return(ERR_SUP_PROGSZ);        /* get normalized segment and offset, check alignment */	norm_seg = FP_SEG(load_addr);	norm_off = FP_OFF(load_addr);	norm_seg += norm_off / 16;        norm_off %= 16;	if (norm_off != 0) return(ERR_SUP_LDADDR);        /* ensure that path name is not too long */        if ((strlen(dir_name) + strlen(prog_name) + 5)		 > MAX_PATH_SIZE) return(ERR_SUP_NAMLNG);	/* construct path name */	file_name[0] = NULCH;	if (dir_name[0] != NULCH) {		strcat(file_name, dir_name);	        strcat(file_name, "\\");	}        strcat(file_name, prog_name);	strcat(file_name, ".MPX");        /* get current segment regs */	segread(&segregs);        /* setup function codes */	inregs.h.ah = 0x4B;        /* EXEC function */	inregs.h.al = 0x03;        /* load only */        /* setup parameter block and name pointers */        segregs.ds = FP_SEG(&file_name);	inregs.x.dx = FP_OFF(&file_name);        segregs.es = FP_SEG(&p_block);	inregs.x.bx = FP_OFF(&p_block);        /* setup load segment -- must be normalized */	p_block.load_seg = norm_seg;	p_block.reloc_seg = p_block.load_seg;        /* call the MS-DOS loader */	errcode = intdosx(&inregs,&outregs,&segregs);        errcode = errcode;        /* check for error */	if (outregs.x.cflag) return(ERR_SUP_LDFAIL);	/* load successful */	return(OK);}/* END OF FILE */alloc_table1,0
/***********************************************************************	MPX: The MultiProgramming eXecutive	Project to Accompany	A Practical Approach to Operating Systems	Malcolm G. Lane & James D. Mooney	Copyright 1993, P.W.S. Kent Publishing Co., Boston, MA.		File Name: mpx_supt.c	Authors: J.J. Patnesky, A. Ghosal, M. Lane, J. Mooney	Version: 2.1b	Date: 01/31/08	Purpose: Support routines for MPX-PC		Modules: all	Environment:      IBM-PC (XT, AT or PS/2)			MS-DOS 3.3 or later			TURBO-C 3.0 or TURBO-C++ 1.0 or later	Compile using the LARGE MODEL and SS NOT equal to DS.	All addresses and pointers are "far", and	CS, DS and SS are independent.	Procedures in this file:		sys_init		sys_exit		sys_set_vec		sys_req		sys_alloc_mem		sys_free_mem		sys_get_date		sys_set_date		sys_open_dir		sys_get_entry		sys_close_dir	       sys_check_program	       sys_load_program************************************************************************Change Log:	07/16/88  akg	added comments	02/25/92  jdm	full revision, UNIX version	04/14/92  jdm	Macintosh version	05/15/92  jdm	cleanup and documentation	07/14/92  jdm	update for revised specs        08/13/92  jdm 	revised IBM version; added private heap        10/14/92  jdm 	added check and load procedures        10/18/92  jdm 	revised sys_alloc_mem for alignment	11/17/92  jdm	true heap mgt, aligned, using calloc & free	11/19/92  jdm	enable device handling for final module	12/31/92  jdm	revised sys_req parameters	01/02/93  jdm	return count value after I/O	01/03/93  jdm	revised error names and codes	01/27/93  jdm	corrected count for line input in sys_req			fixed open_dir to handle null lines	02/24/93  jdm	changed sys_set_vec param to interrupt	03/08/93  jdm	corrections to sys_check & sys_load	03/20/93  jdm	stack switch in free, check, and load	04/22/93  jdm	corrected index conflict in sys_free_mem			added safety escape in alloc table search	07/28/93  jdm	conversion to large model	09/01/93  jdm	fixed allocation bug;  made date private	09/14/93  jdm	cleaned up memory allocation        09/16/93  jdm	adjusted program load for large model        09/30/93  jdm	modified for correct list of root directory	11/01/94  jdm	changed load file read to binary	09/18/95  jdm	fixed get_entry to default to current, not root	01/31/08  jdm   fixed possible overflow problem in get_entry************************************************************************/#include "mpx_supt.h"#include <stdlib.h>#include <dos.h>#include <dir.h>#include <errno.h>#include <conio.h>#include <alloc.h>#define VEC_ADDR (0x60L*4)#define MAX_ALLOC 200#define MAX_XPOS 79#define MAX_YPOS 24#define MAX_PATH_SIZE 50/*	System-dependent type definitions*/typedef unsigned char byte;typedef unsigned int word;typedef unsigned long longword;typedef byte *address;typedef struct params {	int      op_code;	int      device_id;	char     *buf_p;	int      *count_p;	} params;/*	Global variables accessed only by support routines*/	static longword vec_save;  /* saved interrupt vector */	static int mod_code;                /* module code */                                           	static struct date sys_date;        /* MPX system date */	/* data structures for directory access */        static char current_path[MAX_PATH_SIZE+1];        static int num_entries;        static struct ffblk file_block;        /* handler presence flags */	static flag sysc_hand;	static flag trm_hand;	static flag prt_hand;	static flag com_hand;        /* memory allocation table */	static struct {		void* original;		void* aligned;	} alloc_table[MAX_ALLOC];	static int alloc_ix;                /* current index */	static int num_alloc;               /* no. of allocated blocks *//*	Procedure: sys_init	Purpose: initialize mpx	Parameters: see prototype  	Return value: error code, or OK if no error	Calls: getdate    	Globals: mod_code		vec_save		sys_date		alloc_table, alloc_ix, num_alloc		sysc_hand, term_hand, prt_hand, com_hand	Errors: none*/int sys_init (    int      modules  /* module code */	     ){	mod_code = modules;        vec_save = 0L;        /* no handlers detected yet */	sysc_hand = FALSE;	trm_hand = FALSE;	prt_hand = FALSE;	com_hand = FALSE;	/* initialize allocation table */	for (alloc_ix=0; alloc_ix < MAX_ALLOC; alloc_ix++) {		alloc_table[alloc_ix].original = NULL;		alloc_table[alloc_ix].aligned = NULL;	}	alloc_ix = 0;	num_alloc = 0;	/* if we have reached Module R3, enable system call handling */	if (modules >= MODULE_R3) sysc_hand = TRUE;	/* if we have reached the final module, enable device handlers */	if (modules >= MODULE_F) {		trm_hand = TRUE;		prt_hand = TRUE;		com_hand = TRUE;	}	/* get system date */        getdate(&sys_date);	return (OK);}/*	Procedure: sys_exit	Purpose: terminate mpx	Parameters: none  	Return value: none	Calls: none       	Globals: vec_save*/void sys_exit(void){	longword *vec_p;	/* if trap vector changed, restore it */	if (vec_save != 0L) {		vec_p = (longword*) VEC_ADDR;		*vec_p = vec_save;	}	/* return to host with null error code */	exit(0);}/*	Procedure: sys_set_vec	Purpose: link trap vector to MPX system call handler	Parameters: handler: addr of handler         	Return value: error code; OK if no error	Calls: none       	Globals: vec_save	Errors: none*/int sys_set_vec   ( void interrupt (*handler)() /* system call handler */		){	longword *vec_p;			vec_p = (longword*) VEC_ADDR;		vec_save = *vec_p;		*vec_p = (longword) handler;	return (0);}/*	Procedure: sys_req	Purpose: Request a system service	Inputs:		op_code           operation code		device_id         device identifier		buf_p             addresso f data buffer		count_p           address of size of buffer	Returns: Result or error code, depending on service		Services supported:	IDLE     null operation				READ     input from a device				WRITE    output to a device				CLEAR    clear terminal screen				GOTOXY   absolute cursor position				EXIT     terminate the caller	Calls:   fgets		strlen			Globals: none		Errors:  ERR_SUP_INVDEV    invalid device		ERR_SUP_INVOPC    invalid operation code		ERR_SUP_INVPOS    invalid character position		ERR_SUP_RDFAIL    read failed		ERR_SUP_WRFAIL    write failed	Description:	For Modules R1 through R4,	this procedure is used only for terminal I/O.	Later modules support both reading and	writing for several devices.	For Modules R1 through R4,	sys_req uses the ANSI C function "fgets."	Later modules may use alternate functions and device drivers.*/int sys_req (   int      op_code, /* operation code */		int      device_id,        /* device id */		char*    buf_p,            /* I/O buffer */		int*     count_p           /* address of count */		){	int      rval;    /* result or error code */	char     *rp;     /* return pointer for fgets */	char     rc;      /* return char for fputc */        params    *param_p; /* pointer to parameter record in stack */	flag     docall;  /* true if system call interrupt wanted */	int      ix;      /* temporary index */	docall = FALSE;	rval = OK;	switch (op_code) {		case IDLE:		if (sysc_hand) docall = TRUE;		break; 				case READ:		switch (device_id) {				case TERMINAL:			if (trm_hand) docall = TRUE;			else {				rp = fgets(buf_p,*count_p,stdin);				if (rp==NULL) rval = ERR_SUP_RDFAIL;				else rval = strlen(buf_p);			}			break;					case COM_PORT:			if (com_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					default:			rval = ERR_SUP_INVDEV;					}		break;	case WRITE:		switch (device_id) {				case TERMINAL:			if (trm_hand) docall = TRUE;			else {				rval = *count_p;				for (ix=0; ix<*count_p; ix++) {					rc = fputc(buf_p[ix],stdout);					if (rc == EOF) {						rval = ERR_SUP_WRFAIL;						break;					}				}			}			break;					case COM_PORT:			if (com_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					case PRINTER:			if (prt_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					default:			rval = ERR_SUP_INVDEV;					}		break;	case CLEAR:		if (device_id==TERMINAL) {			if (trm_hand) docall = TRUE;			else {			     clrscr();				rval = 0;			}		}		else rval = ERR_SUP_INVDEV;		break;			case GOTOXY:		if (device_id==TERMINAL) {			if (trm_hand) docall = TRUE;			else {				if (*count_p != 2) rval = ERR_SUP_WRFAIL;				else if ((*buf_p<0)					|| (*buf_p > MAX_XPOS))					rval = ERR_SUP_WRFAIL;				else if ((*(buf_p+1)<0)					|| (*(buf_p+1) > MAX_YPOS))					rval = ERR_SUP_WRFAIL;				else {					gotoxy(*buf_p + 1,						*(buf_p+1) + 1);					rval = 0;				}			}		}		else rval = ERR_SUP_INVDEV;		break;			/* EXIT - terminate the calling process */	/* legal only when a system call handler is present */	case EXIT:		if (sysc_hand) docall = TRUE;		else rval = ERR_SUP_INVOPC;		break; 	default:		rval = ERR_SUP_INVOPC;			}		/* Invoke user's call handler if present.	   If the call is an IO request, return will occur	   only after the request is complete.	*/	if (docall && (rval==OK)) {		/* invoke the call handler */	_SP = _SP - sizeof(params);		param_p = (params*) MK_FP(_SS,_SP);	       param_p->op_code = op_code;	       param_p->device_id = device_id;	       param_p->buf_p = buf_p;	       param_p->count_p = count_p;	       geninterrupt(0x60);	       rval = _AX;	       _SP = _SP + sizeof(params);		/* for I/O operations, return count value */		switch(op_code) {		case READ:		case WRITE:		case CLEAR:		case GOTOXY:			rval = *count_p;		}	}	return(rval);}/*	Procedure: sys_alloc_mem	Purpose: Allocate a memory block	Parameters:			size_t size       No. of bytes to allocate	Returns: void* pointer to allocated block;		 null pointer in case of error		 	Calls: calloc		Globals: alloc_table, alloc_ix, num_alloc	For program loading (Module R-4), the blocks must be aligned.	This is achieved by requesting one extra paragraph and	returning the lowest aligned address as the base.  It is	necessary to keep a table of allocated address, original and	aligned, to support correct freeing.	It would seem simpler to use the Turbo-C function allocmem,	which always allocates aligned blocks.  However, allocmem	appears to conflict with the internal allocation of fopen	and other C library routines.*/void *sys_alloc_mem (      size_t   size     /* size in bytes to allocate */		    ){	int ix_save;      /* temp copy of table index */        void *addr;        /* addr returned by calloc (*void) */	word offset;      /* offset of unaligned address */	word seg;         /* segment addr of unaligned address */	void *addr_alig; /* aligned address */	int rem; /* temp for alignment computation */	/* ensure that allocation table is not full */	if (num_alloc >= MAX_ALLOC) {		return(NULL);	}	/* find free entry in allocation table */	ix_save = alloc_ix;	while (alloc_table[alloc_ix].original != NULL) {		alloc_ix++;		if (alloc_ix >= MAX_ALLOC) alloc_ix = 0;		/* safety check -- should never happen! */		if (alloc_ix == ix_save) return(NULL);	}	/* call allocation routine */	/* request 15 extra bytes to ensure alignment is possible */	addr = calloc(size + 15,1);	/* compute aligned base */	offset = FP_OFF(addr);        seg = FP_SEG(addr);	rem = offset % 16;	if (rem > 0) offset = offset + 16 - rem;	addr_alig = MK_FP(seg,offset);	/* insert entries in table */	alloc_table[alloc_ix].original = addr;	alloc_table[alloc_ix].aligned = addr_alig;	/* increment count */	num_alloc++;	return(addr_alig);}/*	Procedure: sys_free_mem	Purpose: free a memory block	Parameters:		void *ptr         ptr to block to allocate	Returns: integer error code; zero if OK		Calls:   free	Globals: alloc_table, num_alloc	Errors:  ERR_SUP_INVMEM    invalid memory block	This procedure receives an aligned address; it must	find and free the corresponding non-aligned one.*/int sys_free_mem (         void     *ptr     /* pointer to block */		 ){	void *free_addr;  /* true (unaligned) block address */	int free_ix;               /* temp table index */	/* ensure valid pointer */	if (ptr==NULL) return(ERR_SUP_INVMEM);	/* Look for the block in the allocation table */	free_addr = NULL;	for (free_ix=0; free_ix<MAX_ALLOC; free_ix++) {		if (alloc_table[free_ix].aligned == ptr) {			free_addr = alloc_table[free_ix].original;			break;		}	}	/* If the block wasn't found, report error */	if (free_addr == NULL) return(ERR_SUP_INVMEM);	/* free the block & clear the table entry */	alloc_table[free_ix].original = NULL;	alloc_table[free_ix].aligned = NULL;        free(free_addr);	/* decrement count */	num_alloc--;	return(OK);}        /*	Procedure: sys_get_date	Purpose: Returns the system date (month, day, year)	Parameters:		date_rec *date_p Pointer to structure of type date	Returns: void		Calls: none		Globals: sys_date        Errors: none*/void sys_get_date (  date_rec*      date_p   /* ptr to date record */		){	date_p->month = sys_date.da_mon;	date_p->day = sys_date.da_day;	date_p->year = sys_date.da_year;}/*	Procedure: sys_set_date	Purpose: Sets the system date (month, day, year)	Parameters:		date_rec *date_p ptr to structure of type date	Returns: error code; OK if no error	Calls:   none        Globals: sys_date	Errors: none*/int sys_set_date (  date_rec*       date_p   /* ptr to date record */		 ){	sys_date.da_mon = date_p->month;        sys_date.da_day = date_p->day;        sys_date.da_year = date_p->year;	return(OK);}/*	Procedure: sys_open_dir	Purpose: open a specified directory	Parameters: char dir_name[]            directory name	Returns: error code; zero if OK	Calls:   findfirst		strncpy  	Globals: current_path, file_block, num_entries	Errors:  ERR_SUP_DIROPN    directory open error		ERR_SUP_INVDIR    invalid directory*/int sys_open_dir (  char  path_name[]        /* directory name */		 ){        char temp_path[MAX_PATH_SIZE];	int res;        int len;        /* ensure there is no directory currently open */	if (current_path[0]!=NULCH) return(ERR_SUP_DIROPN);        /* check pathname for validity */        /* construct temporary search path name */	temp_path[0] = NULCH;	if (path_name != NULL) {		strncpy(temp_path,path_name,MAX_PATH_SIZE-4);	}	/* build wildcard search string */        len = strlen(temp_path);	/* if path is null, use current directory */        if (len==0) strcpy(temp_path,"*.*");	/* handle paths ending in backslash, including root */        else if (temp_path[len-1]=='\\') strcat(temp_path,"*.*");	/* handle paths not ending in backslash */        else strcat(temp_path,"\\*.*");	/* validate the directory by searching for either an ordinary	   file or a directory in it.  This should never fail; even	   empty directories contain the directories "." and ".."	*/		res = findfirst(temp_path, &file_block, FA_DIREC);	if (res!=0)  return(ERR_SUP_INVDIR);        /* save pathname as current, clear entry count */	current_path[0] = NULCH;	if (path_name != NULL) {		strncpy(current_path,path_name,MAX_PATH_SIZE-6);	}	num_entries = 0;	return(OK);}/*	Procedure: sys_get_entry	Purpose: get the next directory entry;	Parameters: char name_buf[]	name buffer		    int buf_size  	buffer capacity		    long *file_size_p	file length buffer         	Returns: error code, or zero if ok	Calls:	findfirst		findnext		strncpy, strcpy, strrchr, strcat    	Globals: current_path, num_entries, file_block	Errors:  ERR_SUP_NOENTR    no such entry*/int sys_get_entry (char    name_buf[],       /* buffer for entry */		   int   buf_size,         /* buffer size */		   long* file_size_p       /* buffer for size value */		  ){	char filename[MAX_PATH_SIZE+1];	int err;        int len;        char *cp;        /* find next MPX file entry, if any */        /* if this is the first call */	if (num_entries==0) {	       /* construct complete search path name */	       len = strlen(current_path);	       if (len==0) strcpy(current_path,"*.MPX");	       else if (current_path[len-1]=='\\') strcat(current_path,"*.MPX");	       else strcat(current_path,"\\*.MPX");	       /* find first entry */		err = findfirst (current_path,&file_block,0);        }        /* otherwise, find next entry */        else err = findnext(&file_block);        if (err<0) return(ERR_SUP_NOENTR);		/* ensure buf_size is not too large */		if (buf_size > MAX_PATH_SIZE) buf_size = MAX_PATH_SIZE;		      /* copy filename to buffer */	filename[buf_size] = NULCH;	strncpy (filename,file_block.ff_name,			 (size_t) buf_size);	/* remove ".MPX" from name */	cp = strrchr(filename, (int) '.');        *cp = NULCH;	/* copy name and size to caller's buffer */        strcpy (name_buf,filename);	*file_size_p = file_block.ff_fsize;        /* count entry */	num_entries++;	return(OK);}/*	Procedure: sys_close_dir	Purpose: close an open directory	Parameters: none	Returns: error code; zero if OK	Calls:   none	Globals: current_path	Errors:  none*/int sys_close_dir (void){	current_path[0] = NULCH;	return(OK);}/*	Procedure: sys_check_program	Purpose: locate and measure a program file	Parameters: see prototype	Returns: program size or error code	Calls:   strlen, strcat		fopen, fread	Globals: none	Errors:  ERR_SUP_NAMLNG    pathname too long		ERR_SUP_FILNFD    file not found		ERR_SUP_FILINV    file invalid*/#define HEADER_SIZE 32int sys_check_program(     char     dir_name[],       /* directory name */			char     prog_name[],      /* program name */			int*     prog_len_p,       /* ptr to prog length */			int*     start_offset_p    /* ptr to start offset */			){        /* buffer for full pathname */	char file_name[MAX_PATH_SIZE+1];        /* buffer for file header */        byte header[HEADER_SIZE];	FILE *file_p;     /* file pointer for C file routines */        int num_read;      /* number of header bytes read */	int file_size;    /* size of complete file */        int header_size;/* size of header */        int code_size;     /* size of program code */        int data_size;     /* size of program data */        int errcode;       /* error code */        /* ensure that path name is not too long */        if ((strlen(dir_name) + strlen(prog_name) + 5)		 > MAX_PATH_SIZE) return(ERR_SUP_NAMLNG);	/* construct path name */	file_name[0] = NULCH;	if (dir_name[0] != NULCH) {		strcat(file_name, dir_name);	        strcat(file_name, "\\");	}        strcat(file_name, prog_name);	strcat(file_name, ".MPX");        /* try to open the file */	errcode = OK;        file_p = fopen(file_name, "rb");        if (file_p == NULL) return(ERR_SUP_FILNFD);	/* read the header, check for EXE signature */        num_read = fread( (void*) header, 1, HEADER_SIZE, file_p);        if (num_read != HEADER_SIZE) {		errcode = ERR_SUP_FILINV;	}        else if ((header[0] != 0x4D) || (header[1] != 0x5A)) {		errcode = ERR_SUP_FILINV;	}        /* close the file, then return if error occurred */        fclose(file_p);	if (errcode!=OK) return(errcode);        /* compute allocation size needed */        file_size = (header[5]*256 + header[4] -1) * 512		+ (header[3]*256 + header[2]);        header_size =(header[9]*256 + header[8])*16;        code_size = file_size - header_size;        data_size = (header[11]*256 + header[10])*16;        /* return total length and starting offset */        *prog_len_p = code_size + data_size;	*start_offset_p = (header[23]*256 + header[22]) * 16;	return(OK);}/*	Procedure: sys_load_program	Purpose: load a program file	Parameters: see prototype	Returns: error code; zero if OK	Calls:   intdosx		segread		strlen, strcat	Globals: none 	Errors:  ERR_SUP_NAMLNG    name too long		ERR_SUP_FILNFD    file not found	       ERR_SUP_FILINV      file invalid		ERR_SUP_PROGSZ    program too large	       ERR_SUP_LDADDR      address not aligned		ERR_SUP_LDFAIL    load failed*/int sys_load_program (     void*    load_addr,        /* address for loading */			int      max_size,         /* memory size */			char     dir_name[],       /* directory name */			char     prog_name[]       /* program name */		      ){	int errcode;      /* error code */        int prog_len;      /* program length */	int offset;       /* offset for starting */	word norm_seg;    /* normalized load address segment */        word norm_off;     /* normalized load address offset */        /* full pathname for file to be loaded */	char file_name[MAX_PATH_SIZE+1];        /* parameter block for MSDOS EXEC function */	struct {		word load_seg;    /* segment address for loading */	       word reloc_seg;     /* segment address for relocation */        }p_block;	union REGS inregs;            /* input register structure */	union REGS outregs;           /* output register structure */	struct SREGS segregs;         /* segment register structure */        /* check program, get length and offset */	errcode = sys_check_program(dir_name, prog_name,					&prog_len, &offset);        if (errcode < 0) return(errcode);        /* ensure that allocated memory is large enough */        if (max_size < prog_len) return(ERR_SUP_PROGSZ);        /* get normalized segment and offset, check alignment */	norm_seg = FP_SEG(load_addr);	norm_off = FP_OFF(load_addr);	norm_seg += norm_off / 16;        norm_off %= 16;	if (norm_off != 0) return(ERR_SUP_LDADDR);        /* ensure that path name is not too long */        if ((strlen(dir_name) + strlen(prog_name) + 5)		 > MAX_PATH_SIZE) return(ERR_SUP_NAMLNG);	/* construct path name */	file_name[0] = NULCH;	if (dir_name[0] != NULCH) {		strcat(file_name, dir_name);	        strcat(file_name, "\\");	}        strcat(file_name, prog_name);	strcat(file_name, ".MPX");        /* get current segment regs */	segread(&segregs);        /* setup function codes */	inregs.h.ah = 0x4B;        /* EXEC function */	inregs.h.al = 0x03;        /* load only */        /* setup parameter block and name pointers */        segregs.ds = FP_SEG(&file_name);	inregs.x.dx = FP_OFF(&file_name);        segregs.es = FP_SEG(&p_block);	inregs.x.bx = FP_OFF(&p_block);        /* setup load segment -- must be normalized */	p_block.load_seg = norm_seg;	p_block.reloc_seg = p_block.load_seg;        /* call the MS-DOS loader */	errcode = intdosx(&inregs,&outregs,&segregs);        errcode = errcode;        /* check for error */	if (outregs.x.cflag) return(ERR_SUP_LDFAIL);	/* load successful */	return(OK);}/* END OF FILE */alloc_ix1,0
/***********************************************************************	MPX: The MultiProgramming eXecutive	Project to Accompany	A Practical Approach to Operating Systems	Malcolm G. Lane & James D. Mooney	Copyright 1993, P.W.S. Kent Publishing Co., Boston, MA.		File Name: mpx_supt.c	Authors: J.J. Patnesky, A. Ghosal, M. Lane, J. Mooney	Version: 2.1b	Date: 01/31/08	Purpose: Support routines for MPX-PC		Modules: all	Environment:      IBM-PC (XT, AT or PS/2)			MS-DOS 3.3 or later			TURBO-C 3.0 or TURBO-C++ 1.0 or later	Compile using the LARGE MODEL and SS NOT equal to DS.	All addresses and pointers are "far", and	CS, DS and SS are independent.	Procedures in this file:		sys_init		sys_exit		sys_set_vec		sys_req		sys_alloc_mem		sys_free_mem		sys_get_date		sys_set_date		sys_open_dir		sys_get_entry		sys_close_dir	       sys_check_program	       sys_load_program************************************************************************Change Log:	07/16/88  akg	added comments	02/25/92  jdm	full revision, UNIX version	04/14/92  jdm	Macintosh version	05/15/92  jdm	cleanup and documentation	07/14/92  jdm	update for revised specs        08/13/92  jdm 	revised IBM version; added private heap        10/14/92  jdm 	added check and load procedures        10/18/92  jdm 	revised sys_alloc_mem for alignment	11/17/92  jdm	true heap mgt, aligned, using calloc & free	11/19/92  jdm	enable device handling for final module	12/31/92  jdm	revised sys_req parameters	01/02/93  jdm	return count value after I/O	01/03/93  jdm	revised error names and codes	01/27/93  jdm	corrected count for line input in sys_req			fixed open_dir to handle null lines	02/24/93  jdm	changed sys_set_vec param to interrupt	03/08/93  jdm	corrections to sys_check & sys_load	03/20/93  jdm	stack switch in free, check, and load	04/22/93  jdm	corrected index conflict in sys_free_mem			added safety escape in alloc table search	07/28/93  jdm	conversion to large model	09/01/93  jdm	fixed allocation bug;  made date private	09/14/93  jdm	cleaned up memory allocation        09/16/93  jdm	adjusted program load for large model        09/30/93  jdm	modified for correct list of root directory	11/01/94  jdm	changed load file read to binary	09/18/95  jdm	fixed get_entry to default to current, not root	01/31/08  jdm   fixed possible overflow problem in get_entry************************************************************************/#include "mpx_supt.h"#include <stdlib.h>#include <dos.h>#include <dir.h>#include <errno.h>#include <conio.h>#include <alloc.h>#define VEC_ADDR (0x60L*4)#define MAX_ALLOC 200#define MAX_XPOS 79#define MAX_YPOS 24#define MAX_PATH_SIZE 50/*	System-dependent type definitions*/typedef unsigned char byte;typedef unsigned int word;typedef unsigned long longword;typedef byte *address;typedef struct params {	int      op_code;	int      device_id;	char     *buf_p;	int      *count_p;	} params;/*	Global variables accessed only by support routines*/	static longword vec_save;  /* saved interrupt vector */	static int mod_code;                /* module code */                                           	static struct date sys_date;        /* MPX system date */	/* data structures for directory access */        static char current_path[MAX_PATH_SIZE+1];        static int num_entries;        static struct ffblk file_block;        /* handler presence flags */	static flag sysc_hand;	static flag trm_hand;	static flag prt_hand;	static flag com_hand;        /* memory allocation table */	static struct {		void* original;		void* aligned;	} alloc_table[MAX_ALLOC];	static int alloc_ix;                /* current index */	static int num_alloc;               /* no. of allocated blocks *//*	Procedure: sys_init	Purpose: initialize mpx	Parameters: see prototype  	Return value: error code, or OK if no error	Calls: getdate    	Globals: mod_code		vec_save		sys_date		alloc_table, alloc_ix, num_alloc		sysc_hand, term_hand, prt_hand, com_hand	Errors: none*/int sys_init (    int      modules  /* module code */	     ){	mod_code = modules;        vec_save = 0L;        /* no handlers detected yet */	sysc_hand = FALSE;	trm_hand = FALSE;	prt_hand = FALSE;	com_hand = FALSE;	/* initialize allocation table */	for (alloc_ix=0; alloc_ix < MAX_ALLOC; alloc_ix++) {		alloc_table[alloc_ix].original = NULL;		alloc_table[alloc_ix].aligned = NULL;	}	alloc_ix = 0;	num_alloc = 0;	/* if we have reached Module R3, enable system call handling */	if (modules >= MODULE_R3) sysc_hand = TRUE;	/* if we have reached the final module, enable device handlers */	if (modules >= MODULE_F) {		trm_hand = TRUE;		prt_hand = TRUE;		com_hand = TRUE;	}	/* get system date */        getdate(&sys_date);	return (OK);}/*	Procedure: sys_exit	Purpose: terminate mpx	Parameters: none  	Return value: none	Calls: none       	Globals: vec_save*/void sys_exit(void){	longword *vec_p;	/* if trap vector changed, restore it */	if (vec_save != 0L) {		vec_p = (longword*) VEC_ADDR;		*vec_p = vec_save;	}	/* return to host with null error code */	exit(0);}/*	Procedure: sys_set_vec	Purpose: link trap vector to MPX system call handler	Parameters: handler: addr of handler         	Return value: error code; OK if no error	Calls: none       	Globals: vec_save	Errors: none*/int sys_set_vec   ( void interrupt (*handler)() /* system call handler */		){	longword *vec_p;			vec_p = (longword*) VEC_ADDR;		vec_save = *vec_p;		*vec_p = (longword) handler;	return (0);}/*	Procedure: sys_req	Purpose: Request a system service	Inputs:		op_code           operation code		device_id         device identifier		buf_p             addresso f data buffer		count_p           address of size of buffer	Returns: Result or error code, depending on service		Services supported:	IDLE     null operation				READ     input from a device				WRITE    output to a device				CLEAR    clear terminal screen				GOTOXY   absolute cursor position				EXIT     terminate the caller	Calls:   fgets		strlen			Globals: none		Errors:  ERR_SUP_INVDEV    invalid device		ERR_SUP_INVOPC    invalid operation code		ERR_SUP_INVPOS    invalid character position		ERR_SUP_RDFAIL    read failed		ERR_SUP_WRFAIL    write failed	Description:	For Modules R1 through R4,	this procedure is used only for terminal I/O.	Later modules support both reading and	writing for several devices.	For Modules R1 through R4,	sys_req uses the ANSI C function "fgets."	Later modules may use alternate functions and device drivers.*/int sys_req (   int      op_code, /* operation code */		int      device_id,        /* device id */		char*    buf_p,            /* I/O buffer */		int*     count_p           /* address of count */		){	int      rval;    /* result or error code */	char     *rp;     /* return pointer for fgets */	char     rc;      /* return char for fputc */        params    *param_p; /* pointer to parameter record in stack */	flag     docall;  /* true if system call interrupt wanted */	int      ix;      /* temporary index */	docall = FALSE;	rval = OK;	switch (op_code) {		case IDLE:		if (sysc_hand) docall = TRUE;		break; 				case READ:		switch (device_id) {				case TERMINAL:			if (trm_hand) docall = TRUE;			else {				rp = fgets(buf_p,*count_p,stdin);				if (rp==NULL) rval = ERR_SUP_RDFAIL;				else rval = strlen(buf_p);			}			break;					case COM_PORT:			if (com_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					default:			rval = ERR_SUP_INVDEV;					}		break;	case WRITE:		switch (device_id) {				case TERMINAL:			if (trm_hand) docall = TRUE;			else {				rval = *count_p;				for (ix=0; ix<*count_p; ix++) {					rc = fputc(buf_p[ix],stdout);					if (rc == EOF) {						rval = ERR_SUP_WRFAIL;						break;					}				}			}			break;					case COM_PORT:			if (com_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					case PRINTER:			if (prt_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					default:			rval = ERR_SUP_INVDEV;					}		break;	case CLEAR:		if (device_id==TERMINAL) {			if (trm_hand) docall = TRUE;			else {			     clrscr();				rval = 0;			}		}		else rval = ERR_SUP_INVDEV;		break;			case GOTOXY:		if (device_id==TERMINAL) {			if (trm_hand) docall = TRUE;			else {				if (*count_p != 2) rval = ERR_SUP_WRFAIL;				else if ((*buf_p<0)					|| (*buf_p > MAX_XPOS))					rval = ERR_SUP_WRFAIL;				else if ((*(buf_p+1)<0)					|| (*(buf_p+1) > MAX_YPOS))					rval = ERR_SUP_WRFAIL;				else {					gotoxy(*buf_p + 1,						*(buf_p+1) + 1);					rval = 0;				}			}		}		else rval = ERR_SUP_INVDEV;		break;			/* EXIT - terminate the calling process */	/* legal only when a system call handler is present */	case EXIT:		if (sysc_hand) docall = TRUE;		else rval = ERR_SUP_INVOPC;		break; 	default:		rval = ERR_SUP_INVOPC;			}		/* Invoke user's call handler if present.	   If the call is an IO request, return will occur	   only after the request is complete.	*/	if (docall && (rval==OK)) {		/* invoke the call handler */	_SP = _SP - sizeof(params);		param_p = (params*) MK_FP(_SS,_SP);	       param_p->op_code = op_code;	       param_p->device_id = device_id;	       param_p->buf_p = buf_p;	       param_p->count_p = count_p;	       geninterrupt(0x60);	       rval = _AX;	       _SP = _SP + sizeof(params);		/* for I/O operations, return count value */		switch(op_code) {		case READ:		case WRITE:		case CLEAR:		case GOTOXY:			rval = *count_p;		}	}	return(rval);}/*	Procedure: sys_alloc_mem	Purpose: Allocate a memory block	Parameters:			size_t size       No. of bytes to allocate	Returns: void* pointer to allocated block;		 null pointer in case of error		 	Calls: calloc		Globals: alloc_table, alloc_ix, num_alloc	For program loading (Module R-4), the blocks must be aligned.	This is achieved by requesting one extra paragraph and	returning the lowest aligned address as the base.  It is	necessary to keep a table of allocated address, original and	aligned, to support correct freeing.	It would seem simpler to use the Turbo-C function allocmem,	which always allocates aligned blocks.  However, allocmem	appears to conflict with the internal allocation of fopen	and other C library routines.*/void *sys_alloc_mem (      size_t   size     /* size in bytes to allocate */		    ){	int ix_save;      /* temp copy of table index */        void *addr;        /* addr returned by calloc (*void) */	word offset;      /* offset of unaligned address */	word seg;         /* segment addr of unaligned address */	void *addr_alig; /* aligned address */	int rem; /* temp for alignment computation */	/* ensure that allocation table is not full */	if (num_alloc >= MAX_ALLOC) {		return(NULL);	}	/* find free entry in allocation table */	ix_save = alloc_ix;	while (alloc_table[alloc_ix].original != NULL) {		alloc_ix++;		if (alloc_ix >= MAX_ALLOC) alloc_ix = 0;		/* safety check -- should never happen! */		if (alloc_ix == ix_save) return(NULL);	}	/* call allocation routine */	/* request 15 extra bytes to ensure alignment is possible */	addr = calloc(size + 15,1);	/* compute aligned base */	offset = FP_OFF(addr);        seg = FP_SEG(addr);	rem = offset % 16;	if (rem > 0) offset = offset + 16 - rem;	addr_alig = MK_FP(seg,offset);	/* insert entries in table */	alloc_table[alloc_ix].original = addr;	alloc_table[alloc_ix].aligned = addr_alig;	/* increment count */	num_alloc++;	return(addr_alig);}/*	Procedure: sys_free_mem	Purpose: free a memory block	Parameters:		void *ptr         ptr to block to allocate	Returns: integer error code; zero if OK		Calls:   free	Globals: alloc_table, num_alloc	Errors:  ERR_SUP_INVMEM    invalid memory block	This procedure receives an aligned address; it must	find and free the corresponding non-aligned one.*/int sys_free_mem (         void     *ptr     /* pointer to block */		 ){	void *free_addr;  /* true (unaligned) block address */	int free_ix;               /* temp table index */	/* ensure valid pointer */	if (ptr==NULL) return(ERR_SUP_INVMEM);	/* Look for the block in the allocation table */	free_addr = NULL;	for (free_ix=0; free_ix<MAX_ALLOC; free_ix++) {		if (alloc_table[free_ix].aligned == ptr) {			free_addr = alloc_table[free_ix].original;			break;		}	}	/* If the block wasn't found, report error */	if (free_addr == NULL) return(ERR_SUP_INVMEM);	/* free the block & clear the table entry */	alloc_table[free_ix].original = NULL;	alloc_table[free_ix].aligned = NULL;        free(free_addr);	/* decrement count */	num_alloc--;	return(OK);}        /*	Procedure: sys_get_date	Purpose: Returns the system date (month, day, year)	Parameters:		date_rec *date_p Pointer to structure of type date	Returns: void		Calls: none		Globals: sys_date        Errors: none*/void sys_get_date (  date_rec*      date_p   /* ptr to date record */		){	date_p->month = sys_date.da_mon;	date_p->day = sys_date.da_day;	date_p->year = sys_date.da_year;}/*	Procedure: sys_set_date	Purpose: Sets the system date (month, day, year)	Parameters:		date_rec *date_p ptr to structure of type date	Returns: error code; OK if no error	Calls:   none        Globals: sys_date	Errors: none*/int sys_set_date (  date_rec*       date_p   /* ptr to date record */		 ){	sys_date.da_mon = date_p->month;        sys_date.da_day = date_p->day;        sys_date.da_year = date_p->year;	return(OK);}/*	Procedure: sys_open_dir	Purpose: open a specified directory	Parameters: char dir_name[]            directory name	Returns: error code; zero if OK	Calls:   findfirst		strncpy  	Globals: current_path, file_block, num_entries	Errors:  ERR_SUP_DIROPN    directory open error		ERR_SUP_INVDIR    invalid directory*/int sys_open_dir (  char  path_name[]        /* directory name */		 ){        char temp_path[MAX_PATH_SIZE];	int res;        int len;        /* ensure there is no directory currently open */	if (current_path[0]!=NULCH) return(ERR_SUP_DIROPN);        /* check pathname for validity */        /* construct temporary search path name */	temp_path[0] = NULCH;	if (path_name != NULL) {		strncpy(temp_path,path_name,MAX_PATH_SIZE-4);	}	/* build wildcard search string */        len = strlen(temp_path);	/* if path is null, use current directory */        if (len==0) strcpy(temp_path,"*.*");	/* handle paths ending in backslash, including root */        else if (temp_path[len-1]=='\\') strcat(temp_path,"*.*");	/* handle paths not ending in backslash */        else strcat(temp_path,"\\*.*");	/* validate the directory by searching for either an ordinary	   file or a directory in it.  This should never fail; even	   empty directories contain the directories "." and ".."	*/		res = findfirst(temp_path, &file_block, FA_DIREC);	if (res!=0)  return(ERR_SUP_INVDIR);        /* save pathname as current, clear entry count */	current_path[0] = NULCH;	if (path_name != NULL) {		strncpy(current_path,path_name,MAX_PATH_SIZE-6);	}	num_entries = 0;	return(OK);}/*	Procedure: sys_get_entry	Purpose: get the next directory entry;	Parameters: char name_buf[]	name buffer		    int buf_size  	buffer capacity		    long *file_size_p	file length buffer         	Returns: error code, or zero if ok	Calls:	findfirst		findnext		strncpy, strcpy, strrchr, strcat    	Globals: current_path, num_entries, file_block	Errors:  ERR_SUP_NOENTR    no such entry*/int sys_get_entry (char    name_buf[],       /* buffer for entry */		   int   buf_size,         /* buffer size */		   long* file_size_p       /* buffer for size value */		  ){	char filename[MAX_PATH_SIZE+1];	int err;        int len;        char *cp;        /* find next MPX file entry, if any */        /* if this is the first call */	if (num_entries==0) {	       /* construct complete search path name */	       len = strlen(current_path);	       if (len==0) strcpy(current_path,"*.MPX");	       else if (current_path[len-1]=='\\') strcat(current_path,"*.MPX");	       else strcat(current_path,"\\*.MPX");	       /* find first entry */		err = findfirst (current_path,&file_block,0);        }        /* otherwise, find next entry */        else err = findnext(&file_block);        if (err<0) return(ERR_SUP_NOENTR);		/* ensure buf_size is not too large */		if (buf_size > MAX_PATH_SIZE) buf_size = MAX_PATH_SIZE;		      /* copy filename to buffer */	filename[buf_size] = NULCH;	strncpy (filename,file_block.ff_name,			 (size_t) buf_size);	/* remove ".MPX" from name */	cp = strrchr(filename, (int) '.');        *cp = NULCH;	/* copy name and size to caller's buffer */        strcpy (name_buf,filename);	*file_size_p = file_block.ff_fsize;        /* count entry */	num_entries++;	return(OK);}/*	Procedure: sys_close_dir	Purpose: close an open directory	Parameters: none	Returns: error code; zero if OK	Calls:   none	Globals: current_path	Errors:  none*/int sys_close_dir (void){	current_path[0] = NULCH;	return(OK);}/*	Procedure: sys_check_program	Purpose: locate and measure a program file	Parameters: see prototype	Returns: program size or error code	Calls:   strlen, strcat		fopen, fread	Globals: none	Errors:  ERR_SUP_NAMLNG    pathname too long		ERR_SUP_FILNFD    file not found		ERR_SUP_FILINV    file invalid*/#define HEADER_SIZE 32int sys_check_program(     char     dir_name[],       /* directory name */			char     prog_name[],      /* program name */			int*     prog_len_p,       /* ptr to prog length */			int*     start_offset_p    /* ptr to start offset */			){        /* buffer for full pathname */	char file_name[MAX_PATH_SIZE+1];        /* buffer for file header */        byte header[HEADER_SIZE];	FILE *file_p;     /* file pointer for C file routines */        int num_read;      /* number of header bytes read */	int file_size;    /* size of complete file */        int header_size;/* size of header */        int code_size;     /* size of program code */        int data_size;     /* size of program data */        int errcode;       /* error code */        /* ensure that path name is not too long */        if ((strlen(dir_name) + strlen(prog_name) + 5)		 > MAX_PATH_SIZE) return(ERR_SUP_NAMLNG);	/* construct path name */	file_name[0] = NULCH;	if (dir_name[0] != NULCH) {		strcat(file_name, dir_name);	        strcat(file_name, "\\");	}        strcat(file_name, prog_name);	strcat(file_name, ".MPX");        /* try to open the file */	errcode = OK;        file_p = fopen(file_name, "rb");        if (file_p == NULL) return(ERR_SUP_FILNFD);	/* read the header, check for EXE signature */        num_read = fread( (void*) header, 1, HEADER_SIZE, file_p);        if (num_read != HEADER_SIZE) {		errcode = ERR_SUP_FILINV;	}        else if ((header[0] != 0x4D) || (header[1] != 0x5A)) {		errcode = ERR_SUP_FILINV;	}        /* close the file, then return if error occurred */        fclose(file_p);	if (errcode!=OK) return(errcode);        /* compute allocation size needed */        file_size = (header[5]*256 + header[4] -1) * 512		+ (header[3]*256 + header[2]);        header_size =(header[9]*256 + header[8])*16;        code_size = file_size - header_size;        data_size = (header[11]*256 + header[10])*16;        /* return total length and starting offset */        *prog_len_p = code_size + data_size;	*start_offset_p = (header[23]*256 + header[22]) * 16;	return(OK);}/*	Procedure: sys_load_program	Purpose: load a program file	Parameters: see prototype	Returns: error code; zero if OK	Calls:   intdosx		segread		strlen, strcat	Globals: none 	Errors:  ERR_SUP_NAMLNG    name too long		ERR_SUP_FILNFD    file not found	       ERR_SUP_FILINV      file invalid		ERR_SUP_PROGSZ    program too large	       ERR_SUP_LDADDR      address not aligned		ERR_SUP_LDFAIL    load failed*/int sys_load_program (     void*    load_addr,        /* address for loading */			int      max_size,         /* memory size */			char     dir_name[],       /* directory name */			char     prog_name[]       /* program name */		      ){	int errcode;      /* error code */        int prog_len;      /* program length */	int offset;       /* offset for starting */	word norm_seg;    /* normalized load address segment */        word norm_off;     /* normalized load address offset */        /* full pathname for file to be loaded */	char file_name[MAX_PATH_SIZE+1];        /* parameter block for MSDOS EXEC function */	struct {		word load_seg;    /* segment address for loading */	       word reloc_seg;     /* segment address for relocation */        }p_block;	union REGS inregs;            /* input register structure */	union REGS outregs;           /* output register structure */	struct SREGS segregs;         /* segment register structure */        /* check program, get length and offset */	errcode = sys_check_program(dir_name, prog_name,					&prog_len, &offset);        if (errcode < 0) return(errcode);        /* ensure that allocated memory is large enough */        if (max_size < prog_len) return(ERR_SUP_PROGSZ);        /* get normalized segment and offset, check alignment */	norm_seg = FP_SEG(load_addr);	norm_off = FP_OFF(load_addr);	norm_seg += norm_off / 16;        norm_off %= 16;	if (norm_off != 0) return(ERR_SUP_LDADDR);        /* ensure that path name is not too long */        if ((strlen(dir_name) + strlen(prog_name) + 5)		 > MAX_PATH_SIZE) return(ERR_SUP_NAMLNG);	/* construct path name */	file_name[0] = NULCH;	if (dir_name[0] != NULCH) {		strcat(file_name, dir_name);	        strcat(file_name, "\\");	}        strcat(file_name, prog_name);	strcat(file_name, ".MPX");        /* get current segment regs */	segread(&segregs);        /* setup function codes */	inregs.h.ah = 0x4B;        /* EXEC function */	inregs.h.al = 0x03;        /* load only */        /* setup parameter block and name pointers */        segregs.ds = FP_SEG(&file_name);	inregs.x.dx = FP_OFF(&file_name);        segregs.es = FP_SEG(&p_block);	inregs.x.bx = FP_OFF(&p_block);        /* setup load segment -- must be normalized */	p_block.load_seg = norm_seg;	p_block.reloc_seg = p_block.load_seg;        /* call the MS-DOS loader */	errcode = intdosx(&inregs,&outregs,&segregs);        errcode = errcode;        /* check for error */	if (outregs.x.cflag) return(ERR_SUP_LDFAIL);	/* load successful */	return(OK);}/* END OF FILE */num_alloc1,0
/***********************************************************************	MPX: The MultiProgramming eXecutive	Project to Accompany	A Practical Approach to Operating Systems	Malcolm G. Lane & James D. Mooney	Copyright 1993, P.W.S. Kent Publishing Co., Boston, MA.		File Name: mpx_supt.c	Authors: J.J. Patnesky, A. Ghosal, M. Lane, J. Mooney	Version: 2.1b	Date: 01/31/08	Purpose: Support routines for MPX-PC		Modules: all	Environment:      IBM-PC (XT, AT or PS/2)			MS-DOS 3.3 or later			TURBO-C 3.0 or TURBO-C++ 1.0 or later	Compile using the LARGE MODEL and SS NOT equal to DS.	All addresses and pointers are "far", and	CS, DS and SS are independent.	Procedures in this file:		sys_init		sys_exit		sys_set_vec		sys_req		sys_alloc_mem		sys_free_mem		sys_get_date		sys_set_date		sys_open_dir		sys_get_entry		sys_close_dir	       sys_check_program	       sys_load_program************************************************************************Change Log:	07/16/88  akg	added comments	02/25/92  jdm	full revision, UNIX version	04/14/92  jdm	Macintosh version	05/15/92  jdm	cleanup and documentation	07/14/92  jdm	update for revised specs        08/13/92  jdm 	revised IBM version; added private heap        10/14/92  jdm 	added check and load procedures        10/18/92  jdm 	revised sys_alloc_mem for alignment	11/17/92  jdm	true heap mgt, aligned, using calloc & free	11/19/92  jdm	enable device handling for final module	12/31/92  jdm	revised sys_req parameters	01/02/93  jdm	return count value after I/O	01/03/93  jdm	revised error names and codes	01/27/93  jdm	corrected count for line input in sys_req			fixed open_dir to handle null lines	02/24/93  jdm	changed sys_set_vec param to interrupt	03/08/93  jdm	corrections to sys_check & sys_load	03/20/93  jdm	stack switch in free, check, and load	04/22/93  jdm	corrected index conflict in sys_free_mem			added safety escape in alloc table search	07/28/93  jdm	conversion to large model	09/01/93  jdm	fixed allocation bug;  made date private	09/14/93  jdm	cleaned up memory allocation        09/16/93  jdm	adjusted program load for large model        09/30/93  jdm	modified for correct list of root directory	11/01/94  jdm	changed load file read to binary	09/18/95  jdm	fixed get_entry to default to current, not root	01/31/08  jdm   fixed possible overflow problem in get_entry************************************************************************/#include "mpx_supt.h"#include <stdlib.h>#include <dos.h>#include <dir.h>#include <errno.h>#include <conio.h>#include <alloc.h>#define VEC_ADDR (0x60L*4)#define MAX_ALLOC 200#define MAX_XPOS 79#define MAX_YPOS 24#define MAX_PATH_SIZE 50/*	System-dependent type definitions*/typedef unsigned char byte;typedef unsigned int word;typedef unsigned long longword;typedef byte *address;typedef struct params {	int      op_code;	int      device_id;	char     *buf_p;	int      *count_p;	} params;/*	Global variables accessed only by support routines*/	static longword vec_save;  /* saved interrupt vector */	static int mod_code;                /* module code */                                           	static struct date sys_date;        /* MPX system date */	/* data structures for directory access */        static char current_path[MAX_PATH_SIZE+1];        static int num_entries;        static struct ffblk file_block;        /* handler presence flags */	static flag sysc_hand;	static flag trm_hand;	static flag prt_hand;	static flag com_hand;        /* memory allocation table */	static struct {		void* original;		void* aligned;	} alloc_table[MAX_ALLOC];	static int alloc_ix;                /* current index */	static int num_alloc;               /* no. of allocated blocks *//*	Procedure: sys_init	Purpose: initialize mpx	Parameters: see prototype  	Return value: error code, or OK if no error	Calls: getdate    	Globals: mod_code		vec_save		sys_date		alloc_table, alloc_ix, num_alloc		sysc_hand, term_hand, prt_hand, com_hand	Errors: none*/int sys_init (    int      modules  /* module code */	     ){	mod_code = modules;        vec_save = 0L;        /* no handlers detected yet */	sysc_hand = FALSE;	trm_hand = FALSE;	prt_hand = FALSE;	com_hand = FALSE;	/* initialize allocation table */	for (alloc_ix=0; alloc_ix < MAX_ALLOC; alloc_ix++) {		alloc_table[alloc_ix].original = NULL;		alloc_table[alloc_ix].aligned = NULL;	}	alloc_ix = 0;	num_alloc = 0;	/* if we have reached Module R3, enable system call handling */	if (modules >= MODULE_R3) sysc_hand = TRUE;	/* if we have reached the final module, enable device handlers */	if (modules >= MODULE_F) {		trm_hand = TRUE;		prt_hand = TRUE;		com_hand = TRUE;	}	/* get system date */        getdate(&sys_date);	return (OK);}/*	Procedure: sys_exit	Purpose: terminate mpx	Parameters: none  	Return value: none	Calls: none       	Globals: vec_save*/void sys_exit(void){	longword *vec_p;	/* if trap vector changed, restore it */	if (vec_save != 0L) {		vec_p = (longword*) VEC_ADDR;		*vec_p = vec_save;	}	/* return to host with null error code */	exit(0);}/*	Procedure: sys_set_vec	Purpose: link trap vector to MPX system call handler	Parameters: handler: addr of handler         	Return value: error code; OK if no error	Calls: none       	Globals: vec_save	Errors: none*/int sys_set_vec   ( void interrupt (*handler)() /* system call handler */		){	longword *vec_p;			vec_p = (longword*) VEC_ADDR;		vec_save = *vec_p;		*vec_p = (longword) handler;	return (0);}/*	Procedure: sys_req	Purpose: Request a system service	Inputs:		op_code           operation code		device_id         device identifier		buf_p             addresso f data buffer		count_p           address of size of buffer	Returns: Result or error code, depending on service		Services supported:	IDLE     null operation				READ     input from a device				WRITE    output to a device				CLEAR    clear terminal screen				GOTOXY   absolute cursor position				EXIT     terminate the caller	Calls:   fgets		strlen			Globals: none		Errors:  ERR_SUP_INVDEV    invalid device		ERR_SUP_INVOPC    invalid operation code		ERR_SUP_INVPOS    invalid character position		ERR_SUP_RDFAIL    read failed		ERR_SUP_WRFAIL    write failed	Description:	For Modules R1 through R4,	this procedure is used only for terminal I/O.	Later modules support both reading and	writing for several devices.	For Modules R1 through R4,	sys_req uses the ANSI C function "fgets."	Later modules may use alternate functions and device drivers.*/int sys_req (   int      op_code, /* operation code */		int      device_id,        /* device id */		char*    buf_p,            /* I/O buffer */		int*     count_p           /* address of count */		){	int      rval;    /* result or error code */	char     *rp;     /* return pointer for fgets */	char     rc;      /* return char for fputc */        params    *param_p; /* pointer to parameter record in stack */	flag     docall;  /* true if system call interrupt wanted */	int      ix;      /* temporary index */	docall = FALSE;	rval = OK;	switch (op_code) {		case IDLE:		if (sysc_hand) docall = TRUE;		break; 				case READ:		switch (device_id) {				case TERMINAL:			if (trm_hand) docall = TRUE;			else {				rp = fgets(buf_p,*count_p,stdin);				if (rp==NULL) rval = ERR_SUP_RDFAIL;				else rval = strlen(buf_p);			}			break;					case COM_PORT:			if (com_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					default:			rval = ERR_SUP_INVDEV;					}		break;	case WRITE:		switch (device_id) {				case TERMINAL:			if (trm_hand) docall = TRUE;			else {				rval = *count_p;				for (ix=0; ix<*count_p; ix++) {					rc = fputc(buf_p[ix],stdout);					if (rc == EOF) {						rval = ERR_SUP_WRFAIL;						break;					}				}			}			break;					case COM_PORT:			if (com_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					case PRINTER:			if (prt_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					default:			rval = ERR_SUP_INVDEV;					}		break;	case CLEAR:		if (device_id==TERMINAL) {			if (trm_hand) docall = TRUE;			else {			     clrscr();				rval = 0;			}		}		else rval = ERR_SUP_INVDEV;		break;			case GOTOXY:		if (device_id==TERMINAL) {			if (trm_hand) docall = TRUE;			else {				if (*count_p != 2) rval = ERR_SUP_WRFAIL;				else if ((*buf_p<0)					|| (*buf_p > MAX_XPOS))					rval = ERR_SUP_WRFAIL;				else if ((*(buf_p+1)<0)					|| (*(buf_p+1) > MAX_YPOS))					rval = ERR_SUP_WRFAIL;				else {					gotoxy(*buf_p + 1,						*(buf_p+1) + 1);					rval = 0;				}			}		}		else rval = ERR_SUP_INVDEV;		break;			/* EXIT - terminate the calling process */	/* legal only when a system call handler is present */	case EXIT:		if (sysc_hand) docall = TRUE;		else rval = ERR_SUP_INVOPC;		break; 	default:		rval = ERR_SUP_INVOPC;			}		/* Invoke user's call handler if present.	   If the call is an IO request, return will occur	   only after the request is complete.	*/	if (docall && (rval==OK)) {		/* invoke the call handler */	_SP = _SP - sizeof(params);		param_p = (params*) MK_FP(_SS,_SP);	       param_p->op_code = op_code;	       param_p->device_id = device_id;	       param_p->buf_p = buf_p;	       param_p->count_p = count_p;	       geninterrupt(0x60);	       rval = _AX;	       _SP = _SP + sizeof(params);		/* for I/O operations, return count value */		switch(op_code) {		case READ:		case WRITE:		case CLEAR:		case GOTOXY:			rval = *count_p;		}	}	return(rval);}/*	Procedure: sys_alloc_mem	Purpose: Allocate a memory block	Parameters:			size_t size       No. of bytes to allocate	Returns: void* pointer to allocated block;		 null pointer in case of error		 	Calls: calloc		Globals: alloc_table, alloc_ix, num_alloc	For program loading (Module R-4), the blocks must be aligned.	This is achieved by requesting one extra paragraph and	returning the lowest aligned address as the base.  It is	necessary to keep a table of allocated address, original and	aligned, to support correct freeing.	It would seem simpler to use the Turbo-C function allocmem,	which always allocates aligned blocks.  However, allocmem	appears to conflict with the internal allocation of fopen	and other C library routines.*/void *sys_alloc_mem (      size_t   size     /* size in bytes to allocate */		    ){	int ix_save;      /* temp copy of table index */        void *addr;        /* addr returned by calloc (*void) */	word offset;      /* offset of unaligned address */	word seg;         /* segment addr of unaligned address */	void *addr_alig; /* aligned address */	int rem; /* temp for alignment computation */	/* ensure that allocation table is not full */	if (num_alloc >= MAX_ALLOC) {		return(NULL);	}	/* find free entry in allocation table */	ix_save = alloc_ix;	while (alloc_table[alloc_ix].original != NULL) {		alloc_ix++;		if (alloc_ix >= MAX_ALLOC) alloc_ix = 0;		/* safety check -- should never happen! */		if (alloc_ix == ix_save) return(NULL);	}	/* call allocation routine */	/* request 15 extra bytes to ensure alignment is possible */	addr = calloc(size + 15,1);	/* compute aligned base */	offset = FP_OFF(addr);        seg = FP_SEG(addr);	rem = offset % 16;	if (rem > 0) offset = offset + 16 - rem;	addr_alig = MK_FP(seg,offset);	/* insert entries in table */	alloc_table[alloc_ix].original = addr;	alloc_table[alloc_ix].aligned = addr_alig;	/* increment count */	num_alloc++;	return(addr_alig);}/*	Procedure: sys_free_mem	Purpose: free a memory block	Parameters:		void *ptr         ptr to block to allocate	Returns: integer error code; zero if OK		Calls:   free	Globals: alloc_table, num_alloc	Errors:  ERR_SUP_INVMEM    invalid memory block	This procedure receives an aligned address; it must	find and free the corresponding non-aligned one.*/int sys_free_mem (         void     *ptr     /* pointer to block */		 ){	void *free_addr;  /* true (unaligned) block address */	int free_ix;               /* temp table index */	/* ensure valid pointer */	if (ptr==NULL) return(ERR_SUP_INVMEM);	/* Look for the block in the allocation table */	free_addr = NULL;	for (free_ix=0; free_ix<MAX_ALLOC; free_ix++) {		if (alloc_table[free_ix].aligned == ptr) {			free_addr = alloc_table[free_ix].original;			break;		}	}	/* If the block wasn't found, report error */	if (free_addr == NULL) return(ERR_SUP_INVMEM);	/* free the block & clear the table entry */	alloc_table[free_ix].original = NULL;	alloc_table[free_ix].aligned = NULL;        free(free_addr);	/* decrement count */	num_alloc--;	return(OK);}        /*	Procedure: sys_get_date	Purpose: Returns the system date (month, day, year)	Parameters:		date_rec *date_p Pointer to structure of type date	Returns: void		Calls: none		Globals: sys_date        Errors: none*/void sys_get_date (  date_rec*      date_p   /* ptr to date record */		){	date_p->month = sys_date.da_mon;	date_p->day = sys_date.da_day;	date_p->year = sys_date.da_year;}/*	Procedure: sys_set_date	Purpose: Sets the system date (month, day, year)	Parameters:		date_rec *date_p ptr to structure of type date	Returns: error code; OK if no error	Calls:   none        Globals: sys_date	Errors: none*/int sys_set_date (  date_rec*       date_p   /* ptr to date record */		 ){	sys_date.da_mon = date_p->month;        sys_date.da_day = date_p->day;        sys_date.da_year = date_p->year;	return(OK);}/*	Procedure: sys_open_dir	Purpose: open a specified directory	Parameters: char dir_name[]            directory name	Returns: error code; zero if OK	Calls:   findfirst		strncpy  	Globals: current_path, file_block, num_entries	Errors:  ERR_SUP_DIROPN    directory open error		ERR_SUP_INVDIR    invalid directory*/int sys_open_dir (  char  path_name[]        /* directory name */		 ){        char temp_path[MAX_PATH_SIZE];	int res;        int len;        /* ensure there is no directory currently open */	if (current_path[0]!=NULCH) return(ERR_SUP_DIROPN);        /* check pathname for validity */        /* construct temporary search path name */	temp_path[0] = NULCH;	if (path_name != NULL) {		strncpy(temp_path,path_name,MAX_PATH_SIZE-4);	}	/* build wildcard search string */        len = strlen(temp_path);	/* if path is null, use current directory */        if (len==0) strcpy(temp_path,"*.*");	/* handle paths ending in backslash, including root */        else if (temp_path[len-1]=='\\') strcat(temp_path,"*.*");	/* handle paths not ending in backslash */        else strcat(temp_path,"\\*.*");	/* validate the directory by searching for either an ordinary	   file or a directory in it.  This should never fail; even	   empty directories contain the directories "." and ".."	*/		res = findfirst(temp_path, &file_block, FA_DIREC);	if (res!=0)  return(ERR_SUP_INVDIR);        /* save pathname as current, clear entry count */	current_path[0] = NULCH;	if (path_name != NULL) {		strncpy(current_path,path_name,MAX_PATH_SIZE-6);	}	num_entries = 0;	return(OK);}/*	Procedure: sys_get_entry	Purpose: get the next directory entry;	Parameters: char name_buf[]	name buffer		    int buf_size  	buffer capacity		    long *file_size_p	file length buffer         	Returns: error code, or zero if ok	Calls:	findfirst		findnext		strncpy, strcpy, strrchr, strcat    	Globals: current_path, num_entries, file_block	Errors:  ERR_SUP_NOENTR    no such entry*/int sys_get_entry (char    name_buf[],       /* buffer for entry */		   int   buf_size,         /* buffer size */		   long* file_size_p       /* buffer for size value */		  ){	char filename[MAX_PATH_SIZE+1];	int err;        int len;        char *cp;        /* find next MPX file entry, if any */        /* if this is the first call */	if (num_entries==0) {	       /* construct complete search path name */	       len = strlen(current_path);	       if (len==0) strcpy(current_path,"*.MPX");	       else if (current_path[len-1]=='\\') strcat(current_path,"*.MPX");	       else strcat(current_path,"\\*.MPX");	       /* find first entry */		err = findfirst (current_path,&file_block,0);        }        /* otherwise, find next entry */        else err = findnext(&file_block);        if (err<0) return(ERR_SUP_NOENTR);		/* ensure buf_size is not too large */		if (buf_size > MAX_PATH_SIZE) buf_size = MAX_PATH_SIZE;		      /* copy filename to buffer */	filename[buf_size] = NULCH;	strncpy (filename,file_block.ff_name,			 (size_t) buf_size);	/* remove ".MPX" from name */	cp = strrchr(filename, (int) '.');        *cp = NULCH;	/* copy name and size to caller's buffer */        strcpy (name_buf,filename);	*file_size_p = file_block.ff_fsize;        /* count entry */	num_entries++;	return(OK);}/*	Procedure: sys_close_dir	Purpose: close an open directory	Parameters: none	Returns: error code; zero if OK	Calls:   none	Globals: current_path	Errors:  none*/int sys_close_dir (void){	current_path[0] = NULCH;	return(OK);}/*	Procedure: sys_check_program	Purpose: locate and measure a program file	Parameters: see prototype	Returns: program size or error code	Calls:   strlen, strcat		fopen, fread	Globals: none	Errors:  ERR_SUP_NAMLNG    pathname too long		ERR_SUP_FILNFD    file not found		ERR_SUP_FILINV    file invalid*/#define HEADER_SIZE 32int sys_check_program(     char     dir_name[],       /* directory name */			char     prog_name[],      /* program name */			int*     prog_len_p,       /* ptr to prog length */			int*     start_offset_p    /* ptr to start offset */			){        /* buffer for full pathname */	char file_name[MAX_PATH_SIZE+1];        /* buffer for file header */        byte header[HEADER_SIZE];	FILE *file_p;     /* file pointer for C file routines */        int num_read;      /* number of header bytes read */	int file_size;    /* size of complete file */        int header_size;/* size of header */        int code_size;     /* size of program code */        int data_size;     /* size of program data */        int errcode;       /* error code */        /* ensure that path name is not too long */        if ((strlen(dir_name) + strlen(prog_name) + 5)		 > MAX_PATH_SIZE) return(ERR_SUP_NAMLNG);	/* construct path name */	file_name[0] = NULCH;	if (dir_name[0] != NULCH) {		strcat(file_name, dir_name);	        strcat(file_name, "\\");	}        strcat(file_name, prog_name);	strcat(file_name, ".MPX");        /* try to open the file */	errcode = OK;        file_p = fopen(file_name, "rb");        if (file_p == NULL) return(ERR_SUP_FILNFD);	/* read the header, check for EXE signature */        num_read = fread( (void*) header, 1, HEADER_SIZE, file_p);        if (num_read != HEADER_SIZE) {		errcode = ERR_SUP_FILINV;	}        else if ((header[0] != 0x4D) || (header[1] != 0x5A)) {		errcode = ERR_SUP_FILINV;	}        /* close the file, then return if error occurred */        fclose(file_p);	if (errcode!=OK) return(errcode);        /* compute allocation size needed */        file_size = (header[5]*256 + header[4] -1) * 512		+ (header[3]*256 + header[2]);        header_size =(header[9]*256 + header[8])*16;        code_size = file_size - header_size;        data_size = (header[11]*256 + header[10])*16;        /* return total length and starting offset */        *prog_len_p = code_size + data_size;	*start_offset_p = (header[23]*256 + header[22]) * 16;	return(OK);}/*	Procedure: sys_load_program	Purpose: load a program file	Parameters: see prototype	Returns: error code; zero if OK	Calls:   intdosx		segread		strlen, strcat	Globals: none 	Errors:  ERR_SUP_NAMLNG    name too long		ERR_SUP_FILNFD    file not found	       ERR_SUP_FILINV      file invalid		ERR_SUP_PROGSZ    program too large	       ERR_SUP_LDADDR      address not aligned		ERR_SUP_LDFAIL    load failed*/int sys_load_program (     void*    load_addr,        /* address for loading */			int      max_size,         /* memory size */			char     dir_name[],       /* directory name */			char     prog_name[]       /* program name */		      ){	int errcode;      /* error code */        int prog_len;      /* program length */	int offset;       /* offset for starting */	word norm_seg;    /* normalized load address segment */        word norm_off;     /* normalized load address offset */        /* full pathname for file to be loaded */	char file_name[MAX_PATH_SIZE+1];        /* parameter block for MSDOS EXEC function */	struct {		word load_seg;    /* segment address for loading */	       word reloc_seg;     /* segment address for relocation */        }p_block;	union REGS inregs;            /* input register structure */	union REGS outregs;           /* output register structure */	struct SREGS segregs;         /* segment register structure */        /* check program, get length and offset */	errcode = sys_check_program(dir_name, prog_name,					&prog_len, &offset);        if (errcode < 0) return(errcode);        /* ensure that allocated memory is large enough */        if (max_size < prog_len) return(ERR_SUP_PROGSZ);        /* get normalized segment and offset, check alignment */	norm_seg = FP_SEG(load_addr);	norm_off = FP_OFF(load_addr);	norm_seg += norm_off / 16;        norm_off %= 16;	if (norm_off != 0) return(ERR_SUP_LDADDR);        /* ensure that path name is not too long */        if ((strlen(dir_name) + strlen(prog_name) + 5)		 > MAX_PATH_SIZE) return(ERR_SUP_NAMLNG);	/* construct path name */	file_name[0] = NULCH;	if (dir_name[0] != NULCH) {		strcat(file_name, dir_name);	        strcat(file_name, "\\");	}        strcat(file_name, prog_name);	strcat(file_name, ".MPX");        /* get current segment regs */	segread(&segregs);        /* setup function codes */	inregs.h.ah = 0x4B;        /* EXEC function */	inregs.h.al = 0x03;        /* load only */        /* setup parameter block and name pointers */        segregs.ds = FP_SEG(&file_name);	inregs.x.dx = FP_OFF(&file_name);        segregs.es = FP_SEG(&p_block);	inregs.x.bx = FP_OFF(&p_block);        /* setup load segment -- must be normalized */	p_block.load_seg = norm_seg;	p_block.reloc_seg = p_block.load_seg;        /* call the MS-DOS loader */	errcode = intdosx(&inregs,&outregs,&segregs);        errcode = errcode;        /* check for error */	if (outregs.x.cflag) return(ERR_SUP_LDFAIL);	/* load successful */	return(OK);}/* END OF FILE */sys_init1,0
/***********************************************************************	MPX: The MultiProgramming eXecutive	Project to Accompany	A Practical Approach to Operating Systems	Malcolm G. Lane & James D. Mooney	Copyright 1993, P.W.S. Kent Publishing Co., Boston, MA.		File Name: mpx_supt.c	Authors: J.J. Patnesky, A. Ghosal, M. Lane, J. Mooney	Version: 2.1b	Date: 01/31/08	Purpose: Support routines for MPX-PC		Modules: all	Environment:      IBM-PC (XT, AT or PS/2)			MS-DOS 3.3 or later			TURBO-C 3.0 or TURBO-C++ 1.0 or later	Compile using the LARGE MODEL and SS NOT equal to DS.	All addresses and pointers are "far", and	CS, DS and SS are independent.	Procedures in this file:		sys_init		sys_exit		sys_set_vec		sys_req		sys_alloc_mem		sys_free_mem		sys_get_date		sys_set_date		sys_open_dir		sys_get_entry		sys_close_dir	       sys_check_program	       sys_load_program************************************************************************Change Log:	07/16/88  akg	added comments	02/25/92  jdm	full revision, UNIX version	04/14/92  jdm	Macintosh version	05/15/92  jdm	cleanup and documentation	07/14/92  jdm	update for revised specs        08/13/92  jdm 	revised IBM version; added private heap        10/14/92  jdm 	added check and load procedures        10/18/92  jdm 	revised sys_alloc_mem for alignment	11/17/92  jdm	true heap mgt, aligned, using calloc & free	11/19/92  jdm	enable device handling for final module	12/31/92  jdm	revised sys_req parameters	01/02/93  jdm	return count value after I/O	01/03/93  jdm	revised error names and codes	01/27/93  jdm	corrected count for line input in sys_req			fixed open_dir to handle null lines	02/24/93  jdm	changed sys_set_vec param to interrupt	03/08/93  jdm	corrections to sys_check & sys_load	03/20/93  jdm	stack switch in free, check, and load	04/22/93  jdm	corrected index conflict in sys_free_mem			added safety escape in alloc table search	07/28/93  jdm	conversion to large model	09/01/93  jdm	fixed allocation bug;  made date private	09/14/93  jdm	cleaned up memory allocation        09/16/93  jdm	adjusted program load for large model        09/30/93  jdm	modified for correct list of root directory	11/01/94  jdm	changed load file read to binary	09/18/95  jdm	fixed get_entry to default to current, not root	01/31/08  jdm   fixed possible overflow problem in get_entry************************************************************************/#include "mpx_supt.h"#include <stdlib.h>#include <dos.h>#include <dir.h>#include <errno.h>#include <conio.h>#include <alloc.h>#define VEC_ADDR (0x60L*4)#define MAX_ALLOC 200#define MAX_XPOS 79#define MAX_YPOS 24#define MAX_PATH_SIZE 50/*	System-dependent type definitions*/typedef unsigned char byte;typedef unsigned int word;typedef unsigned long longword;typedef byte *address;typedef struct params {	int      op_code;	int      device_id;	char     *buf_p;	int      *count_p;	} params;/*	Global variables accessed only by support routines*/	static longword vec_save;  /* saved interrupt vector */	static int mod_code;                /* module code */                                           	static struct date sys_date;        /* MPX system date */	/* data structures for directory access */        static char current_path[MAX_PATH_SIZE+1];        static int num_entries;        static struct ffblk file_block;        /* handler presence flags */	static flag sysc_hand;	static flag trm_hand;	static flag prt_hand;	static flag com_hand;        /* memory allocation table */	static struct {		void* original;		void* aligned;	} alloc_table[MAX_ALLOC];	static int alloc_ix;                /* current index */	static int num_alloc;               /* no. of allocated blocks *//*	Procedure: sys_init	Purpose: initialize mpx	Parameters: see prototype  	Return value: error code, or OK if no error	Calls: getdate    	Globals: mod_code		vec_save		sys_date		alloc_table, alloc_ix, num_alloc		sysc_hand, term_hand, prt_hand, com_hand	Errors: none*/int sys_init (    int      modules  /* module code */	     ){	mod_code = modules;        vec_save = 0L;        /* no handlers detected yet */	sysc_hand = FALSE;	trm_hand = FALSE;	prt_hand = FALSE;	com_hand = FALSE;	/* initialize allocation table */	for (alloc_ix=0; alloc_ix < MAX_ALLOC; alloc_ix++) {		alloc_table[alloc_ix].original = NULL;		alloc_table[alloc_ix].aligned = NULL;	}	alloc_ix = 0;	num_alloc = 0;	/* if we have reached Module R3, enable system call handling */	if (modules >= MODULE_R3) sysc_hand = TRUE;	/* if we have reached the final module, enable device handlers */	if (modules >= MODULE_F) {		trm_hand = TRUE;		prt_hand = TRUE;		com_hand = TRUE;	}	/* get system date */        getdate(&sys_date);	return (OK);}/*	Procedure: sys_exit	Purpose: terminate mpx	Parameters: none  	Return value: none	Calls: none       	Globals: vec_save*/void sys_exit(void){	longword *vec_p;	/* if trap vector changed, restore it */	if (vec_save != 0L) {		vec_p = (longword*) VEC_ADDR;		*vec_p = vec_save;	}	/* return to host with null error code */	exit(0);}/*	Procedure: sys_set_vec	Purpose: link trap vector to MPX system call handler	Parameters: handler: addr of handler         	Return value: error code; OK if no error	Calls: none       	Globals: vec_save	Errors: none*/int sys_set_vec   ( void interrupt (*handler)() /* system call handler */		){	longword *vec_p;			vec_p = (longword*) VEC_ADDR;		vec_save = *vec_p;		*vec_p = (longword) handler;	return (0);}/*	Procedure: sys_req	Purpose: Request a system service	Inputs:		op_code           operation code		device_id         device identifier		buf_p             addresso f data buffer		count_p           address of size of buffer	Returns: Result or error code, depending on service		Services supported:	IDLE     null operation				READ     input from a device				WRITE    output to a device				CLEAR    clear terminal screen				GOTOXY   absolute cursor position				EXIT     terminate the caller	Calls:   fgets		strlen			Globals: none		Errors:  ERR_SUP_INVDEV    invalid device		ERR_SUP_INVOPC    invalid operation code		ERR_SUP_INVPOS    invalid character position		ERR_SUP_RDFAIL    read failed		ERR_SUP_WRFAIL    write failed	Description:	For Modules R1 through R4,	this procedure is used only for terminal I/O.	Later modules support both reading and	writing for several devices.	For Modules R1 through R4,	sys_req uses the ANSI C function "fgets."	Later modules may use alternate functions and device drivers.*/int sys_req (   int      op_code, /* operation code */		int      device_id,        /* device id */		char*    buf_p,            /* I/O buffer */		int*     count_p           /* address of count */		){	int      rval;    /* result or error code */	char     *rp;     /* return pointer for fgets */	char     rc;      /* return char for fputc */        params    *param_p; /* pointer to parameter record in stack */	flag     docall;  /* true if system call interrupt wanted */	int      ix;      /* temporary index */	docall = FALSE;	rval = OK;	switch (op_code) {		case IDLE:		if (sysc_hand) docall = TRUE;		break; 				case READ:		switch (device_id) {				case TERMINAL:			if (trm_hand) docall = TRUE;			else {				rp = fgets(buf_p,*count_p,stdin);				if (rp==NULL) rval = ERR_SUP_RDFAIL;				else rval = strlen(buf_p);			}			break;					case COM_PORT:			if (com_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					default:			rval = ERR_SUP_INVDEV;					}		break;	case WRITE:		switch (device_id) {				case TERMINAL:			if (trm_hand) docall = TRUE;			else {				rval = *count_p;				for (ix=0; ix<*count_p; ix++) {					rc = fputc(buf_p[ix],stdout);					if (rc == EOF) {						rval = ERR_SUP_WRFAIL;						break;					}				}			}			break;					case COM_PORT:			if (com_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					case PRINTER:			if (prt_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					default:			rval = ERR_SUP_INVDEV;					}		break;	case CLEAR:		if (device_id==TERMINAL) {			if (trm_hand) docall = TRUE;			else {			     clrscr();				rval = 0;			}		}		else rval = ERR_SUP_INVDEV;		break;			case GOTOXY:		if (device_id==TERMINAL) {			if (trm_hand) docall = TRUE;			else {				if (*count_p != 2) rval = ERR_SUP_WRFAIL;				else if ((*buf_p<0)					|| (*buf_p > MAX_XPOS))					rval = ERR_SUP_WRFAIL;				else if ((*(buf_p+1)<0)					|| (*(buf_p+1) > MAX_YPOS))					rval = ERR_SUP_WRFAIL;				else {					gotoxy(*buf_p + 1,						*(buf_p+1) + 1);					rval = 0;				}			}		}		else rval = ERR_SUP_INVDEV;		break;			/* EXIT - terminate the calling process */	/* legal only when a system call handler is present */	case EXIT:		if (sysc_hand) docall = TRUE;		else rval = ERR_SUP_INVOPC;		break; 	default:		rval = ERR_SUP_INVOPC;			}		/* Invoke user's call handler if present.	   If the call is an IO request, return will occur	   only after the request is complete.	*/	if (docall && (rval==OK)) {		/* invoke the call handler */	_SP = _SP - sizeof(params);		param_p = (params*) MK_FP(_SS,_SP);	       param_p->op_code = op_code;	       param_p->device_id = device_id;	       param_p->buf_p = buf_p;	       param_p->count_p = count_p;	       geninterrupt(0x60);	       rval = _AX;	       _SP = _SP + sizeof(params);		/* for I/O operations, return count value */		switch(op_code) {		case READ:		case WRITE:		case CLEAR:		case GOTOXY:			rval = *count_p;		}	}	return(rval);}/*	Procedure: sys_alloc_mem	Purpose: Allocate a memory block	Parameters:			size_t size       No. of bytes to allocate	Returns: void* pointer to allocated block;		 null pointer in case of error		 	Calls: calloc		Globals: alloc_table, alloc_ix, num_alloc	For program loading (Module R-4), the blocks must be aligned.	This is achieved by requesting one extra paragraph and	returning the lowest aligned address as the base.  It is	necessary to keep a table of allocated address, original and	aligned, to support correct freeing.	It would seem simpler to use the Turbo-C function allocmem,	which always allocates aligned blocks.  However, allocmem	appears to conflict with the internal allocation of fopen	and other C library routines.*/void *sys_alloc_mem (      size_t   size     /* size in bytes to allocate */		    ){	int ix_save;      /* temp copy of table index */        void *addr;        /* addr returned by calloc (*void) */	word offset;      /* offset of unaligned address */	word seg;         /* segment addr of unaligned address */	void *addr_alig; /* aligned address */	int rem; /* temp for alignment computation */	/* ensure that allocation table is not full */	if (num_alloc >= MAX_ALLOC) {		return(NULL);	}	/* find free entry in allocation table */	ix_save = alloc_ix;	while (alloc_table[alloc_ix].original != NULL) {		alloc_ix++;		if (alloc_ix >= MAX_ALLOC) alloc_ix = 0;		/* safety check -- should never happen! */		if (alloc_ix == ix_save) return(NULL);	}	/* call allocation routine */	/* request 15 extra bytes to ensure alignment is possible */	addr = calloc(size + 15,1);	/* compute aligned base */	offset = FP_OFF(addr);        seg = FP_SEG(addr);	rem = offset % 16;	if (rem > 0) offset = offset + 16 - rem;	addr_alig = MK_FP(seg,offset);	/* insert entries in table */	alloc_table[alloc_ix].original = addr;	alloc_table[alloc_ix].aligned = addr_alig;	/* increment count */	num_alloc++;	return(addr_alig);}/*	Procedure: sys_free_mem	Purpose: free a memory block	Parameters:		void *ptr         ptr to block to allocate	Returns: integer error code; zero if OK		Calls:   free	Globals: alloc_table, num_alloc	Errors:  ERR_SUP_INVMEM    invalid memory block	This procedure receives an aligned address; it must	find and free the corresponding non-aligned one.*/int sys_free_mem (         void     *ptr     /* pointer to block */		 ){	void *free_addr;  /* true (unaligned) block address */	int free_ix;               /* temp table index */	/* ensure valid pointer */	if (ptr==NULL) return(ERR_SUP_INVMEM);	/* Look for the block in the allocation table */	free_addr = NULL;	for (free_ix=0; free_ix<MAX_ALLOC; free_ix++) {		if (alloc_table[free_ix].aligned == ptr) {			free_addr = alloc_table[free_ix].original;			break;		}	}	/* If the block wasn't found, report error */	if (free_addr == NULL) return(ERR_SUP_INVMEM);	/* free the block & clear the table entry */	alloc_table[free_ix].original = NULL;	alloc_table[free_ix].aligned = NULL;        free(free_addr);	/* decrement count */	num_alloc--;	return(OK);}        /*	Procedure: sys_get_date	Purpose: Returns the system date (month, day, year)	Parameters:		date_rec *date_p Pointer to structure of type date	Returns: void		Calls: none		Globals: sys_date        Errors: none*/void sys_get_date (  date_rec*      date_p   /* ptr to date record */		){	date_p->month = sys_date.da_mon;	date_p->day = sys_date.da_day;	date_p->year = sys_date.da_year;}/*	Procedure: sys_set_date	Purpose: Sets the system date (month, day, year)	Parameters:		date_rec *date_p ptr to structure of type date	Returns: error code; OK if no error	Calls:   none        Globals: sys_date	Errors: none*/int sys_set_date (  date_rec*       date_p   /* ptr to date record */		 ){	sys_date.da_mon = date_p->month;        sys_date.da_day = date_p->day;        sys_date.da_year = date_p->year;	return(OK);}/*	Procedure: sys_open_dir	Purpose: open a specified directory	Parameters: char dir_name[]            directory name	Returns: error code; zero if OK	Calls:   findfirst		strncpy  	Globals: current_path, file_block, num_entries	Errors:  ERR_SUP_DIROPN    directory open error		ERR_SUP_INVDIR    invalid directory*/int sys_open_dir (  char  path_name[]        /* directory name */		 ){        char temp_path[MAX_PATH_SIZE];	int res;        int len;        /* ensure there is no directory currently open */	if (current_path[0]!=NULCH) return(ERR_SUP_DIROPN);        /* check pathname for validity */        /* construct temporary search path name */	temp_path[0] = NULCH;	if (path_name != NULL) {		strncpy(temp_path,path_name,MAX_PATH_SIZE-4);	}	/* build wildcard search string */        len = strlen(temp_path);	/* if path is null, use current directory */        if (len==0) strcpy(temp_path,"*.*");	/* handle paths ending in backslash, including root */        else if (temp_path[len-1]=='\\') strcat(temp_path,"*.*");	/* handle paths not ending in backslash */        else strcat(temp_path,"\\*.*");	/* validate the directory by searching for either an ordinary	   file or a directory in it.  This should never fail; even	   empty directories contain the directories "." and ".."	*/		res = findfirst(temp_path, &file_block, FA_DIREC);	if (res!=0)  return(ERR_SUP_INVDIR);        /* save pathname as current, clear entry count */	current_path[0] = NULCH;	if (path_name != NULL) {		strncpy(current_path,path_name,MAX_PATH_SIZE-6);	}	num_entries = 0;	return(OK);}/*	Procedure: sys_get_entry	Purpose: get the next directory entry;	Parameters: char name_buf[]	name buffer		    int buf_size  	buffer capacity		    long *file_size_p	file length buffer         	Returns: error code, or zero if ok	Calls:	findfirst		findnext		strncpy, strcpy, strrchr, strcat    	Globals: current_path, num_entries, file_block	Errors:  ERR_SUP_NOENTR    no such entry*/int sys_get_entry (char    name_buf[],       /* buffer for entry */		   int   buf_size,         /* buffer size */		   long* file_size_p       /* buffer for size value */		  ){	char filename[MAX_PATH_SIZE+1];	int err;        int len;        char *cp;        /* find next MPX file entry, if any */        /* if this is the first call */	if (num_entries==0) {	       /* construct complete search path name */	       len = strlen(current_path);	       if (len==0) strcpy(current_path,"*.MPX");	       else if (current_path[len-1]=='\\') strcat(current_path,"*.MPX");	       else strcat(current_path,"\\*.MPX");	       /* find first entry */		err = findfirst (current_path,&file_block,0);        }        /* otherwise, find next entry */        else err = findnext(&file_block);        if (err<0) return(ERR_SUP_NOENTR);		/* ensure buf_size is not too large */		if (buf_size > MAX_PATH_SIZE) buf_size = MAX_PATH_SIZE;		      /* copy filename to buffer */	filename[buf_size] = NULCH;	strncpy (filename,file_block.ff_name,			 (size_t) buf_size);	/* remove ".MPX" from name */	cp = strrchr(filename, (int) '.');        *cp = NULCH;	/* copy name and size to caller's buffer */        strcpy (name_buf,filename);	*file_size_p = file_block.ff_fsize;        /* count entry */	num_entries++;	return(OK);}/*	Procedure: sys_close_dir	Purpose: close an open directory	Parameters: none	Returns: error code; zero if OK	Calls:   none	Globals: current_path	Errors:  none*/int sys_close_dir (void){	current_path[0] = NULCH;	return(OK);}/*	Procedure: sys_check_program	Purpose: locate and measure a program file	Parameters: see prototype	Returns: program size or error code	Calls:   strlen, strcat		fopen, fread	Globals: none	Errors:  ERR_SUP_NAMLNG    pathname too long		ERR_SUP_FILNFD    file not found		ERR_SUP_FILINV    file invalid*/#define HEADER_SIZE 32int sys_check_program(     char     dir_name[],       /* directory name */			char     prog_name[],      /* program name */			int*     prog_len_p,       /* ptr to prog length */			int*     start_offset_p    /* ptr to start offset */			){        /* buffer for full pathname */	char file_name[MAX_PATH_SIZE+1];        /* buffer for file header */        byte header[HEADER_SIZE];	FILE *file_p;     /* file pointer for C file routines */        int num_read;      /* number of header bytes read */	int file_size;    /* size of complete file */        int header_size;/* size of header */        int code_size;     /* size of program code */        int data_size;     /* size of program data */        int errcode;       /* error code */        /* ensure that path name is not too long */        if ((strlen(dir_name) + strlen(prog_name) + 5)		 > MAX_PATH_SIZE) return(ERR_SUP_NAMLNG);	/* construct path name */	file_name[0] = NULCH;	if (dir_name[0] != NULCH) {		strcat(file_name, dir_name);	        strcat(file_name, "\\");	}        strcat(file_name, prog_name);	strcat(file_name, ".MPX");        /* try to open the file */	errcode = OK;        file_p = fopen(file_name, "rb");        if (file_p == NULL) return(ERR_SUP_FILNFD);	/* read the header, check for EXE signature */        num_read = fread( (void*) header, 1, HEADER_SIZE, file_p);        if (num_read != HEADER_SIZE) {		errcode = ERR_SUP_FILINV;	}        else if ((header[0] != 0x4D) || (header[1] != 0x5A)) {		errcode = ERR_SUP_FILINV;	}        /* close the file, then return if error occurred */        fclose(file_p);	if (errcode!=OK) return(errcode);        /* compute allocation size needed */        file_size = (header[5]*256 + header[4] -1) * 512		+ (header[3]*256 + header[2]);        header_size =(header[9]*256 + header[8])*16;        code_size = file_size - header_size;        data_size = (header[11]*256 + header[10])*16;        /* return total length and starting offset */        *prog_len_p = code_size + data_size;	*start_offset_p = (header[23]*256 + header[22]) * 16;	return(OK);}/*	Procedure: sys_load_program	Purpose: load a program file	Parameters: see prototype	Returns: error code; zero if OK	Calls:   intdosx		segread		strlen, strcat	Globals: none 	Errors:  ERR_SUP_NAMLNG    name too long		ERR_SUP_FILNFD    file not found	       ERR_SUP_FILINV      file invalid		ERR_SUP_PROGSZ    program too large	       ERR_SUP_LDADDR      address not aligned		ERR_SUP_LDFAIL    load failed*/int sys_load_program (     void*    load_addr,        /* address for loading */			int      max_size,         /* memory size */			char     dir_name[],       /* directory name */			char     prog_name[]       /* program name */		      ){	int errcode;      /* error code */        int prog_len;      /* program length */	int offset;       /* offset for starting */	word norm_seg;    /* normalized load address segment */        word norm_off;     /* normalized load address offset */        /* full pathname for file to be loaded */	char file_name[MAX_PATH_SIZE+1];        /* parameter block for MSDOS EXEC function */	struct {		word load_seg;    /* segment address for loading */	       word reloc_seg;     /* segment address for relocation */        }p_block;	union REGS inregs;            /* input register structure */	union REGS outregs;           /* output register structure */	struct SREGS segregs;         /* segment register structure */        /* check program, get length and offset */	errcode = sys_check_program(dir_name, prog_name,					&prog_len, &offset);        if (errcode < 0) return(errcode);        /* ensure that allocated memory is large enough */        if (max_size < prog_len) return(ERR_SUP_PROGSZ);        /* get normalized segment and offset, check alignment */	norm_seg = FP_SEG(load_addr);	norm_off = FP_OFF(load_addr);	norm_seg += norm_off / 16;        norm_off %= 16;	if (norm_off != 0) return(ERR_SUP_LDADDR);        /* ensure that path name is not too long */        if ((strlen(dir_name) + strlen(prog_name) + 5)		 > MAX_PATH_SIZE) return(ERR_SUP_NAMLNG);	/* construct path name */	file_name[0] = NULCH;	if (dir_name[0] != NULCH) {		strcat(file_name, dir_name);	        strcat(file_name, "\\");	}        strcat(file_name, prog_name);	strcat(file_name, ".MPX");        /* get current segment regs */	segread(&segregs);        /* setup function codes */	inregs.h.ah = 0x4B;        /* EXEC function */	inregs.h.al = 0x03;        /* load only */        /* setup parameter block and name pointers */        segregs.ds = FP_SEG(&file_name);	inregs.x.dx = FP_OFF(&file_name);        segregs.es = FP_SEG(&p_block);	inregs.x.bx = FP_OFF(&p_block);        /* setup load segment -- must be normalized */	p_block.load_seg = norm_seg;	p_block.reloc_seg = p_block.load_seg;        /* call the MS-DOS loader */	errcode = intdosx(&inregs,&outregs,&segregs);        errcode = errcode;        /* check for error */	if (outregs.x.cflag) return(ERR_SUP_LDFAIL);	/* load successful */	return(OK);}/* END OF FILE */sys_exit1,0
/***********************************************************************	MPX: The MultiProgramming eXecutive	Project to Accompany	A Practical Approach to Operating Systems	Malcolm G. Lane & James D. Mooney	Copyright 1993, P.W.S. Kent Publishing Co., Boston, MA.		File Name: mpx_supt.c	Authors: J.J. Patnesky, A. Ghosal, M. Lane, J. Mooney	Version: 2.1b	Date: 01/31/08	Purpose: Support routines for MPX-PC		Modules: all	Environment:      IBM-PC (XT, AT or PS/2)			MS-DOS 3.3 or later			TURBO-C 3.0 or TURBO-C++ 1.0 or later	Compile using the LARGE MODEL and SS NOT equal to DS.	All addresses and pointers are "far", and	CS, DS and SS are independent.	Procedures in this file:		sys_init		sys_exit		sys_set_vec		sys_req		sys_alloc_mem		sys_free_mem		sys_get_date		sys_set_date		sys_open_dir		sys_get_entry		sys_close_dir	       sys_check_program	       sys_load_program************************************************************************Change Log:	07/16/88  akg	added comments	02/25/92  jdm	full revision, UNIX version	04/14/92  jdm	Macintosh version	05/15/92  jdm	cleanup and documentation	07/14/92  jdm	update for revised specs        08/13/92  jdm 	revised IBM version; added private heap        10/14/92  jdm 	added check and load procedures        10/18/92  jdm 	revised sys_alloc_mem for alignment	11/17/92  jdm	true heap mgt, aligned, using calloc & free	11/19/92  jdm	enable device handling for final module	12/31/92  jdm	revised sys_req parameters	01/02/93  jdm	return count value after I/O	01/03/93  jdm	revised error names and codes	01/27/93  jdm	corrected count for line input in sys_req			fixed open_dir to handle null lines	02/24/93  jdm	changed sys_set_vec param to interrupt	03/08/93  jdm	corrections to sys_check & sys_load	03/20/93  jdm	stack switch in free, check, and load	04/22/93  jdm	corrected index conflict in sys_free_mem			added safety escape in alloc table search	07/28/93  jdm	conversion to large model	09/01/93  jdm	fixed allocation bug;  made date private	09/14/93  jdm	cleaned up memory allocation        09/16/93  jdm	adjusted program load for large model        09/30/93  jdm	modified for correct list of root directory	11/01/94  jdm	changed load file read to binary	09/18/95  jdm	fixed get_entry to default to current, not root	01/31/08  jdm   fixed possible overflow problem in get_entry************************************************************************/#include "mpx_supt.h"#include <stdlib.h>#include <dos.h>#include <dir.h>#include <errno.h>#include <conio.h>#include <alloc.h>#define VEC_ADDR (0x60L*4)#define MAX_ALLOC 200#define MAX_XPOS 79#define MAX_YPOS 24#define MAX_PATH_SIZE 50/*	System-dependent type definitions*/typedef unsigned char byte;typedef unsigned int word;typedef unsigned long longword;typedef byte *address;typedef struct params {	int      op_code;	int      device_id;	char     *buf_p;	int      *count_p;	} params;/*	Global variables accessed only by support routines*/	static longword vec_save;  /* saved interrupt vector */	static int mod_code;                /* module code */                                           	static struct date sys_date;        /* MPX system date */	/* data structures for directory access */        static char current_path[MAX_PATH_SIZE+1];        static int num_entries;        static struct ffblk file_block;        /* handler presence flags */	static flag sysc_hand;	static flag trm_hand;	static flag prt_hand;	static flag com_hand;        /* memory allocation table */	static struct {		void* original;		void* aligned;	} alloc_table[MAX_ALLOC];	static int alloc_ix;                /* current index */	static int num_alloc;               /* no. of allocated blocks *//*	Procedure: sys_init	Purpose: initialize mpx	Parameters: see prototype  	Return value: error code, or OK if no error	Calls: getdate    	Globals: mod_code		vec_save		sys_date		alloc_table, alloc_ix, num_alloc		sysc_hand, term_hand, prt_hand, com_hand	Errors: none*/int sys_init (    int      modules  /* module code */	     ){	mod_code = modules;        vec_save = 0L;        /* no handlers detected yet */	sysc_hand = FALSE;	trm_hand = FALSE;	prt_hand = FALSE;	com_hand = FALSE;	/* initialize allocation table */	for (alloc_ix=0; alloc_ix < MAX_ALLOC; alloc_ix++) {		alloc_table[alloc_ix].original = NULL;		alloc_table[alloc_ix].aligned = NULL;	}	alloc_ix = 0;	num_alloc = 0;	/* if we have reached Module R3, enable system call handling */	if (modules >= MODULE_R3) sysc_hand = TRUE;	/* if we have reached the final module, enable device handlers */	if (modules >= MODULE_F) {		trm_hand = TRUE;		prt_hand = TRUE;		com_hand = TRUE;	}	/* get system date */        getdate(&sys_date);	return (OK);}/*	Procedure: sys_exit	Purpose: terminate mpx	Parameters: none  	Return value: none	Calls: none       	Globals: vec_save*/void sys_exit(void){	longword *vec_p;	/* if trap vector changed, restore it */	if (vec_save != 0L) {		vec_p = (longword*) VEC_ADDR;		*vec_p = vec_save;	}	/* return to host with null error code */	exit(0);}/*	Procedure: sys_set_vec	Purpose: link trap vector to MPX system call handler	Parameters: handler: addr of handler         	Return value: error code; OK if no error	Calls: none       	Globals: vec_save	Errors: none*/int sys_set_vec   ( void interrupt (*handler)() /* system call handler */		){	longword *vec_p;			vec_p = (longword*) VEC_ADDR;		vec_save = *vec_p;		*vec_p = (longword) handler;	return (0);}/*	Procedure: sys_req	Purpose: Request a system service	Inputs:		op_code           operation code		device_id         device identifier		buf_p             addresso f data buffer		count_p           address of size of buffer	Returns: Result or error code, depending on service		Services supported:	IDLE     null operation				READ     input from a device				WRITE    output to a device				CLEAR    clear terminal screen				GOTOXY   absolute cursor position				EXIT     terminate the caller	Calls:   fgets		strlen			Globals: none		Errors:  ERR_SUP_INVDEV    invalid device		ERR_SUP_INVOPC    invalid operation code		ERR_SUP_INVPOS    invalid character position		ERR_SUP_RDFAIL    read failed		ERR_SUP_WRFAIL    write failed	Description:	For Modules R1 through R4,	this procedure is used only for terminal I/O.	Later modules support both reading and	writing for several devices.	For Modules R1 through R4,	sys_req uses the ANSI C function "fgets."	Later modules may use alternate functions and device drivers.*/int sys_req (   int      op_code, /* operation code */		int      device_id,        /* device id */		char*    buf_p,            /* I/O buffer */		int*     count_p           /* address of count */		){	int      rval;    /* result or error code */	char     *rp;     /* return pointer for fgets */	char     rc;      /* return char for fputc */        params    *param_p; /* pointer to parameter record in stack */	flag     docall;  /* true if system call interrupt wanted */	int      ix;      /* temporary index */	docall = FALSE;	rval = OK;	switch (op_code) {		case IDLE:		if (sysc_hand) docall = TRUE;		break; 				case READ:		switch (device_id) {				case TERMINAL:			if (trm_hand) docall = TRUE;			else {				rp = fgets(buf_p,*count_p,stdin);				if (rp==NULL) rval = ERR_SUP_RDFAIL;				else rval = strlen(buf_p);			}			break;					case COM_PORT:			if (com_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					default:			rval = ERR_SUP_INVDEV;					}		break;	case WRITE:		switch (device_id) {				case TERMINAL:			if (trm_hand) docall = TRUE;			else {				rval = *count_p;				for (ix=0; ix<*count_p; ix++) {					rc = fputc(buf_p[ix],stdout);					if (rc == EOF) {						rval = ERR_SUP_WRFAIL;						break;					}				}			}			break;					case COM_PORT:			if (com_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					case PRINTER:			if (prt_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					default:			rval = ERR_SUP_INVDEV;					}		break;	case CLEAR:		if (device_id==TERMINAL) {			if (trm_hand) docall = TRUE;			else {			     clrscr();				rval = 0;			}		}		else rval = ERR_SUP_INVDEV;		break;			case GOTOXY:		if (device_id==TERMINAL) {			if (trm_hand) docall = TRUE;			else {				if (*count_p != 2) rval = ERR_SUP_WRFAIL;				else if ((*buf_p<0)					|| (*buf_p > MAX_XPOS))					rval = ERR_SUP_WRFAIL;				else if ((*(buf_p+1)<0)					|| (*(buf_p+1) > MAX_YPOS))					rval = ERR_SUP_WRFAIL;				else {					gotoxy(*buf_p + 1,						*(buf_p+1) + 1);					rval = 0;				}			}		}		else rval = ERR_SUP_INVDEV;		break;			/* EXIT - terminate the calling process */	/* legal only when a system call handler is present */	case EXIT:		if (sysc_hand) docall = TRUE;		else rval = ERR_SUP_INVOPC;		break; 	default:		rval = ERR_SUP_INVOPC;			}		/* Invoke user's call handler if present.	   If the call is an IO request, return will occur	   only after the request is complete.	*/	if (docall && (rval==OK)) {		/* invoke the call handler */	_SP = _SP - sizeof(params);		param_p = (params*) MK_FP(_SS,_SP);	       param_p->op_code = op_code;	       param_p->device_id = device_id;	       param_p->buf_p = buf_p;	       param_p->count_p = count_p;	       geninterrupt(0x60);	       rval = _AX;	       _SP = _SP + sizeof(params);		/* for I/O operations, return count value */		switch(op_code) {		case READ:		case WRITE:		case CLEAR:		case GOTOXY:			rval = *count_p;		}	}	return(rval);}/*	Procedure: sys_alloc_mem	Purpose: Allocate a memory block	Parameters:			size_t size       No. of bytes to allocate	Returns: void* pointer to allocated block;		 null pointer in case of error		 	Calls: calloc		Globals: alloc_table, alloc_ix, num_alloc	For program loading (Module R-4), the blocks must be aligned.	This is achieved by requesting one extra paragraph and	returning the lowest aligned address as the base.  It is	necessary to keep a table of allocated address, original and	aligned, to support correct freeing.	It would seem simpler to use the Turbo-C function allocmem,	which always allocates aligned blocks.  However, allocmem	appears to conflict with the internal allocation of fopen	and other C library routines.*/void *sys_alloc_mem (      size_t   size     /* size in bytes to allocate */		    ){	int ix_save;      /* temp copy of table index */        void *addr;        /* addr returned by calloc (*void) */	word offset;      /* offset of unaligned address */	word seg;         /* segment addr of unaligned address */	void *addr_alig; /* aligned address */	int rem; /* temp for alignment computation */	/* ensure that allocation table is not full */	if (num_alloc >= MAX_ALLOC) {		return(NULL);	}	/* find free entry in allocation table */	ix_save = alloc_ix;	while (alloc_table[alloc_ix].original != NULL) {		alloc_ix++;		if (alloc_ix >= MAX_ALLOC) alloc_ix = 0;		/* safety check -- should never happen! */		if (alloc_ix == ix_save) return(NULL);	}	/* call allocation routine */	/* request 15 extra bytes to ensure alignment is possible */	addr = calloc(size + 15,1);	/* compute aligned base */	offset = FP_OFF(addr);        seg = FP_SEG(addr);	rem = offset % 16;	if (rem > 0) offset = offset + 16 - rem;	addr_alig = MK_FP(seg,offset);	/* insert entries in table */	alloc_table[alloc_ix].original = addr;	alloc_table[alloc_ix].aligned = addr_alig;	/* increment count */	num_alloc++;	return(addr_alig);}/*	Procedure: sys_free_mem	Purpose: free a memory block	Parameters:		void *ptr         ptr to block to allocate	Returns: integer error code; zero if OK		Calls:   free	Globals: alloc_table, num_alloc	Errors:  ERR_SUP_INVMEM    invalid memory block	This procedure receives an aligned address; it must	find and free the corresponding non-aligned one.*/int sys_free_mem (         void     *ptr     /* pointer to block */		 ){	void *free_addr;  /* true (unaligned) block address */	int free_ix;               /* temp table index */	/* ensure valid pointer */	if (ptr==NULL) return(ERR_SUP_INVMEM);	/* Look for the block in the allocation table */	free_addr = NULL;	for (free_ix=0; free_ix<MAX_ALLOC; free_ix++) {		if (alloc_table[free_ix].aligned == ptr) {			free_addr = alloc_table[free_ix].original;			break;		}	}	/* If the block wasn't found, report error */	if (free_addr == NULL) return(ERR_SUP_INVMEM);	/* free the block & clear the table entry */	alloc_table[free_ix].original = NULL;	alloc_table[free_ix].aligned = NULL;        free(free_addr);	/* decrement count */	num_alloc--;	return(OK);}        /*	Procedure: sys_get_date	Purpose: Returns the system date (month, day, year)	Parameters:		date_rec *date_p Pointer to structure of type date	Returns: void		Calls: none		Globals: sys_date        Errors: none*/void sys_get_date (  date_rec*      date_p   /* ptr to date record */		){	date_p->month = sys_date.da_mon;	date_p->day = sys_date.da_day;	date_p->year = sys_date.da_year;}/*	Procedure: sys_set_date	Purpose: Sets the system date (month, day, year)	Parameters:		date_rec *date_p ptr to structure of type date	Returns: error code; OK if no error	Calls:   none        Globals: sys_date	Errors: none*/int sys_set_date (  date_rec*       date_p   /* ptr to date record */		 ){	sys_date.da_mon = date_p->month;        sys_date.da_day = date_p->day;        sys_date.da_year = date_p->year;	return(OK);}/*	Procedure: sys_open_dir	Purpose: open a specified directory	Parameters: char dir_name[]            directory name	Returns: error code; zero if OK	Calls:   findfirst		strncpy  	Globals: current_path, file_block, num_entries	Errors:  ERR_SUP_DIROPN    directory open error		ERR_SUP_INVDIR    invalid directory*/int sys_open_dir (  char  path_name[]        /* directory name */		 ){        char temp_path[MAX_PATH_SIZE];	int res;        int len;        /* ensure there is no directory currently open */	if (current_path[0]!=NULCH) return(ERR_SUP_DIROPN);        /* check pathname for validity */        /* construct temporary search path name */	temp_path[0] = NULCH;	if (path_name != NULL) {		strncpy(temp_path,path_name,MAX_PATH_SIZE-4);	}	/* build wildcard search string */        len = strlen(temp_path);	/* if path is null, use current directory */        if (len==0) strcpy(temp_path,"*.*");	/* handle paths ending in backslash, including root */        else if (temp_path[len-1]=='\\') strcat(temp_path,"*.*");	/* handle paths not ending in backslash */        else strcat(temp_path,"\\*.*");	/* validate the directory by searching for either an ordinary	   file or a directory in it.  This should never fail; even	   empty directories contain the directories "." and ".."	*/		res = findfirst(temp_path, &file_block, FA_DIREC);	if (res!=0)  return(ERR_SUP_INVDIR);        /* save pathname as current, clear entry count */	current_path[0] = NULCH;	if (path_name != NULL) {		strncpy(current_path,path_name,MAX_PATH_SIZE-6);	}	num_entries = 0;	return(OK);}/*	Procedure: sys_get_entry	Purpose: get the next directory entry;	Parameters: char name_buf[]	name buffer		    int buf_size  	buffer capacity		    long *file_size_p	file length buffer         	Returns: error code, or zero if ok	Calls:	findfirst		findnext		strncpy, strcpy, strrchr, strcat    	Globals: current_path, num_entries, file_block	Errors:  ERR_SUP_NOENTR    no such entry*/int sys_get_entry (char    name_buf[],       /* buffer for entry */		   int   buf_size,         /* buffer size */		   long* file_size_p       /* buffer for size value */		  ){	char filename[MAX_PATH_SIZE+1];	int err;        int len;        char *cp;        /* find next MPX file entry, if any */        /* if this is the first call */	if (num_entries==0) {	       /* construct complete search path name */	       len = strlen(current_path);	       if (len==0) strcpy(current_path,"*.MPX");	       else if (current_path[len-1]=='\\') strcat(current_path,"*.MPX");	       else strcat(current_path,"\\*.MPX");	       /* find first entry */		err = findfirst (current_path,&file_block,0);        }        /* otherwise, find next entry */        else err = findnext(&file_block);        if (err<0) return(ERR_SUP_NOENTR);		/* ensure buf_size is not too large */		if (buf_size > MAX_PATH_SIZE) buf_size = MAX_PATH_SIZE;		      /* copy filename to buffer */	filename[buf_size] = NULCH;	strncpy (filename,file_block.ff_name,			 (size_t) buf_size);	/* remove ".MPX" from name */	cp = strrchr(filename, (int) '.');        *cp = NULCH;	/* copy name and size to caller's buffer */        strcpy (name_buf,filename);	*file_size_p = file_block.ff_fsize;        /* count entry */	num_entries++;	return(OK);}/*	Procedure: sys_close_dir	Purpose: close an open directory	Parameters: none	Returns: error code; zero if OK	Calls:   none	Globals: current_path	Errors:  none*/int sys_close_dir (void){	current_path[0] = NULCH;	return(OK);}/*	Procedure: sys_check_program	Purpose: locate and measure a program file	Parameters: see prototype	Returns: program size or error code	Calls:   strlen, strcat		fopen, fread	Globals: none	Errors:  ERR_SUP_NAMLNG    pathname too long		ERR_SUP_FILNFD    file not found		ERR_SUP_FILINV    file invalid*/#define HEADER_SIZE 32int sys_check_program(     char     dir_name[],       /* directory name */			char     prog_name[],      /* program name */			int*     prog_len_p,       /* ptr to prog length */			int*     start_offset_p    /* ptr to start offset */			){        /* buffer for full pathname */	char file_name[MAX_PATH_SIZE+1];        /* buffer for file header */        byte header[HEADER_SIZE];	FILE *file_p;     /* file pointer for C file routines */        int num_read;      /* number of header bytes read */	int file_size;    /* size of complete file */        int header_size;/* size of header */        int code_size;     /* size of program code */        int data_size;     /* size of program data */        int errcode;       /* error code */        /* ensure that path name is not too long */        if ((strlen(dir_name) + strlen(prog_name) + 5)		 > MAX_PATH_SIZE) return(ERR_SUP_NAMLNG);	/* construct path name */	file_name[0] = NULCH;	if (dir_name[0] != NULCH) {		strcat(file_name, dir_name);	        strcat(file_name, "\\");	}        strcat(file_name, prog_name);	strcat(file_name, ".MPX");        /* try to open the file */	errcode = OK;        file_p = fopen(file_name, "rb");        if (file_p == NULL) return(ERR_SUP_FILNFD);	/* read the header, check for EXE signature */        num_read = fread( (void*) header, 1, HEADER_SIZE, file_p);        if (num_read != HEADER_SIZE) {		errcode = ERR_SUP_FILINV;	}        else if ((header[0] != 0x4D) || (header[1] != 0x5A)) {		errcode = ERR_SUP_FILINV;	}        /* close the file, then return if error occurred */        fclose(file_p);	if (errcode!=OK) return(errcode);        /* compute allocation size needed */        file_size = (header[5]*256 + header[4] -1) * 512		+ (header[3]*256 + header[2]);        header_size =(header[9]*256 + header[8])*16;        code_size = file_size - header_size;        data_size = (header[11]*256 + header[10])*16;        /* return total length and starting offset */        *prog_len_p = code_size + data_size;	*start_offset_p = (header[23]*256 + header[22]) * 16;	return(OK);}/*	Procedure: sys_load_program	Purpose: load a program file	Parameters: see prototype	Returns: error code; zero if OK	Calls:   intdosx		segread		strlen, strcat	Globals: none 	Errors:  ERR_SUP_NAMLNG    name too long		ERR_SUP_FILNFD    file not found	       ERR_SUP_FILINV      file invalid		ERR_SUP_PROGSZ    program too large	       ERR_SUP_LDADDR      address not aligned		ERR_SUP_LDFAIL    load failed*/int sys_load_program (     void*    load_addr,        /* address for loading */			int      max_size,         /* memory size */			char     dir_name[],       /* directory name */			char     prog_name[]       /* program name */		      ){	int errcode;      /* error code */        int prog_len;      /* program length */	int offset;       /* offset for starting */	word norm_seg;    /* normalized load address segment */        word norm_off;     /* normalized load address offset */        /* full pathname for file to be loaded */	char file_name[MAX_PATH_SIZE+1];        /* parameter block for MSDOS EXEC function */	struct {		word load_seg;    /* segment address for loading */	       word reloc_seg;     /* segment address for relocation */        }p_block;	union REGS inregs;            /* input register structure */	union REGS outregs;           /* output register structure */	struct SREGS segregs;         /* segment register structure */        /* check program, get length and offset */	errcode = sys_check_program(dir_name, prog_name,					&prog_len, &offset);        if (errcode < 0) return(errcode);        /* ensure that allocated memory is large enough */        if (max_size < prog_len) return(ERR_SUP_PROGSZ);        /* get normalized segment and offset, check alignment */	norm_seg = FP_SEG(load_addr);	norm_off = FP_OFF(load_addr);	norm_seg += norm_off / 16;        norm_off %= 16;	if (norm_off != 0) return(ERR_SUP_LDADDR);        /* ensure that path name is not too long */        if ((strlen(dir_name) + strlen(prog_name) + 5)		 > MAX_PATH_SIZE) return(ERR_SUP_NAMLNG);	/* construct path name */	file_name[0] = NULCH;	if (dir_name[0] != NULCH) {		strcat(file_name, dir_name);	        strcat(file_name, "\\");	}        strcat(file_name, prog_name);	strcat(file_name, ".MPX");        /* get current segment regs */	segread(&segregs);        /* setup function codes */	inregs.h.ah = 0x4B;        /* EXEC function */	inregs.h.al = 0x03;        /* load only */        /* setup parameter block and name pointers */        segregs.ds = FP_SEG(&file_name);	inregs.x.dx = FP_OFF(&file_name);        segregs.es = FP_SEG(&p_block);	inregs.x.bx = FP_OFF(&p_block);        /* setup load segment -- must be normalized */	p_block.load_seg = norm_seg;	p_block.reloc_seg = p_block.load_seg;        /* call the MS-DOS loader */	errcode = intdosx(&inregs,&outregs,&segregs);        errcode = errcode;        /* check for error */	if (outregs.x.cflag) return(ERR_SUP_LDFAIL);	/* load successful */	return(OK);}/* END OF FILE */sys_set_vec1,0
/***********************************************************************	MPX: The MultiProgramming eXecutive	Project to Accompany	A Practical Approach to Operating Systems	Malcolm G. Lane & James D. Mooney	Copyright 1993, P.W.S. Kent Publishing Co., Boston, MA.		File Name: mpx_supt.c	Authors: J.J. Patnesky, A. Ghosal, M. Lane, J. Mooney	Version: 2.1b	Date: 01/31/08	Purpose: Support routines for MPX-PC		Modules: all	Environment:      IBM-PC (XT, AT or PS/2)			MS-DOS 3.3 or later			TURBO-C 3.0 or TURBO-C++ 1.0 or later	Compile using the LARGE MODEL and SS NOT equal to DS.	All addresses and pointers are "far", and	CS, DS and SS are independent.	Procedures in this file:		sys_init		sys_exit		sys_set_vec		sys_req		sys_alloc_mem		sys_free_mem		sys_get_date		sys_set_date		sys_open_dir		sys_get_entry		sys_close_dir	       sys_check_program	       sys_load_program************************************************************************Change Log:	07/16/88  akg	added comments	02/25/92  jdm	full revision, UNIX version	04/14/92  jdm	Macintosh version	05/15/92  jdm	cleanup and documentation	07/14/92  jdm	update for revised specs        08/13/92  jdm 	revised IBM version; added private heap        10/14/92  jdm 	added check and load procedures        10/18/92  jdm 	revised sys_alloc_mem for alignment	11/17/92  jdm	true heap mgt, aligned, using calloc & free	11/19/92  jdm	enable device handling for final module	12/31/92  jdm	revised sys_req parameters	01/02/93  jdm	return count value after I/O	01/03/93  jdm	revised error names and codes	01/27/93  jdm	corrected count for line input in sys_req			fixed open_dir to handle null lines	02/24/93  jdm	changed sys_set_vec param to interrupt	03/08/93  jdm	corrections to sys_check & sys_load	03/20/93  jdm	stack switch in free, check, and load	04/22/93  jdm	corrected index conflict in sys_free_mem			added safety escape in alloc table search	07/28/93  jdm	conversion to large model	09/01/93  jdm	fixed allocation bug;  made date private	09/14/93  jdm	cleaned up memory allocation        09/16/93  jdm	adjusted program load for large model        09/30/93  jdm	modified for correct list of root directory	11/01/94  jdm	changed load file read to binary	09/18/95  jdm	fixed get_entry to default to current, not root	01/31/08  jdm   fixed possible overflow problem in get_entry************************************************************************/#include "mpx_supt.h"#include <stdlib.h>#include <dos.h>#include <dir.h>#include <errno.h>#include <conio.h>#include <alloc.h>#define VEC_ADDR (0x60L*4)#define MAX_ALLOC 200#define MAX_XPOS 79#define MAX_YPOS 24#define MAX_PATH_SIZE 50/*	System-dependent type definitions*/typedef unsigned char byte;typedef unsigned int word;typedef unsigned long longword;typedef byte *address;typedef struct params {	int      op_code;	int      device_id;	char     *buf_p;	int      *count_p;	} params;/*	Global variables accessed only by support routines*/	static longword vec_save;  /* saved interrupt vector */	static int mod_code;                /* module code */                                           	static struct date sys_date;        /* MPX system date */	/* data structures for directory access */        static char current_path[MAX_PATH_SIZE+1];        static int num_entries;        static struct ffblk file_block;        /* handler presence flags */	static flag sysc_hand;	static flag trm_hand;	static flag prt_hand;	static flag com_hand;        /* memory allocation table */	static struct {		void* original;		void* aligned;	} alloc_table[MAX_ALLOC];	static int alloc_ix;                /* current index */	static int num_alloc;               /* no. of allocated blocks *//*	Procedure: sys_init	Purpose: initialize mpx	Parameters: see prototype  	Return value: error code, or OK if no error	Calls: getdate    	Globals: mod_code		vec_save		sys_date		alloc_table, alloc_ix, num_alloc		sysc_hand, term_hand, prt_hand, com_hand	Errors: none*/int sys_init (    int      modules  /* module code */	     ){	mod_code = modules;        vec_save = 0L;        /* no handlers detected yet */	sysc_hand = FALSE;	trm_hand = FALSE;	prt_hand = FALSE;	com_hand = FALSE;	/* initialize allocation table */	for (alloc_ix=0; alloc_ix < MAX_ALLOC; alloc_ix++) {		alloc_table[alloc_ix].original = NULL;		alloc_table[alloc_ix].aligned = NULL;	}	alloc_ix = 0;	num_alloc = 0;	/* if we have reached Module R3, enable system call handling */	if (modules >= MODULE_R3) sysc_hand = TRUE;	/* if we have reached the final module, enable device handlers */	if (modules >= MODULE_F) {		trm_hand = TRUE;		prt_hand = TRUE;		com_hand = TRUE;	}	/* get system date */        getdate(&sys_date);	return (OK);}/*	Procedure: sys_exit	Purpose: terminate mpx	Parameters: none  	Return value: none	Calls: none       	Globals: vec_save*/void sys_exit(void){	longword *vec_p;	/* if trap vector changed, restore it */	if (vec_save != 0L) {		vec_p = (longword*) VEC_ADDR;		*vec_p = vec_save;	}	/* return to host with null error code */	exit(0);}/*	Procedure: sys_set_vec	Purpose: link trap vector to MPX system call handler	Parameters: handler: addr of handler         	Return value: error code; OK if no error	Calls: none       	Globals: vec_save	Errors: none*/int sys_set_vec   ( void interrupt (*handler)() /* system call handler */		){	longword *vec_p;			vec_p = (longword*) VEC_ADDR;		vec_save = *vec_p;		*vec_p = (longword) handler;	return (0);}/*	Procedure: sys_req	Purpose: Request a system service	Inputs:		op_code           operation code		device_id         device identifier		buf_p             addresso f data buffer		count_p           address of size of buffer	Returns: Result or error code, depending on service		Services supported:	IDLE     null operation				READ     input from a device				WRITE    output to a device				CLEAR    clear terminal screen				GOTOXY   absolute cursor position				EXIT     terminate the caller	Calls:   fgets		strlen			Globals: none		Errors:  ERR_SUP_INVDEV    invalid device		ERR_SUP_INVOPC    invalid operation code		ERR_SUP_INVPOS    invalid character position		ERR_SUP_RDFAIL    read failed		ERR_SUP_WRFAIL    write failed	Description:	For Modules R1 through R4,	this procedure is used only for terminal I/O.	Later modules support both reading and	writing for several devices.	For Modules R1 through R4,	sys_req uses the ANSI C function "fgets."	Later modules may use alternate functions and device drivers.*/int sys_req (   int      op_code, /* operation code */		int      device_id,        /* device id */		char*    buf_p,            /* I/O buffer */		int*     count_p           /* address of count */		){	int      rval;    /* result or error code */	char     *rp;     /* return pointer for fgets */	char     rc;      /* return char for fputc */        params    *param_p; /* pointer to parameter record in stack */	flag     docall;  /* true if system call interrupt wanted */	int      ix;      /* temporary index */	docall = FALSE;	rval = OK;	switch (op_code) {		case IDLE:		if (sysc_hand) docall = TRUE;		break; 				case READ:		switch (device_id) {				case TERMINAL:			if (trm_hand) docall = TRUE;			else {				rp = fgets(buf_p,*count_p,stdin);				if (rp==NULL) rval = ERR_SUP_RDFAIL;				else rval = strlen(buf_p);			}			break;					case COM_PORT:			if (com_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					default:			rval = ERR_SUP_INVDEV;					}		break;	case WRITE:		switch (device_id) {				case TERMINAL:			if (trm_hand) docall = TRUE;			else {				rval = *count_p;				for (ix=0; ix<*count_p; ix++) {					rc = fputc(buf_p[ix],stdout);					if (rc == EOF) {						rval = ERR_SUP_WRFAIL;						break;					}				}			}			break;					case COM_PORT:			if (com_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					case PRINTER:			if (prt_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					default:			rval = ERR_SUP_INVDEV;					}		break;	case CLEAR:		if (device_id==TERMINAL) {			if (trm_hand) docall = TRUE;			else {			     clrscr();				rval = 0;			}		}		else rval = ERR_SUP_INVDEV;		break;			case GOTOXY:		if (device_id==TERMINAL) {			if (trm_hand) docall = TRUE;			else {				if (*count_p != 2) rval = ERR_SUP_WRFAIL;				else if ((*buf_p<0)					|| (*buf_p > MAX_XPOS))					rval = ERR_SUP_WRFAIL;				else if ((*(buf_p+1)<0)					|| (*(buf_p+1) > MAX_YPOS))					rval = ERR_SUP_WRFAIL;				else {					gotoxy(*buf_p + 1,						*(buf_p+1) + 1);					rval = 0;				}			}		}		else rval = ERR_SUP_INVDEV;		break;			/* EXIT - terminate the calling process */	/* legal only when a system call handler is present */	case EXIT:		if (sysc_hand) docall = TRUE;		else rval = ERR_SUP_INVOPC;		break; 	default:		rval = ERR_SUP_INVOPC;			}		/* Invoke user's call handler if present.	   If the call is an IO request, return will occur	   only after the request is complete.	*/	if (docall && (rval==OK)) {		/* invoke the call handler */	_SP = _SP - sizeof(params);		param_p = (params*) MK_FP(_SS,_SP);	       param_p->op_code = op_code;	       param_p->device_id = device_id;	       param_p->buf_p = buf_p;	       param_p->count_p = count_p;	       geninterrupt(0x60);	       rval = _AX;	       _SP = _SP + sizeof(params);		/* for I/O operations, return count value */		switch(op_code) {		case READ:		case WRITE:		case CLEAR:		case GOTOXY:			rval = *count_p;		}	}	return(rval);}/*	Procedure: sys_alloc_mem	Purpose: Allocate a memory block	Parameters:			size_t size       No. of bytes to allocate	Returns: void* pointer to allocated block;		 null pointer in case of error		 	Calls: calloc		Globals: alloc_table, alloc_ix, num_alloc	For program loading (Module R-4), the blocks must be aligned.	This is achieved by requesting one extra paragraph and	returning the lowest aligned address as the base.  It is	necessary to keep a table of allocated address, original and	aligned, to support correct freeing.	It would seem simpler to use the Turbo-C function allocmem,	which always allocates aligned blocks.  However, allocmem	appears to conflict with the internal allocation of fopen	and other C library routines.*/void *sys_alloc_mem (      size_t   size     /* size in bytes to allocate */		    ){	int ix_save;      /* temp copy of table index */        void *addr;        /* addr returned by calloc (*void) */	word offset;      /* offset of unaligned address */	word seg;         /* segment addr of unaligned address */	void *addr_alig; /* aligned address */	int rem; /* temp for alignment computation */	/* ensure that allocation table is not full */	if (num_alloc >= MAX_ALLOC) {		return(NULL);	}	/* find free entry in allocation table */	ix_save = alloc_ix;	while (alloc_table[alloc_ix].original != NULL) {		alloc_ix++;		if (alloc_ix >= MAX_ALLOC) alloc_ix = 0;		/* safety check -- should never happen! */		if (alloc_ix == ix_save) return(NULL);	}	/* call allocation routine */	/* request 15 extra bytes to ensure alignment is possible */	addr = calloc(size + 15,1);	/* compute aligned base */	offset = FP_OFF(addr);        seg = FP_SEG(addr);	rem = offset % 16;	if (rem > 0) offset = offset + 16 - rem;	addr_alig = MK_FP(seg,offset);	/* insert entries in table */	alloc_table[alloc_ix].original = addr;	alloc_table[alloc_ix].aligned = addr_alig;	/* increment count */	num_alloc++;	return(addr_alig);}/*	Procedure: sys_free_mem	Purpose: free a memory block	Parameters:		void *ptr         ptr to block to allocate	Returns: integer error code; zero if OK		Calls:   free	Globals: alloc_table, num_alloc	Errors:  ERR_SUP_INVMEM    invalid memory block	This procedure receives an aligned address; it must	find and free the corresponding non-aligned one.*/int sys_free_mem (         void     *ptr     /* pointer to block */		 ){	void *free_addr;  /* true (unaligned) block address */	int free_ix;               /* temp table index */	/* ensure valid pointer */	if (ptr==NULL) return(ERR_SUP_INVMEM);	/* Look for the block in the allocation table */	free_addr = NULL;	for (free_ix=0; free_ix<MAX_ALLOC; free_ix++) {		if (alloc_table[free_ix].aligned == ptr) {			free_addr = alloc_table[free_ix].original;			break;		}	}	/* If the block wasn't found, report error */	if (free_addr == NULL) return(ERR_SUP_INVMEM);	/* free the block & clear the table entry */	alloc_table[free_ix].original = NULL;	alloc_table[free_ix].aligned = NULL;        free(free_addr);	/* decrement count */	num_alloc--;	return(OK);}        /*	Procedure: sys_get_date	Purpose: Returns the system date (month, day, year)	Parameters:		date_rec *date_p Pointer to structure of type date	Returns: void		Calls: none		Globals: sys_date        Errors: none*/void sys_get_date (  date_rec*      date_p   /* ptr to date record */		){	date_p->month = sys_date.da_mon;	date_p->day = sys_date.da_day;	date_p->year = sys_date.da_year;}/*	Procedure: sys_set_date	Purpose: Sets the system date (month, day, year)	Parameters:		date_rec *date_p ptr to structure of type date	Returns: error code; OK if no error	Calls:   none        Globals: sys_date	Errors: none*/int sys_set_date (  date_rec*       date_p   /* ptr to date record */		 ){	sys_date.da_mon = date_p->month;        sys_date.da_day = date_p->day;        sys_date.da_year = date_p->year;	return(OK);}/*	Procedure: sys_open_dir	Purpose: open a specified directory	Parameters: char dir_name[]            directory name	Returns: error code; zero if OK	Calls:   findfirst		strncpy  	Globals: current_path, file_block, num_entries	Errors:  ERR_SUP_DIROPN    directory open error		ERR_SUP_INVDIR    invalid directory*/int sys_open_dir (  char  path_name[]        /* directory name */		 ){        char temp_path[MAX_PATH_SIZE];	int res;        int len;        /* ensure there is no directory currently open */	if (current_path[0]!=NULCH) return(ERR_SUP_DIROPN);        /* check pathname for validity */        /* construct temporary search path name */	temp_path[0] = NULCH;	if (path_name != NULL) {		strncpy(temp_path,path_name,MAX_PATH_SIZE-4);	}	/* build wildcard search string */        len = strlen(temp_path);	/* if path is null, use current directory */        if (len==0) strcpy(temp_path,"*.*");	/* handle paths ending in backslash, including root */        else if (temp_path[len-1]=='\\') strcat(temp_path,"*.*");	/* handle paths not ending in backslash */        else strcat(temp_path,"\\*.*");	/* validate the directory by searching for either an ordinary	   file or a directory in it.  This should never fail; even	   empty directories contain the directories "." and ".."	*/		res = findfirst(temp_path, &file_block, FA_DIREC);	if (res!=0)  return(ERR_SUP_INVDIR);        /* save pathname as current, clear entry count */	current_path[0] = NULCH;	if (path_name != NULL) {		strncpy(current_path,path_name,MAX_PATH_SIZE-6);	}	num_entries = 0;	return(OK);}/*	Procedure: sys_get_entry	Purpose: get the next directory entry;	Parameters: char name_buf[]	name buffer		    int buf_size  	buffer capacity		    long *file_size_p	file length buffer         	Returns: error code, or zero if ok	Calls:	findfirst		findnext		strncpy, strcpy, strrchr, strcat    	Globals: current_path, num_entries, file_block	Errors:  ERR_SUP_NOENTR    no such entry*/int sys_get_entry (char    name_buf[],       /* buffer for entry */		   int   buf_size,         /* buffer size */		   long* file_size_p       /* buffer for size value */		  ){	char filename[MAX_PATH_SIZE+1];	int err;        int len;        char *cp;        /* find next MPX file entry, if any */        /* if this is the first call */	if (num_entries==0) {	       /* construct complete search path name */	       len = strlen(current_path);	       if (len==0) strcpy(current_path,"*.MPX");	       else if (current_path[len-1]=='\\') strcat(current_path,"*.MPX");	       else strcat(current_path,"\\*.MPX");	       /* find first entry */		err = findfirst (current_path,&file_block,0);        }        /* otherwise, find next entry */        else err = findnext(&file_block);        if (err<0) return(ERR_SUP_NOENTR);		/* ensure buf_size is not too large */		if (buf_size > MAX_PATH_SIZE) buf_size = MAX_PATH_SIZE;		      /* copy filename to buffer */	filename[buf_size] = NULCH;	strncpy (filename,file_block.ff_name,			 (size_t) buf_size);	/* remove ".MPX" from name */	cp = strrchr(filename, (int) '.');        *cp = NULCH;	/* copy name and size to caller's buffer */        strcpy (name_buf,filename);	*file_size_p = file_block.ff_fsize;        /* count entry */	num_entries++;	return(OK);}/*	Procedure: sys_close_dir	Purpose: close an open directory	Parameters: none	Returns: error code; zero if OK	Calls:   none	Globals: current_path	Errors:  none*/int sys_close_dir (void){	current_path[0] = NULCH;	return(OK);}/*	Procedure: sys_check_program	Purpose: locate and measure a program file	Parameters: see prototype	Returns: program size or error code	Calls:   strlen, strcat		fopen, fread	Globals: none	Errors:  ERR_SUP_NAMLNG    pathname too long		ERR_SUP_FILNFD    file not found		ERR_SUP_FILINV    file invalid*/#define HEADER_SIZE 32int sys_check_program(     char     dir_name[],       /* directory name */			char     prog_name[],      /* program name */			int*     prog_len_p,       /* ptr to prog length */			int*     start_offset_p    /* ptr to start offset */			){        /* buffer for full pathname */	char file_name[MAX_PATH_SIZE+1];        /* buffer for file header */        byte header[HEADER_SIZE];	FILE *file_p;     /* file pointer for C file routines */        int num_read;      /* number of header bytes read */	int file_size;    /* size of complete file */        int header_size;/* size of header */        int code_size;     /* size of program code */        int data_size;     /* size of program data */        int errcode;       /* error code */        /* ensure that path name is not too long */        if ((strlen(dir_name) + strlen(prog_name) + 5)		 > MAX_PATH_SIZE) return(ERR_SUP_NAMLNG);	/* construct path name */	file_name[0] = NULCH;	if (dir_name[0] != NULCH) {		strcat(file_name, dir_name);	        strcat(file_name, "\\");	}        strcat(file_name, prog_name);	strcat(file_name, ".MPX");        /* try to open the file */	errcode = OK;        file_p = fopen(file_name, "rb");        if (file_p == NULL) return(ERR_SUP_FILNFD);	/* read the header, check for EXE signature */        num_read = fread( (void*) header, 1, HEADER_SIZE, file_p);        if (num_read != HEADER_SIZE) {		errcode = ERR_SUP_FILINV;	}        else if ((header[0] != 0x4D) || (header[1] != 0x5A)) {		errcode = ERR_SUP_FILINV;	}        /* close the file, then return if error occurred */        fclose(file_p);	if (errcode!=OK) return(errcode);        /* compute allocation size needed */        file_size = (header[5]*256 + header[4] -1) * 512		+ (header[3]*256 + header[2]);        header_size =(header[9]*256 + header[8])*16;        code_size = file_size - header_size;        data_size = (header[11]*256 + header[10])*16;        /* return total length and starting offset */        *prog_len_p = code_size + data_size;	*start_offset_p = (header[23]*256 + header[22]) * 16;	return(OK);}/*	Procedure: sys_load_program	Purpose: load a program file	Parameters: see prototype	Returns: error code; zero if OK	Calls:   intdosx		segread		strlen, strcat	Globals: none 	Errors:  ERR_SUP_NAMLNG    name too long		ERR_SUP_FILNFD    file not found	       ERR_SUP_FILINV      file invalid		ERR_SUP_PROGSZ    program too large	       ERR_SUP_LDADDR      address not aligned		ERR_SUP_LDFAIL    load failed*/int sys_load_program (     void*    load_addr,        /* address for loading */			int      max_size,         /* memory size */			char     dir_name[],       /* directory name */			char     prog_name[]       /* program name */		      ){	int errcode;      /* error code */        int prog_len;      /* program length */	int offset;       /* offset for starting */	word norm_seg;    /* normalized load address segment */        word norm_off;     /* normalized load address offset */        /* full pathname for file to be loaded */	char file_name[MAX_PATH_SIZE+1];        /* parameter block for MSDOS EXEC function */	struct {		word load_seg;    /* segment address for loading */	       word reloc_seg;     /* segment address for relocation */        }p_block;	union REGS inregs;            /* input register structure */	union REGS outregs;           /* output register structure */	struct SREGS segregs;         /* segment register structure */        /* check program, get length and offset */	errcode = sys_check_program(dir_name, prog_name,					&prog_len, &offset);        if (errcode < 0) return(errcode);        /* ensure that allocated memory is large enough */        if (max_size < prog_len) return(ERR_SUP_PROGSZ);        /* get normalized segment and offset, check alignment */	norm_seg = FP_SEG(load_addr);	norm_off = FP_OFF(load_addr);	norm_seg += norm_off / 16;        norm_off %= 16;	if (norm_off != 0) return(ERR_SUP_LDADDR);        /* ensure that path name is not too long */        if ((strlen(dir_name) + strlen(prog_name) + 5)		 > MAX_PATH_SIZE) return(ERR_SUP_NAMLNG);	/* construct path name */	file_name[0] = NULCH;	if (dir_name[0] != NULCH) {		strcat(file_name, dir_name);	        strcat(file_name, "\\");	}        strcat(file_name, prog_name);	strcat(file_name, ".MPX");        /* get current segment regs */	segread(&segregs);        /* setup function codes */	inregs.h.ah = 0x4B;        /* EXEC function */	inregs.h.al = 0x03;        /* load only */        /* setup parameter block and name pointers */        segregs.ds = FP_SEG(&file_name);	inregs.x.dx = FP_OFF(&file_name);        segregs.es = FP_SEG(&p_block);	inregs.x.bx = FP_OFF(&p_block);        /* setup load segment -- must be normalized */	p_block.load_seg = norm_seg;	p_block.reloc_seg = p_block.load_seg;        /* call the MS-DOS loader */	errcode = intdosx(&inregs,&outregs,&segregs);        errcode = errcode;        /* check for error */	if (outregs.x.cflag) return(ERR_SUP_LDFAIL);	/* load successful */	return(OK);}/* END OF FILE */sys_req1,0
/***********************************************************************	MPX: The MultiProgramming eXecutive	Project to Accompany	A Practical Approach to Operating Systems	Malcolm G. Lane & James D. Mooney	Copyright 1993, P.W.S. Kent Publishing Co., Boston, MA.		File Name: mpx_supt.c	Authors: J.J. Patnesky, A. Ghosal, M. Lane, J. Mooney	Version: 2.1b	Date: 01/31/08	Purpose: Support routines for MPX-PC		Modules: all	Environment:      IBM-PC (XT, AT or PS/2)			MS-DOS 3.3 or later			TURBO-C 3.0 or TURBO-C++ 1.0 or later	Compile using the LARGE MODEL and SS NOT equal to DS.	All addresses and pointers are "far", and	CS, DS and SS are independent.	Procedures in this file:		sys_init		sys_exit		sys_set_vec		sys_req		sys_alloc_mem		sys_free_mem		sys_get_date		sys_set_date		sys_open_dir		sys_get_entry		sys_close_dir	       sys_check_program	       sys_load_program************************************************************************Change Log:	07/16/88  akg	added comments	02/25/92  jdm	full revision, UNIX version	04/14/92  jdm	Macintosh version	05/15/92  jdm	cleanup and documentation	07/14/92  jdm	update for revised specs        08/13/92  jdm 	revised IBM version; added private heap        10/14/92  jdm 	added check and load procedures        10/18/92  jdm 	revised sys_alloc_mem for alignment	11/17/92  jdm	true heap mgt, aligned, using calloc & free	11/19/92  jdm	enable device handling for final module	12/31/92  jdm	revised sys_req parameters	01/02/93  jdm	return count value after I/O	01/03/93  jdm	revised error names and codes	01/27/93  jdm	corrected count for line input in sys_req			fixed open_dir to handle null lines	02/24/93  jdm	changed sys_set_vec param to interrupt	03/08/93  jdm	corrections to sys_check & sys_load	03/20/93  jdm	stack switch in free, check, and load	04/22/93  jdm	corrected index conflict in sys_free_mem			added safety escape in alloc table search	07/28/93  jdm	conversion to large model	09/01/93  jdm	fixed allocation bug;  made date private	09/14/93  jdm	cleaned up memory allocation        09/16/93  jdm	adjusted program load for large model        09/30/93  jdm	modified for correct list of root directory	11/01/94  jdm	changed load file read to binary	09/18/95  jdm	fixed get_entry to default to current, not root	01/31/08  jdm   fixed possible overflow problem in get_entry************************************************************************/#include "mpx_supt.h"#include <stdlib.h>#include <dos.h>#include <dir.h>#include <errno.h>#include <conio.h>#include <alloc.h>#define VEC_ADDR (0x60L*4)#define MAX_ALLOC 200#define MAX_XPOS 79#define MAX_YPOS 24#define MAX_PATH_SIZE 50/*	System-dependent type definitions*/typedef unsigned char byte;typedef unsigned int word;typedef unsigned long longword;typedef byte *address;typedef struct params {	int      op_code;	int      device_id;	char     *buf_p;	int      *count_p;	} params;/*	Global variables accessed only by support routines*/	static longword vec_save;  /* saved interrupt vector */	static int mod_code;                /* module code */                                           	static struct date sys_date;        /* MPX system date */	/* data structures for directory access */        static char current_path[MAX_PATH_SIZE+1];        static int num_entries;        static struct ffblk file_block;        /* handler presence flags */	static flag sysc_hand;	static flag trm_hand;	static flag prt_hand;	static flag com_hand;        /* memory allocation table */	static struct {		void* original;		void* aligned;	} alloc_table[MAX_ALLOC];	static int alloc_ix;                /* current index */	static int num_alloc;               /* no. of allocated blocks *//*	Procedure: sys_init	Purpose: initialize mpx	Parameters: see prototype  	Return value: error code, or OK if no error	Calls: getdate    	Globals: mod_code		vec_save		sys_date		alloc_table, alloc_ix, num_alloc		sysc_hand, term_hand, prt_hand, com_hand	Errors: none*/int sys_init (    int      modules  /* module code */	     ){	mod_code = modules;        vec_save = 0L;        /* no handlers detected yet */	sysc_hand = FALSE;	trm_hand = FALSE;	prt_hand = FALSE;	com_hand = FALSE;	/* initialize allocation table */	for (alloc_ix=0; alloc_ix < MAX_ALLOC; alloc_ix++) {		alloc_table[alloc_ix].original = NULL;		alloc_table[alloc_ix].aligned = NULL;	}	alloc_ix = 0;	num_alloc = 0;	/* if we have reached Module R3, enable system call handling */	if (modules >= MODULE_R3) sysc_hand = TRUE;	/* if we have reached the final module, enable device handlers */	if (modules >= MODULE_F) {		trm_hand = TRUE;		prt_hand = TRUE;		com_hand = TRUE;	}	/* get system date */        getdate(&sys_date);	return (OK);}/*	Procedure: sys_exit	Purpose: terminate mpx	Parameters: none  	Return value: none	Calls: none       	Globals: vec_save*/void sys_exit(void){	longword *vec_p;	/* if trap vector changed, restore it */	if (vec_save != 0L) {		vec_p = (longword*) VEC_ADDR;		*vec_p = vec_save;	}	/* return to host with null error code */	exit(0);}/*	Procedure: sys_set_vec	Purpose: link trap vector to MPX system call handler	Parameters: handler: addr of handler         	Return value: error code; OK if no error	Calls: none       	Globals: vec_save	Errors: none*/int sys_set_vec   ( void interrupt (*handler)() /* system call handler */		){	longword *vec_p;			vec_p = (longword*) VEC_ADDR;		vec_save = *vec_p;		*vec_p = (longword) handler;	return (0);}/*	Procedure: sys_req	Purpose: Request a system service	Inputs:		op_code           operation code		device_id         device identifier		buf_p             addresso f data buffer		count_p           address of size of buffer	Returns: Result or error code, depending on service		Services supported:	IDLE     null operation				READ     input from a device				WRITE    output to a device				CLEAR    clear terminal screen				GOTOXY   absolute cursor position				EXIT     terminate the caller	Calls:   fgets		strlen			Globals: none		Errors:  ERR_SUP_INVDEV    invalid device		ERR_SUP_INVOPC    invalid operation code		ERR_SUP_INVPOS    invalid character position		ERR_SUP_RDFAIL    read failed		ERR_SUP_WRFAIL    write failed	Description:	For Modules R1 through R4,	this procedure is used only for terminal I/O.	Later modules support both reading and	writing for several devices.	For Modules R1 through R4,	sys_req uses the ANSI C function "fgets."	Later modules may use alternate functions and device drivers.*/int sys_req (   int      op_code, /* operation code */		int      device_id,        /* device id */		char*    buf_p,            /* I/O buffer */		int*     count_p           /* address of count */		){	int      rval;    /* result or error code */	char     *rp;     /* return pointer for fgets */	char     rc;      /* return char for fputc */        params    *param_p; /* pointer to parameter record in stack */	flag     docall;  /* true if system call interrupt wanted */	int      ix;      /* temporary index */	docall = FALSE;	rval = OK;	switch (op_code) {		case IDLE:		if (sysc_hand) docall = TRUE;		break; 				case READ:		switch (device_id) {				case TERMINAL:			if (trm_hand) docall = TRUE;			else {				rp = fgets(buf_p,*count_p,stdin);				if (rp==NULL) rval = ERR_SUP_RDFAIL;				else rval = strlen(buf_p);			}			break;					case COM_PORT:			if (com_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					default:			rval = ERR_SUP_INVDEV;					}		break;	case WRITE:		switch (device_id) {				case TERMINAL:			if (trm_hand) docall = TRUE;			else {				rval = *count_p;				for (ix=0; ix<*count_p; ix++) {					rc = fputc(buf_p[ix],stdout);					if (rc == EOF) {						rval = ERR_SUP_WRFAIL;						break;					}				}			}			break;					case COM_PORT:			if (com_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					case PRINTER:			if (prt_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					default:			rval = ERR_SUP_INVDEV;					}		break;	case CLEAR:		if (device_id==TERMINAL) {			if (trm_hand) docall = TRUE;			else {			     clrscr();				rval = 0;			}		}		else rval = ERR_SUP_INVDEV;		break;			case GOTOXY:		if (device_id==TERMINAL) {			if (trm_hand) docall = TRUE;			else {				if (*count_p != 2) rval = ERR_SUP_WRFAIL;				else if ((*buf_p<0)					|| (*buf_p > MAX_XPOS))					rval = ERR_SUP_WRFAIL;				else if ((*(buf_p+1)<0)					|| (*(buf_p+1) > MAX_YPOS))					rval = ERR_SUP_WRFAIL;				else {					gotoxy(*buf_p + 1,						*(buf_p+1) + 1);					rval = 0;				}			}		}		else rval = ERR_SUP_INVDEV;		break;			/* EXIT - terminate the calling process */	/* legal only when a system call handler is present */	case EXIT:		if (sysc_hand) docall = TRUE;		else rval = ERR_SUP_INVOPC;		break; 	default:		rval = ERR_SUP_INVOPC;			}		/* Invoke user's call handler if present.	   If the call is an IO request, return will occur	   only after the request is complete.	*/	if (docall && (rval==OK)) {		/* invoke the call handler */	_SP = _SP - sizeof(params);		param_p = (params*) MK_FP(_SS,_SP);	       param_p->op_code = op_code;	       param_p->device_id = device_id;	       param_p->buf_p = buf_p;	       param_p->count_p = count_p;	       geninterrupt(0x60);	       rval = _AX;	       _SP = _SP + sizeof(params);		/* for I/O operations, return count value */		switch(op_code) {		case READ:		case WRITE:		case CLEAR:		case GOTOXY:			rval = *count_p;		}	}	return(rval);}/*	Procedure: sys_alloc_mem	Purpose: Allocate a memory block	Parameters:			size_t size       No. of bytes to allocate	Returns: void* pointer to allocated block;		 null pointer in case of error		 	Calls: calloc		Globals: alloc_table, alloc_ix, num_alloc	For program loading (Module R-4), the blocks must be aligned.	This is achieved by requesting one extra paragraph and	returning the lowest aligned address as the base.  It is	necessary to keep a table of allocated address, original and	aligned, to support correct freeing.	It would seem simpler to use the Turbo-C function allocmem,	which always allocates aligned blocks.  However, allocmem	appears to conflict with the internal allocation of fopen	and other C library routines.*/void *sys_alloc_mem (      size_t   size     /* size in bytes to allocate */		    ){	int ix_save;      /* temp copy of table index */        void *addr;        /* addr returned by calloc (*void) */	word offset;      /* offset of unaligned address */	word seg;         /* segment addr of unaligned address */	void *addr_alig; /* aligned address */	int rem; /* temp for alignment computation */	/* ensure that allocation table is not full */	if (num_alloc >= MAX_ALLOC) {		return(NULL);	}	/* find free entry in allocation table */	ix_save = alloc_ix;	while (alloc_table[alloc_ix].original != NULL) {		alloc_ix++;		if (alloc_ix >= MAX_ALLOC) alloc_ix = 0;		/* safety check -- should never happen! */		if (alloc_ix == ix_save) return(NULL);	}	/* call allocation routine */	/* request 15 extra bytes to ensure alignment is possible */	addr = calloc(size + 15,1);	/* compute aligned base */	offset = FP_OFF(addr);        seg = FP_SEG(addr);	rem = offset % 16;	if (rem > 0) offset = offset + 16 - rem;	addr_alig = MK_FP(seg,offset);	/* insert entries in table */	alloc_table[alloc_ix].original = addr;	alloc_table[alloc_ix].aligned = addr_alig;	/* increment count */	num_alloc++;	return(addr_alig);}/*	Procedure: sys_free_mem	Purpose: free a memory block	Parameters:		void *ptr         ptr to block to allocate	Returns: integer error code; zero if OK		Calls:   free	Globals: alloc_table, num_alloc	Errors:  ERR_SUP_INVMEM    invalid memory block	This procedure receives an aligned address; it must	find and free the corresponding non-aligned one.*/int sys_free_mem (         void     *ptr     /* pointer to block */		 ){	void *free_addr;  /* true (unaligned) block address */	int free_ix;               /* temp table index */	/* ensure valid pointer */	if (ptr==NULL) return(ERR_SUP_INVMEM);	/* Look for the block in the allocation table */	free_addr = NULL;	for (free_ix=0; free_ix<MAX_ALLOC; free_ix++) {		if (alloc_table[free_ix].aligned == ptr) {			free_addr = alloc_table[free_ix].original;			break;		}	}	/* If the block wasn't found, report error */	if (free_addr == NULL) return(ERR_SUP_INVMEM);	/* free the block & clear the table entry */	alloc_table[free_ix].original = NULL;	alloc_table[free_ix].aligned = NULL;        free(free_addr);	/* decrement count */	num_alloc--;	return(OK);}        /*	Procedure: sys_get_date	Purpose: Returns the system date (month, day, year)	Parameters:		date_rec *date_p Pointer to structure of type date	Returns: void		Calls: none		Globals: sys_date        Errors: none*/void sys_get_date (  date_rec*      date_p   /* ptr to date record */		){	date_p->month = sys_date.da_mon;	date_p->day = sys_date.da_day;	date_p->year = sys_date.da_year;}/*	Procedure: sys_set_date	Purpose: Sets the system date (month, day, year)	Parameters:		date_rec *date_p ptr to structure of type date	Returns: error code; OK if no error	Calls:   none        Globals: sys_date	Errors: none*/int sys_set_date (  date_rec*       date_p   /* ptr to date record */		 ){	sys_date.da_mon = date_p->month;        sys_date.da_day = date_p->day;        sys_date.da_year = date_p->year;	return(OK);}/*	Procedure: sys_open_dir	Purpose: open a specified directory	Parameters: char dir_name[]            directory name	Returns: error code; zero if OK	Calls:   findfirst		strncpy  	Globals: current_path, file_block, num_entries	Errors:  ERR_SUP_DIROPN    directory open error		ERR_SUP_INVDIR    invalid directory*/int sys_open_dir (  char  path_name[]        /* directory name */		 ){        char temp_path[MAX_PATH_SIZE];	int res;        int len;        /* ensure there is no directory currently open */	if (current_path[0]!=NULCH) return(ERR_SUP_DIROPN);        /* check pathname for validity */        /* construct temporary search path name */	temp_path[0] = NULCH;	if (path_name != NULL) {		strncpy(temp_path,path_name,MAX_PATH_SIZE-4);	}	/* build wildcard search string */        len = strlen(temp_path);	/* if path is null, use current directory */        if (len==0) strcpy(temp_path,"*.*");	/* handle paths ending in backslash, including root */        else if (temp_path[len-1]=='\\') strcat(temp_path,"*.*");	/* handle paths not ending in backslash */        else strcat(temp_path,"\\*.*");	/* validate the directory by searching for either an ordinary	   file or a directory in it.  This should never fail; even	   empty directories contain the directories "." and ".."	*/		res = findfirst(temp_path, &file_block, FA_DIREC);	if (res!=0)  return(ERR_SUP_INVDIR);        /* save pathname as current, clear entry count */	current_path[0] = NULCH;	if (path_name != NULL) {		strncpy(current_path,path_name,MAX_PATH_SIZE-6);	}	num_entries = 0;	return(OK);}/*	Procedure: sys_get_entry	Purpose: get the next directory entry;	Parameters: char name_buf[]	name buffer		    int buf_size  	buffer capacity		    long *file_size_p	file length buffer         	Returns: error code, or zero if ok	Calls:	findfirst		findnext		strncpy, strcpy, strrchr, strcat    	Globals: current_path, num_entries, file_block	Errors:  ERR_SUP_NOENTR    no such entry*/int sys_get_entry (char    name_buf[],       /* buffer for entry */		   int   buf_size,         /* buffer size */		   long* file_size_p       /* buffer for size value */		  ){	char filename[MAX_PATH_SIZE+1];	int err;        int len;        char *cp;        /* find next MPX file entry, if any */        /* if this is the first call */	if (num_entries==0) {	       /* construct complete search path name */	       len = strlen(current_path);	       if (len==0) strcpy(current_path,"*.MPX");	       else if (current_path[len-1]=='\\') strcat(current_path,"*.MPX");	       else strcat(current_path,"\\*.MPX");	       /* find first entry */		err = findfirst (current_path,&file_block,0);        }        /* otherwise, find next entry */        else err = findnext(&file_block);        if (err<0) return(ERR_SUP_NOENTR);		/* ensure buf_size is not too large */		if (buf_size > MAX_PATH_SIZE) buf_size = MAX_PATH_SIZE;		      /* copy filename to buffer */	filename[buf_size] = NULCH;	strncpy (filename,file_block.ff_name,			 (size_t) buf_size);	/* remove ".MPX" from name */	cp = strrchr(filename, (int) '.');        *cp = NULCH;	/* copy name and size to caller's buffer */        strcpy (name_buf,filename);	*file_size_p = file_block.ff_fsize;        /* count entry */	num_entries++;	return(OK);}/*	Procedure: sys_close_dir	Purpose: close an open directory	Parameters: none	Returns: error code; zero if OK	Calls:   none	Globals: current_path	Errors:  none*/int sys_close_dir (void){	current_path[0] = NULCH;	return(OK);}/*	Procedure: sys_check_program	Purpose: locate and measure a program file	Parameters: see prototype	Returns: program size or error code	Calls:   strlen, strcat		fopen, fread	Globals: none	Errors:  ERR_SUP_NAMLNG    pathname too long		ERR_SUP_FILNFD    file not found		ERR_SUP_FILINV    file invalid*/#define HEADER_SIZE 32int sys_check_program(     char     dir_name[],       /* directory name */			char     prog_name[],      /* program name */			int*     prog_len_p,       /* ptr to prog length */			int*     start_offset_p    /* ptr to start offset */			){        /* buffer for full pathname */	char file_name[MAX_PATH_SIZE+1];        /* buffer for file header */        byte header[HEADER_SIZE];	FILE *file_p;     /* file pointer for C file routines */        int num_read;      /* number of header bytes read */	int file_size;    /* size of complete file */        int header_size;/* size of header */        int code_size;     /* size of program code */        int data_size;     /* size of program data */        int errcode;       /* error code */        /* ensure that path name is not too long */        if ((strlen(dir_name) + strlen(prog_name) + 5)		 > MAX_PATH_SIZE) return(ERR_SUP_NAMLNG);	/* construct path name */	file_name[0] = NULCH;	if (dir_name[0] != NULCH) {		strcat(file_name, dir_name);	        strcat(file_name, "\\");	}        strcat(file_name, prog_name);	strcat(file_name, ".MPX");        /* try to open the file */	errcode = OK;        file_p = fopen(file_name, "rb");        if (file_p == NULL) return(ERR_SUP_FILNFD);	/* read the header, check for EXE signature */        num_read = fread( (void*) header, 1, HEADER_SIZE, file_p);        if (num_read != HEADER_SIZE) {		errcode = ERR_SUP_FILINV;	}        else if ((header[0] != 0x4D) || (header[1] != 0x5A)) {		errcode = ERR_SUP_FILINV;	}        /* close the file, then return if error occurred */        fclose(file_p);	if (errcode!=OK) return(errcode);        /* compute allocation size needed */        file_size = (header[5]*256 + header[4] -1) * 512		+ (header[3]*256 + header[2]);        header_size =(header[9]*256 + header[8])*16;        code_size = file_size - header_size;        data_size = (header[11]*256 + header[10])*16;        /* return total length and starting offset */        *prog_len_p = code_size + data_size;	*start_offset_p = (header[23]*256 + header[22]) * 16;	return(OK);}/*	Procedure: sys_load_program	Purpose: load a program file	Parameters: see prototype	Returns: error code; zero if OK	Calls:   intdosx		segread		strlen, strcat	Globals: none 	Errors:  ERR_SUP_NAMLNG    name too long		ERR_SUP_FILNFD    file not found	       ERR_SUP_FILINV      file invalid		ERR_SUP_PROGSZ    program too large	       ERR_SUP_LDADDR      address not aligned		ERR_SUP_LDFAIL    load failed*/int sys_load_program (     void*    load_addr,        /* address for loading */			int      max_size,         /* memory size */			char     dir_name[],       /* directory name */			char     prog_name[]       /* program name */		      ){	int errcode;      /* error code */        int prog_len;      /* program length */	int offset;       /* offset for starting */	word norm_seg;    /* normalized load address segment */        word norm_off;     /* normalized load address offset */        /* full pathname for file to be loaded */	char file_name[MAX_PATH_SIZE+1];        /* parameter block for MSDOS EXEC function */	struct {		word load_seg;    /* segment address for loading */	       word reloc_seg;     /* segment address for relocation */        }p_block;	union REGS inregs;            /* input register structure */	union REGS outregs;           /* output register structure */	struct SREGS segregs;         /* segment register structure */        /* check program, get length and offset */	errcode = sys_check_program(dir_name, prog_name,					&prog_len, &offset);        if (errcode < 0) return(errcode);        /* ensure that allocated memory is large enough */        if (max_size < prog_len) return(ERR_SUP_PROGSZ);        /* get normalized segment and offset, check alignment */	norm_seg = FP_SEG(load_addr);	norm_off = FP_OFF(load_addr);	norm_seg += norm_off / 16;        norm_off %= 16;	if (norm_off != 0) return(ERR_SUP_LDADDR);        /* ensure that path name is not too long */        if ((strlen(dir_name) + strlen(prog_name) + 5)		 > MAX_PATH_SIZE) return(ERR_SUP_NAMLNG);	/* construct path name */	file_name[0] = NULCH;	if (dir_name[0] != NULCH) {		strcat(file_name, dir_name);	        strcat(file_name, "\\");	}        strcat(file_name, prog_name);	strcat(file_name, ".MPX");        /* get current segment regs */	segread(&segregs);        /* setup function codes */	inregs.h.ah = 0x4B;        /* EXEC function */	inregs.h.al = 0x03;        /* load only */        /* setup parameter block and name pointers */        segregs.ds = FP_SEG(&file_name);	inregs.x.dx = FP_OFF(&file_name);        segregs.es = FP_SEG(&p_block);	inregs.x.bx = FP_OFF(&p_block);        /* setup load segment -- must be normalized */	p_block.load_seg = norm_seg;	p_block.reloc_seg = p_block.load_seg;        /* call the MS-DOS loader */	errcode = intdosx(&inregs,&outregs,&segregs);        errcode = errcode;        /* check for error */	if (outregs.x.cflag) return(ERR_SUP_LDFAIL);	/* load successful */	return(OK);}/* END OF FILE */sys_alloc_mem1,0
/***********************************************************************	MPX: The MultiProgramming eXecutive	Project to Accompany	A Practical Approach to Operating Systems	Malcolm G. Lane & James D. Mooney	Copyright 1993, P.W.S. Kent Publishing Co., Boston, MA.		File Name: mpx_supt.c	Authors: J.J. Patnesky, A. Ghosal, M. Lane, J. Mooney	Version: 2.1b	Date: 01/31/08	Purpose: Support routines for MPX-PC		Modules: all	Environment:      IBM-PC (XT, AT or PS/2)			MS-DOS 3.3 or later			TURBO-C 3.0 or TURBO-C++ 1.0 or later	Compile using the LARGE MODEL and SS NOT equal to DS.	All addresses and pointers are "far", and	CS, DS and SS are independent.	Procedures in this file:		sys_init		sys_exit		sys_set_vec		sys_req		sys_alloc_mem		sys_free_mem		sys_get_date		sys_set_date		sys_open_dir		sys_get_entry		sys_close_dir	       sys_check_program	       sys_load_program************************************************************************Change Log:	07/16/88  akg	added comments	02/25/92  jdm	full revision, UNIX version	04/14/92  jdm	Macintosh version	05/15/92  jdm	cleanup and documentation	07/14/92  jdm	update for revised specs        08/13/92  jdm 	revised IBM version; added private heap        10/14/92  jdm 	added check and load procedures        10/18/92  jdm 	revised sys_alloc_mem for alignment	11/17/92  jdm	true heap mgt, aligned, using calloc & free	11/19/92  jdm	enable device handling for final module	12/31/92  jdm	revised sys_req parameters	01/02/93  jdm	return count value after I/O	01/03/93  jdm	revised error names and codes	01/27/93  jdm	corrected count for line input in sys_req			fixed open_dir to handle null lines	02/24/93  jdm	changed sys_set_vec param to interrupt	03/08/93  jdm	corrections to sys_check & sys_load	03/20/93  jdm	stack switch in free, check, and load	04/22/93  jdm	corrected index conflict in sys_free_mem			added safety escape in alloc table search	07/28/93  jdm	conversion to large model	09/01/93  jdm	fixed allocation bug;  made date private	09/14/93  jdm	cleaned up memory allocation        09/16/93  jdm	adjusted program load for large model        09/30/93  jdm	modified for correct list of root directory	11/01/94  jdm	changed load file read to binary	09/18/95  jdm	fixed get_entry to default to current, not root	01/31/08  jdm   fixed possible overflow problem in get_entry************************************************************************/#include "mpx_supt.h"#include <stdlib.h>#include <dos.h>#include <dir.h>#include <errno.h>#include <conio.h>#include <alloc.h>#define VEC_ADDR (0x60L*4)#define MAX_ALLOC 200#define MAX_XPOS 79#define MAX_YPOS 24#define MAX_PATH_SIZE 50/*	System-dependent type definitions*/typedef unsigned char byte;typedef unsigned int word;typedef unsigned long longword;typedef byte *address;typedef struct params {	int      op_code;	int      device_id;	char     *buf_p;	int      *count_p;	} params;/*	Global variables accessed only by support routines*/	static longword vec_save;  /* saved interrupt vector */	static int mod_code;                /* module code */                                           	static struct date sys_date;        /* MPX system date */	/* data structures for directory access */        static char current_path[MAX_PATH_SIZE+1];        static int num_entries;        static struct ffblk file_block;        /* handler presence flags */	static flag sysc_hand;	static flag trm_hand;	static flag prt_hand;	static flag com_hand;        /* memory allocation table */	static struct {		void* original;		void* aligned;	} alloc_table[MAX_ALLOC];	static int alloc_ix;                /* current index */	static int num_alloc;               /* no. of allocated blocks *//*	Procedure: sys_init	Purpose: initialize mpx	Parameters: see prototype  	Return value: error code, or OK if no error	Calls: getdate    	Globals: mod_code		vec_save		sys_date		alloc_table, alloc_ix, num_alloc		sysc_hand, term_hand, prt_hand, com_hand	Errors: none*/int sys_init (    int      modules  /* module code */	     ){	mod_code = modules;        vec_save = 0L;        /* no handlers detected yet */	sysc_hand = FALSE;	trm_hand = FALSE;	prt_hand = FALSE;	com_hand = FALSE;	/* initialize allocation table */	for (alloc_ix=0; alloc_ix < MAX_ALLOC; alloc_ix++) {		alloc_table[alloc_ix].original = NULL;		alloc_table[alloc_ix].aligned = NULL;	}	alloc_ix = 0;	num_alloc = 0;	/* if we have reached Module R3, enable system call handling */	if (modules >= MODULE_R3) sysc_hand = TRUE;	/* if we have reached the final module, enable device handlers */	if (modules >= MODULE_F) {		trm_hand = TRUE;		prt_hand = TRUE;		com_hand = TRUE;	}	/* get system date */        getdate(&sys_date);	return (OK);}/*	Procedure: sys_exit	Purpose: terminate mpx	Parameters: none  	Return value: none	Calls: none       	Globals: vec_save*/void sys_exit(void){	longword *vec_p;	/* if trap vector changed, restore it */	if (vec_save != 0L) {		vec_p = (longword*) VEC_ADDR;		*vec_p = vec_save;	}	/* return to host with null error code */	exit(0);}/*	Procedure: sys_set_vec	Purpose: link trap vector to MPX system call handler	Parameters: handler: addr of handler         	Return value: error code; OK if no error	Calls: none       	Globals: vec_save	Errors: none*/int sys_set_vec   ( void interrupt (*handler)() /* system call handler */		){	longword *vec_p;			vec_p = (longword*) VEC_ADDR;		vec_save = *vec_p;		*vec_p = (longword) handler;	return (0);}/*	Procedure: sys_req	Purpose: Request a system service	Inputs:		op_code           operation code		device_id         device identifier		buf_p             addresso f data buffer		count_p           address of size of buffer	Returns: Result or error code, depending on service		Services supported:	IDLE     null operation				READ     input from a device				WRITE    output to a device				CLEAR    clear terminal screen				GOTOXY   absolute cursor position				EXIT     terminate the caller	Calls:   fgets		strlen			Globals: none		Errors:  ERR_SUP_INVDEV    invalid device		ERR_SUP_INVOPC    invalid operation code		ERR_SUP_INVPOS    invalid character position		ERR_SUP_RDFAIL    read failed		ERR_SUP_WRFAIL    write failed	Description:	For Modules R1 through R4,	this procedure is used only for terminal I/O.	Later modules support both reading and	writing for several devices.	For Modules R1 through R4,	sys_req uses the ANSI C function "fgets."	Later modules may use alternate functions and device drivers.*/int sys_req (   int      op_code, /* operation code */		int      device_id,        /* device id */		char*    buf_p,            /* I/O buffer */		int*     count_p           /* address of count */		){	int      rval;    /* result or error code */	char     *rp;     /* return pointer for fgets */	char     rc;      /* return char for fputc */        params    *param_p; /* pointer to parameter record in stack */	flag     docall;  /* true if system call interrupt wanted */	int      ix;      /* temporary index */	docall = FALSE;	rval = OK;	switch (op_code) {		case IDLE:		if (sysc_hand) docall = TRUE;		break; 				case READ:		switch (device_id) {				case TERMINAL:			if (trm_hand) docall = TRUE;			else {				rp = fgets(buf_p,*count_p,stdin);				if (rp==NULL) rval = ERR_SUP_RDFAIL;				else rval = strlen(buf_p);			}			break;					case COM_PORT:			if (com_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					default:			rval = ERR_SUP_INVDEV;					}		break;	case WRITE:		switch (device_id) {				case TERMINAL:			if (trm_hand) docall = TRUE;			else {				rval = *count_p;				for (ix=0; ix<*count_p; ix++) {					rc = fputc(buf_p[ix],stdout);					if (rc == EOF) {						rval = ERR_SUP_WRFAIL;						break;					}				}			}			break;					case COM_PORT:			if (com_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					case PRINTER:			if (prt_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					default:			rval = ERR_SUP_INVDEV;					}		break;	case CLEAR:		if (device_id==TERMINAL) {			if (trm_hand) docall = TRUE;			else {			     clrscr();				rval = 0;			}		}		else rval = ERR_SUP_INVDEV;		break;			case GOTOXY:		if (device_id==TERMINAL) {			if (trm_hand) docall = TRUE;			else {				if (*count_p != 2) rval = ERR_SUP_WRFAIL;				else if ((*buf_p<0)					|| (*buf_p > MAX_XPOS))					rval = ERR_SUP_WRFAIL;				else if ((*(buf_p+1)<0)					|| (*(buf_p+1) > MAX_YPOS))					rval = ERR_SUP_WRFAIL;				else {					gotoxy(*buf_p + 1,						*(buf_p+1) + 1);					rval = 0;				}			}		}		else rval = ERR_SUP_INVDEV;		break;			/* EXIT - terminate the calling process */	/* legal only when a system call handler is present */	case EXIT:		if (sysc_hand) docall = TRUE;		else rval = ERR_SUP_INVOPC;		break; 	default:		rval = ERR_SUP_INVOPC;			}		/* Invoke user's call handler if present.	   If the call is an IO request, return will occur	   only after the request is complete.	*/	if (docall && (rval==OK)) {		/* invoke the call handler */	_SP = _SP - sizeof(params);		param_p = (params*) MK_FP(_SS,_SP);	       param_p->op_code = op_code;	       param_p->device_id = device_id;	       param_p->buf_p = buf_p;	       param_p->count_p = count_p;	       geninterrupt(0x60);	       rval = _AX;	       _SP = _SP + sizeof(params);		/* for I/O operations, return count value */		switch(op_code) {		case READ:		case WRITE:		case CLEAR:		case GOTOXY:			rval = *count_p;		}	}	return(rval);}/*	Procedure: sys_alloc_mem	Purpose: Allocate a memory block	Parameters:			size_t size       No. of bytes to allocate	Returns: void* pointer to allocated block;		 null pointer in case of error		 	Calls: calloc		Globals: alloc_table, alloc_ix, num_alloc	For program loading (Module R-4), the blocks must be aligned.	This is achieved by requesting one extra paragraph and	returning the lowest aligned address as the base.  It is	necessary to keep a table of allocated address, original and	aligned, to support correct freeing.	It would seem simpler to use the Turbo-C function allocmem,	which always allocates aligned blocks.  However, allocmem	appears to conflict with the internal allocation of fopen	and other C library routines.*/void *sys_alloc_mem (      size_t   size     /* size in bytes to allocate */		    ){	int ix_save;      /* temp copy of table index */        void *addr;        /* addr returned by calloc (*void) */	word offset;      /* offset of unaligned address */	word seg;         /* segment addr of unaligned address */	void *addr_alig; /* aligned address */	int rem; /* temp for alignment computation */	/* ensure that allocation table is not full */	if (num_alloc >= MAX_ALLOC) {		return(NULL);	}	/* find free entry in allocation table */	ix_save = alloc_ix;	while (alloc_table[alloc_ix].original != NULL) {		alloc_ix++;		if (alloc_ix >= MAX_ALLOC) alloc_ix = 0;		/* safety check -- should never happen! */		if (alloc_ix == ix_save) return(NULL);	}	/* call allocation routine */	/* request 15 extra bytes to ensure alignment is possible */	addr = calloc(size + 15,1);	/* compute aligned base */	offset = FP_OFF(addr);        seg = FP_SEG(addr);	rem = offset % 16;	if (rem > 0) offset = offset + 16 - rem;	addr_alig = MK_FP(seg,offset);	/* insert entries in table */	alloc_table[alloc_ix].original = addr;	alloc_table[alloc_ix].aligned = addr_alig;	/* increment count */	num_alloc++;	return(addr_alig);}/*	Procedure: sys_free_mem	Purpose: free a memory block	Parameters:		void *ptr         ptr to block to allocate	Returns: integer error code; zero if OK		Calls:   free	Globals: alloc_table, num_alloc	Errors:  ERR_SUP_INVMEM    invalid memory block	This procedure receives an aligned address; it must	find and free the corresponding non-aligned one.*/int sys_free_mem (         void     *ptr     /* pointer to block */		 ){	void *free_addr;  /* true (unaligned) block address */	int free_ix;               /* temp table index */	/* ensure valid pointer */	if (ptr==NULL) return(ERR_SUP_INVMEM);	/* Look for the block in the allocation table */	free_addr = NULL;	for (free_ix=0; free_ix<MAX_ALLOC; free_ix++) {		if (alloc_table[free_ix].aligned == ptr) {			free_addr = alloc_table[free_ix].original;			break;		}	}	/* If the block wasn't found, report error */	if (free_addr == NULL) return(ERR_SUP_INVMEM);	/* free the block & clear the table entry */	alloc_table[free_ix].original = NULL;	alloc_table[free_ix].aligned = NULL;        free(free_addr);	/* decrement count */	num_alloc--;	return(OK);}        /*	Procedure: sys_get_date	Purpose: Returns the system date (month, day, year)	Parameters:		date_rec *date_p Pointer to structure of type date	Returns: void		Calls: none		Globals: sys_date        Errors: none*/void sys_get_date (  date_rec*      date_p   /* ptr to date record */		){	date_p->month = sys_date.da_mon;	date_p->day = sys_date.da_day;	date_p->year = sys_date.da_year;}/*	Procedure: sys_set_date	Purpose: Sets the system date (month, day, year)	Parameters:		date_rec *date_p ptr to structure of type date	Returns: error code; OK if no error	Calls:   none        Globals: sys_date	Errors: none*/int sys_set_date (  date_rec*       date_p   /* ptr to date record */		 ){	sys_date.da_mon = date_p->month;        sys_date.da_day = date_p->day;        sys_date.da_year = date_p->year;	return(OK);}/*	Procedure: sys_open_dir	Purpose: open a specified directory	Parameters: char dir_name[]            directory name	Returns: error code; zero if OK	Calls:   findfirst		strncpy  	Globals: current_path, file_block, num_entries	Errors:  ERR_SUP_DIROPN    directory open error		ERR_SUP_INVDIR    invalid directory*/int sys_open_dir (  char  path_name[]        /* directory name */		 ){        char temp_path[MAX_PATH_SIZE];	int res;        int len;        /* ensure there is no directory currently open */	if (current_path[0]!=NULCH) return(ERR_SUP_DIROPN);        /* check pathname for validity */        /* construct temporary search path name */	temp_path[0] = NULCH;	if (path_name != NULL) {		strncpy(temp_path,path_name,MAX_PATH_SIZE-4);	}	/* build wildcard search string */        len = strlen(temp_path);	/* if path is null, use current directory */        if (len==0) strcpy(temp_path,"*.*");	/* handle paths ending in backslash, including root */        else if (temp_path[len-1]=='\\') strcat(temp_path,"*.*");	/* handle paths not ending in backslash */        else strcat(temp_path,"\\*.*");	/* validate the directory by searching for either an ordinary	   file or a directory in it.  This should never fail; even	   empty directories contain the directories "." and ".."	*/		res = findfirst(temp_path, &file_block, FA_DIREC);	if (res!=0)  return(ERR_SUP_INVDIR);        /* save pathname as current, clear entry count */	current_path[0] = NULCH;	if (path_name != NULL) {		strncpy(current_path,path_name,MAX_PATH_SIZE-6);	}	num_entries = 0;	return(OK);}/*	Procedure: sys_get_entry	Purpose: get the next directory entry;	Parameters: char name_buf[]	name buffer		    int buf_size  	buffer capacity		    long *file_size_p	file length buffer         	Returns: error code, or zero if ok	Calls:	findfirst		findnext		strncpy, strcpy, strrchr, strcat    	Globals: current_path, num_entries, file_block	Errors:  ERR_SUP_NOENTR    no such entry*/int sys_get_entry (char    name_buf[],       /* buffer for entry */		   int   buf_size,         /* buffer size */		   long* file_size_p       /* buffer for size value */		  ){	char filename[MAX_PATH_SIZE+1];	int err;        int len;        char *cp;        /* find next MPX file entry, if any */        /* if this is the first call */	if (num_entries==0) {	       /* construct complete search path name */	       len = strlen(current_path);	       if (len==0) strcpy(current_path,"*.MPX");	       else if (current_path[len-1]=='\\') strcat(current_path,"*.MPX");	       else strcat(current_path,"\\*.MPX");	       /* find first entry */		err = findfirst (current_path,&file_block,0);        }        /* otherwise, find next entry */        else err = findnext(&file_block);        if (err<0) return(ERR_SUP_NOENTR);		/* ensure buf_size is not too large */		if (buf_size > MAX_PATH_SIZE) buf_size = MAX_PATH_SIZE;		      /* copy filename to buffer */	filename[buf_size] = NULCH;	strncpy (filename,file_block.ff_name,			 (size_t) buf_size);	/* remove ".MPX" from name */	cp = strrchr(filename, (int) '.');        *cp = NULCH;	/* copy name and size to caller's buffer */        strcpy (name_buf,filename);	*file_size_p = file_block.ff_fsize;        /* count entry */	num_entries++;	return(OK);}/*	Procedure: sys_close_dir	Purpose: close an open directory	Parameters: none	Returns: error code; zero if OK	Calls:   none	Globals: current_path	Errors:  none*/int sys_close_dir (void){	current_path[0] = NULCH;	return(OK);}/*	Procedure: sys_check_program	Purpose: locate and measure a program file	Parameters: see prototype	Returns: program size or error code	Calls:   strlen, strcat		fopen, fread	Globals: none	Errors:  ERR_SUP_NAMLNG    pathname too long		ERR_SUP_FILNFD    file not found		ERR_SUP_FILINV    file invalid*/#define HEADER_SIZE 32int sys_check_program(     char     dir_name[],       /* directory name */			char     prog_name[],      /* program name */			int*     prog_len_p,       /* ptr to prog length */			int*     start_offset_p    /* ptr to start offset */			){        /* buffer for full pathname */	char file_name[MAX_PATH_SIZE+1];        /* buffer for file header */        byte header[HEADER_SIZE];	FILE *file_p;     /* file pointer for C file routines */        int num_read;      /* number of header bytes read */	int file_size;    /* size of complete file */        int header_size;/* size of header */        int code_size;     /* size of program code */        int data_size;     /* size of program data */        int errcode;       /* error code */        /* ensure that path name is not too long */        if ((strlen(dir_name) + strlen(prog_name) + 5)		 > MAX_PATH_SIZE) return(ERR_SUP_NAMLNG);	/* construct path name */	file_name[0] = NULCH;	if (dir_name[0] != NULCH) {		strcat(file_name, dir_name);	        strcat(file_name, "\\");	}        strcat(file_name, prog_name);	strcat(file_name, ".MPX");        /* try to open the file */	errcode = OK;        file_p = fopen(file_name, "rb");        if (file_p == NULL) return(ERR_SUP_FILNFD);	/* read the header, check for EXE signature */        num_read = fread( (void*) header, 1, HEADER_SIZE, file_p);        if (num_read != HEADER_SIZE) {		errcode = ERR_SUP_FILINV;	}        else if ((header[0] != 0x4D) || (header[1] != 0x5A)) {		errcode = ERR_SUP_FILINV;	}        /* close the file, then return if error occurred */        fclose(file_p);	if (errcode!=OK) return(errcode);        /* compute allocation size needed */        file_size = (header[5]*256 + header[4] -1) * 512		+ (header[3]*256 + header[2]);        header_size =(header[9]*256 + header[8])*16;        code_size = file_size - header_size;        data_size = (header[11]*256 + header[10])*16;        /* return total length and starting offset */        *prog_len_p = code_size + data_size;	*start_offset_p = (header[23]*256 + header[22]) * 16;	return(OK);}/*	Procedure: sys_load_program	Purpose: load a program file	Parameters: see prototype	Returns: error code; zero if OK	Calls:   intdosx		segread		strlen, strcat	Globals: none 	Errors:  ERR_SUP_NAMLNG    name too long		ERR_SUP_FILNFD    file not found	       ERR_SUP_FILINV      file invalid		ERR_SUP_PROGSZ    program too large	       ERR_SUP_LDADDR      address not aligned		ERR_SUP_LDFAIL    load failed*/int sys_load_program (     void*    load_addr,        /* address for loading */			int      max_size,         /* memory size */			char     dir_name[],       /* directory name */			char     prog_name[]       /* program name */		      ){	int errcode;      /* error code */        int prog_len;      /* program length */	int offset;       /* offset for starting */	word norm_seg;    /* normalized load address segment */        word norm_off;     /* normalized load address offset */        /* full pathname for file to be loaded */	char file_name[MAX_PATH_SIZE+1];        /* parameter block for MSDOS EXEC function */	struct {		word load_seg;    /* segment address for loading */	       word reloc_seg;     /* segment address for relocation */        }p_block;	union REGS inregs;            /* input register structure */	union REGS outregs;           /* output register structure */	struct SREGS segregs;         /* segment register structure */        /* check program, get length and offset */	errcode = sys_check_program(dir_name, prog_name,					&prog_len, &offset);        if (errcode < 0) return(errcode);        /* ensure that allocated memory is large enough */        if (max_size < prog_len) return(ERR_SUP_PROGSZ);        /* get normalized segment and offset, check alignment */	norm_seg = FP_SEG(load_addr);	norm_off = FP_OFF(load_addr);	norm_seg += norm_off / 16;        norm_off %= 16;	if (norm_off != 0) return(ERR_SUP_LDADDR);        /* ensure that path name is not too long */        if ((strlen(dir_name) + strlen(prog_name) + 5)		 > MAX_PATH_SIZE) return(ERR_SUP_NAMLNG);	/* construct path name */	file_name[0] = NULCH;	if (dir_name[0] != NULCH) {		strcat(file_name, dir_name);	        strcat(file_name, "\\");	}        strcat(file_name, prog_name);	strcat(file_name, ".MPX");        /* get current segment regs */	segread(&segregs);        /* setup function codes */	inregs.h.ah = 0x4B;        /* EXEC function */	inregs.h.al = 0x03;        /* load only */        /* setup parameter block and name pointers */        segregs.ds = FP_SEG(&file_name);	inregs.x.dx = FP_OFF(&file_name);        segregs.es = FP_SEG(&p_block);	inregs.x.bx = FP_OFF(&p_block);        /* setup load segment -- must be normalized */	p_block.load_seg = norm_seg;	p_block.reloc_seg = p_block.load_seg;        /* call the MS-DOS loader */	errcode = intdosx(&inregs,&outregs,&segregs);        errcode = errcode;        /* check for error */	if (outregs.x.cflag) return(ERR_SUP_LDFAIL);	/* load successful */	return(OK);}/* END OF FILE */sys_free_mem1,0
/***********************************************************************	MPX: The MultiProgramming eXecutive	Project to Accompany	A Practical Approach to Operating Systems	Malcolm G. Lane & James D. Mooney	Copyright 1993, P.W.S. Kent Publishing Co., Boston, MA.		File Name: mpx_supt.c	Authors: J.J. Patnesky, A. Ghosal, M. Lane, J. Mooney	Version: 2.1b	Date: 01/31/08	Purpose: Support routines for MPX-PC		Modules: all	Environment:      IBM-PC (XT, AT or PS/2)			MS-DOS 3.3 or later			TURBO-C 3.0 or TURBO-C++ 1.0 or later	Compile using the LARGE MODEL and SS NOT equal to DS.	All addresses and pointers are "far", and	CS, DS and SS are independent.	Procedures in this file:		sys_init		sys_exit		sys_set_vec		sys_req		sys_alloc_mem		sys_free_mem		sys_get_date		sys_set_date		sys_open_dir		sys_get_entry		sys_close_dir	       sys_check_program	       sys_load_program************************************************************************Change Log:	07/16/88  akg	added comments	02/25/92  jdm	full revision, UNIX version	04/14/92  jdm	Macintosh version	05/15/92  jdm	cleanup and documentation	07/14/92  jdm	update for revised specs        08/13/92  jdm 	revised IBM version; added private heap        10/14/92  jdm 	added check and load procedures        10/18/92  jdm 	revised sys_alloc_mem for alignment	11/17/92  jdm	true heap mgt, aligned, using calloc & free	11/19/92  jdm	enable device handling for final module	12/31/92  jdm	revised sys_req parameters	01/02/93  jdm	return count value after I/O	01/03/93  jdm	revised error names and codes	01/27/93  jdm	corrected count for line input in sys_req			fixed open_dir to handle null lines	02/24/93  jdm	changed sys_set_vec param to interrupt	03/08/93  jdm	corrections to sys_check & sys_load	03/20/93  jdm	stack switch in free, check, and load	04/22/93  jdm	corrected index conflict in sys_free_mem			added safety escape in alloc table search	07/28/93  jdm	conversion to large model	09/01/93  jdm	fixed allocation bug;  made date private	09/14/93  jdm	cleaned up memory allocation        09/16/93  jdm	adjusted program load for large model        09/30/93  jdm	modified for correct list of root directory	11/01/94  jdm	changed load file read to binary	09/18/95  jdm	fixed get_entry to default to current, not root	01/31/08  jdm   fixed possible overflow problem in get_entry************************************************************************/#include "mpx_supt.h"#include <stdlib.h>#include <dos.h>#include <dir.h>#include <errno.h>#include <conio.h>#include <alloc.h>#define VEC_ADDR (0x60L*4)#define MAX_ALLOC 200#define MAX_XPOS 79#define MAX_YPOS 24#define MAX_PATH_SIZE 50/*	System-dependent type definitions*/typedef unsigned char byte;typedef unsigned int word;typedef unsigned long longword;typedef byte *address;typedef struct params {	int      op_code;	int      device_id;	char     *buf_p;	int      *count_p;	} params;/*	Global variables accessed only by support routines*/	static longword vec_save;  /* saved interrupt vector */	static int mod_code;                /* module code */                                           	static struct date sys_date;        /* MPX system date */	/* data structures for directory access */        static char current_path[MAX_PATH_SIZE+1];        static int num_entries;        static struct ffblk file_block;        /* handler presence flags */	static flag sysc_hand;	static flag trm_hand;	static flag prt_hand;	static flag com_hand;        /* memory allocation table */	static struct {		void* original;		void* aligned;	} alloc_table[MAX_ALLOC];	static int alloc_ix;                /* current index */	static int num_alloc;               /* no. of allocated blocks *//*	Procedure: sys_init	Purpose: initialize mpx	Parameters: see prototype  	Return value: error code, or OK if no error	Calls: getdate    	Globals: mod_code		vec_save		sys_date		alloc_table, alloc_ix, num_alloc		sysc_hand, term_hand, prt_hand, com_hand	Errors: none*/int sys_init (    int      modules  /* module code */	     ){	mod_code = modules;        vec_save = 0L;        /* no handlers detected yet */	sysc_hand = FALSE;	trm_hand = FALSE;	prt_hand = FALSE;	com_hand = FALSE;	/* initialize allocation table */	for (alloc_ix=0; alloc_ix < MAX_ALLOC; alloc_ix++) {		alloc_table[alloc_ix].original = NULL;		alloc_table[alloc_ix].aligned = NULL;	}	alloc_ix = 0;	num_alloc = 0;	/* if we have reached Module R3, enable system call handling */	if (modules >= MODULE_R3) sysc_hand = TRUE;	/* if we have reached the final module, enable device handlers */	if (modules >= MODULE_F) {		trm_hand = TRUE;		prt_hand = TRUE;		com_hand = TRUE;	}	/* get system date */        getdate(&sys_date);	return (OK);}/*	Procedure: sys_exit	Purpose: terminate mpx	Parameters: none  	Return value: none	Calls: none       	Globals: vec_save*/void sys_exit(void){	longword *vec_p;	/* if trap vector changed, restore it */	if (vec_save != 0L) {		vec_p = (longword*) VEC_ADDR;		*vec_p = vec_save;	}	/* return to host with null error code */	exit(0);}/*	Procedure: sys_set_vec	Purpose: link trap vector to MPX system call handler	Parameters: handler: addr of handler         	Return value: error code; OK if no error	Calls: none       	Globals: vec_save	Errors: none*/int sys_set_vec   ( void interrupt (*handler)() /* system call handler */		){	longword *vec_p;			vec_p = (longword*) VEC_ADDR;		vec_save = *vec_p;		*vec_p = (longword) handler;	return (0);}/*	Procedure: sys_req	Purpose: Request a system service	Inputs:		op_code           operation code		device_id         device identifier		buf_p             addresso f data buffer		count_p           address of size of buffer	Returns: Result or error code, depending on service		Services supported:	IDLE     null operation				READ     input from a device				WRITE    output to a device				CLEAR    clear terminal screen				GOTOXY   absolute cursor position				EXIT     terminate the caller	Calls:   fgets		strlen			Globals: none		Errors:  ERR_SUP_INVDEV    invalid device		ERR_SUP_INVOPC    invalid operation code		ERR_SUP_INVPOS    invalid character position		ERR_SUP_RDFAIL    read failed		ERR_SUP_WRFAIL    write failed	Description:	For Modules R1 through R4,	this procedure is used only for terminal I/O.	Later modules support both reading and	writing for several devices.	For Modules R1 through R4,	sys_req uses the ANSI C function "fgets."	Later modules may use alternate functions and device drivers.*/int sys_req (   int      op_code, /* operation code */		int      device_id,        /* device id */		char*    buf_p,            /* I/O buffer */		int*     count_p           /* address of count */		){	int      rval;    /* result or error code */	char     *rp;     /* return pointer for fgets */	char     rc;      /* return char for fputc */        params    *param_p; /* pointer to parameter record in stack */	flag     docall;  /* true if system call interrupt wanted */	int      ix;      /* temporary index */	docall = FALSE;	rval = OK;	switch (op_code) {		case IDLE:		if (sysc_hand) docall = TRUE;		break; 				case READ:		switch (device_id) {				case TERMINAL:			if (trm_hand) docall = TRUE;			else {				rp = fgets(buf_p,*count_p,stdin);				if (rp==NULL) rval = ERR_SUP_RDFAIL;				else rval = strlen(buf_p);			}			break;					case COM_PORT:			if (com_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					default:			rval = ERR_SUP_INVDEV;					}		break;	case WRITE:		switch (device_id) {				case TERMINAL:			if (trm_hand) docall = TRUE;			else {				rval = *count_p;				for (ix=0; ix<*count_p; ix++) {					rc = fputc(buf_p[ix],stdout);					if (rc == EOF) {						rval = ERR_SUP_WRFAIL;						break;					}				}			}			break;					case COM_PORT:			if (com_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					case PRINTER:			if (prt_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					default:			rval = ERR_SUP_INVDEV;					}		break;	case CLEAR:		if (device_id==TERMINAL) {			if (trm_hand) docall = TRUE;			else {			     clrscr();				rval = 0;			}		}		else rval = ERR_SUP_INVDEV;		break;			case GOTOXY:		if (device_id==TERMINAL) {			if (trm_hand) docall = TRUE;			else {				if (*count_p != 2) rval = ERR_SUP_WRFAIL;				else if ((*buf_p<0)					|| (*buf_p > MAX_XPOS))					rval = ERR_SUP_WRFAIL;				else if ((*(buf_p+1)<0)					|| (*(buf_p+1) > MAX_YPOS))					rval = ERR_SUP_WRFAIL;				else {					gotoxy(*buf_p + 1,						*(buf_p+1) + 1);					rval = 0;				}			}		}		else rval = ERR_SUP_INVDEV;		break;			/* EXIT - terminate the calling process */	/* legal only when a system call handler is present */	case EXIT:		if (sysc_hand) docall = TRUE;		else rval = ERR_SUP_INVOPC;		break; 	default:		rval = ERR_SUP_INVOPC;			}		/* Invoke user's call handler if present.	   If the call is an IO request, return will occur	   only after the request is complete.	*/	if (docall && (rval==OK)) {		/* invoke the call handler */	_SP = _SP - sizeof(params);		param_p = (params*) MK_FP(_SS,_SP);	       param_p->op_code = op_code;	       param_p->device_id = device_id;	       param_p->buf_p = buf_p;	       param_p->count_p = count_p;	       geninterrupt(0x60);	       rval = _AX;	       _SP = _SP + sizeof(params);		/* for I/O operations, return count value */		switch(op_code) {		case READ:		case WRITE:		case CLEAR:		case GOTOXY:			rval = *count_p;		}	}	return(rval);}/*	Procedure: sys_alloc_mem	Purpose: Allocate a memory block	Parameters:			size_t size       No. of bytes to allocate	Returns: void* pointer to allocated block;		 null pointer in case of error		 	Calls: calloc		Globals: alloc_table, alloc_ix, num_alloc	For program loading (Module R-4), the blocks must be aligned.	This is achieved by requesting one extra paragraph and	returning the lowest aligned address as the base.  It is	necessary to keep a table of allocated address, original and	aligned, to support correct freeing.	It would seem simpler to use the Turbo-C function allocmem,	which always allocates aligned blocks.  However, allocmem	appears to conflict with the internal allocation of fopen	and other C library routines.*/void *sys_alloc_mem (      size_t   size     /* size in bytes to allocate */		    ){	int ix_save;      /* temp copy of table index */        void *addr;        /* addr returned by calloc (*void) */	word offset;      /* offset of unaligned address */	word seg;         /* segment addr of unaligned address */	void *addr_alig; /* aligned address */	int rem; /* temp for alignment computation */	/* ensure that allocation table is not full */	if (num_alloc >= MAX_ALLOC) {		return(NULL);	}	/* find free entry in allocation table */	ix_save = alloc_ix;	while (alloc_table[alloc_ix].original != NULL) {		alloc_ix++;		if (alloc_ix >= MAX_ALLOC) alloc_ix = 0;		/* safety check -- should never happen! */		if (alloc_ix == ix_save) return(NULL);	}	/* call allocation routine */	/* request 15 extra bytes to ensure alignment is possible */	addr = calloc(size + 15,1);	/* compute aligned base */	offset = FP_OFF(addr);        seg = FP_SEG(addr);	rem = offset % 16;	if (rem > 0) offset = offset + 16 - rem;	addr_alig = MK_FP(seg,offset);	/* insert entries in table */	alloc_table[alloc_ix].original = addr;	alloc_table[alloc_ix].aligned = addr_alig;	/* increment count */	num_alloc++;	return(addr_alig);}/*	Procedure: sys_free_mem	Purpose: free a memory block	Parameters:		void *ptr         ptr to block to allocate	Returns: integer error code; zero if OK		Calls:   free	Globals: alloc_table, num_alloc	Errors:  ERR_SUP_INVMEM    invalid memory block	This procedure receives an aligned address; it must	find and free the corresponding non-aligned one.*/int sys_free_mem (         void     *ptr     /* pointer to block */		 ){	void *free_addr;  /* true (unaligned) block address */	int free_ix;               /* temp table index */	/* ensure valid pointer */	if (ptr==NULL) return(ERR_SUP_INVMEM);	/* Look for the block in the allocation table */	free_addr = NULL;	for (free_ix=0; free_ix<MAX_ALLOC; free_ix++) {		if (alloc_table[free_ix].aligned == ptr) {			free_addr = alloc_table[free_ix].original;			break;		}	}	/* If the block wasn't found, report error */	if (free_addr == NULL) return(ERR_SUP_INVMEM);	/* free the block & clear the table entry */	alloc_table[free_ix].original = NULL;	alloc_table[free_ix].aligned = NULL;        free(free_addr);	/* decrement count */	num_alloc--;	return(OK);}        /*	Procedure: sys_get_date	Purpose: Returns the system date (month, day, year)	Parameters:		date_rec *date_p Pointer to structure of type date	Returns: void		Calls: none		Globals: sys_date        Errors: none*/void sys_get_date (  date_rec*      date_p   /* ptr to date record */		){	date_p->month = sys_date.da_mon;	date_p->day = sys_date.da_day;	date_p->year = sys_date.da_year;}/*	Procedure: sys_set_date	Purpose: Sets the system date (month, day, year)	Parameters:		date_rec *date_p ptr to structure of type date	Returns: error code; OK if no error	Calls:   none        Globals: sys_date	Errors: none*/int sys_set_date (  date_rec*       date_p   /* ptr to date record */		 ){	sys_date.da_mon = date_p->month;        sys_date.da_day = date_p->day;        sys_date.da_year = date_p->year;	return(OK);}/*	Procedure: sys_open_dir	Purpose: open a specified directory	Parameters: char dir_name[]            directory name	Returns: error code; zero if OK	Calls:   findfirst		strncpy  	Globals: current_path, file_block, num_entries	Errors:  ERR_SUP_DIROPN    directory open error		ERR_SUP_INVDIR    invalid directory*/int sys_open_dir (  char  path_name[]        /* directory name */		 ){        char temp_path[MAX_PATH_SIZE];	int res;        int len;        /* ensure there is no directory currently open */	if (current_path[0]!=NULCH) return(ERR_SUP_DIROPN);        /* check pathname for validity */        /* construct temporary search path name */	temp_path[0] = NULCH;	if (path_name != NULL) {		strncpy(temp_path,path_name,MAX_PATH_SIZE-4);	}	/* build wildcard search string */        len = strlen(temp_path);	/* if path is null, use current directory */        if (len==0) strcpy(temp_path,"*.*");	/* handle paths ending in backslash, including root */        else if (temp_path[len-1]=='\\') strcat(temp_path,"*.*");	/* handle paths not ending in backslash */        else strcat(temp_path,"\\*.*");	/* validate the directory by searching for either an ordinary	   file or a directory in it.  This should never fail; even	   empty directories contain the directories "." and ".."	*/		res = findfirst(temp_path, &file_block, FA_DIREC);	if (res!=0)  return(ERR_SUP_INVDIR);        /* save pathname as current, clear entry count */	current_path[0] = NULCH;	if (path_name != NULL) {		strncpy(current_path,path_name,MAX_PATH_SIZE-6);	}	num_entries = 0;	return(OK);}/*	Procedure: sys_get_entry	Purpose: get the next directory entry;	Parameters: char name_buf[]	name buffer		    int buf_size  	buffer capacity		    long *file_size_p	file length buffer         	Returns: error code, or zero if ok	Calls:	findfirst		findnext		strncpy, strcpy, strrchr, strcat    	Globals: current_path, num_entries, file_block	Errors:  ERR_SUP_NOENTR    no such entry*/int sys_get_entry (char    name_buf[],       /* buffer for entry */		   int   buf_size,         /* buffer size */		   long* file_size_p       /* buffer for size value */		  ){	char filename[MAX_PATH_SIZE+1];	int err;        int len;        char *cp;        /* find next MPX file entry, if any */        /* if this is the first call */	if (num_entries==0) {	       /* construct complete search path name */	       len = strlen(current_path);	       if (len==0) strcpy(current_path,"*.MPX");	       else if (current_path[len-1]=='\\') strcat(current_path,"*.MPX");	       else strcat(current_path,"\\*.MPX");	       /* find first entry */		err = findfirst (current_path,&file_block,0);        }        /* otherwise, find next entry */        else err = findnext(&file_block);        if (err<0) return(ERR_SUP_NOENTR);		/* ensure buf_size is not too large */		if (buf_size > MAX_PATH_SIZE) buf_size = MAX_PATH_SIZE;		      /* copy filename to buffer */	filename[buf_size] = NULCH;	strncpy (filename,file_block.ff_name,			 (size_t) buf_size);	/* remove ".MPX" from name */	cp = strrchr(filename, (int) '.');        *cp = NULCH;	/* copy name and size to caller's buffer */        strcpy (name_buf,filename);	*file_size_p = file_block.ff_fsize;        /* count entry */	num_entries++;	return(OK);}/*	Procedure: sys_close_dir	Purpose: close an open directory	Parameters: none	Returns: error code; zero if OK	Calls:   none	Globals: current_path	Errors:  none*/int sys_close_dir (void){	current_path[0] = NULCH;	return(OK);}/*	Procedure: sys_check_program	Purpose: locate and measure a program file	Parameters: see prototype	Returns: program size or error code	Calls:   strlen, strcat		fopen, fread	Globals: none	Errors:  ERR_SUP_NAMLNG    pathname too long		ERR_SUP_FILNFD    file not found		ERR_SUP_FILINV    file invalid*/#define HEADER_SIZE 32int sys_check_program(     char     dir_name[],       /* directory name */			char     prog_name[],      /* program name */			int*     prog_len_p,       /* ptr to prog length */			int*     start_offset_p    /* ptr to start offset */			){        /* buffer for full pathname */	char file_name[MAX_PATH_SIZE+1];        /* buffer for file header */        byte header[HEADER_SIZE];	FILE *file_p;     /* file pointer for C file routines */        int num_read;      /* number of header bytes read */	int file_size;    /* size of complete file */        int header_size;/* size of header */        int code_size;     /* size of program code */        int data_size;     /* size of program data */        int errcode;       /* error code */        /* ensure that path name is not too long */        if ((strlen(dir_name) + strlen(prog_name) + 5)		 > MAX_PATH_SIZE) return(ERR_SUP_NAMLNG);	/* construct path name */	file_name[0] = NULCH;	if (dir_name[0] != NULCH) {		strcat(file_name, dir_name);	        strcat(file_name, "\\");	}        strcat(file_name, prog_name);	strcat(file_name, ".MPX");        /* try to open the file */	errcode = OK;        file_p = fopen(file_name, "rb");        if (file_p == NULL) return(ERR_SUP_FILNFD);	/* read the header, check for EXE signature */        num_read = fread( (void*) header, 1, HEADER_SIZE, file_p);        if (num_read != HEADER_SIZE) {		errcode = ERR_SUP_FILINV;	}        else if ((header[0] != 0x4D) || (header[1] != 0x5A)) {		errcode = ERR_SUP_FILINV;	}        /* close the file, then return if error occurred */        fclose(file_p);	if (errcode!=OK) return(errcode);        /* compute allocation size needed */        file_size = (header[5]*256 + header[4] -1) * 512		+ (header[3]*256 + header[2]);        header_size =(header[9]*256 + header[8])*16;        code_size = file_size - header_size;        data_size = (header[11]*256 + header[10])*16;        /* return total length and starting offset */        *prog_len_p = code_size + data_size;	*start_offset_p = (header[23]*256 + header[22]) * 16;	return(OK);}/*	Procedure: sys_load_program	Purpose: load a program file	Parameters: see prototype	Returns: error code; zero if OK	Calls:   intdosx		segread		strlen, strcat	Globals: none 	Errors:  ERR_SUP_NAMLNG    name too long		ERR_SUP_FILNFD    file not found	       ERR_SUP_FILINV      file invalid		ERR_SUP_PROGSZ    program too large	       ERR_SUP_LDADDR      address not aligned		ERR_SUP_LDFAIL    load failed*/int sys_load_program (     void*    load_addr,        /* address for loading */			int      max_size,         /* memory size */			char     dir_name[],       /* directory name */			char     prog_name[]       /* program name */		      ){	int errcode;      /* error code */        int prog_len;      /* program length */	int offset;       /* offset for starting */	word norm_seg;    /* normalized load address segment */        word norm_off;     /* normalized load address offset */        /* full pathname for file to be loaded */	char file_name[MAX_PATH_SIZE+1];        /* parameter block for MSDOS EXEC function */	struct {		word load_seg;    /* segment address for loading */	       word reloc_seg;     /* segment address for relocation */        }p_block;	union REGS inregs;            /* input register structure */	union REGS outregs;           /* output register structure */	struct SREGS segregs;         /* segment register structure */        /* check program, get length and offset */	errcode = sys_check_program(dir_name, prog_name,					&prog_len, &offset);        if (errcode < 0) return(errcode);        /* ensure that allocated memory is large enough */        if (max_size < prog_len) return(ERR_SUP_PROGSZ);        /* get normalized segment and offset, check alignment */	norm_seg = FP_SEG(load_addr);	norm_off = FP_OFF(load_addr);	norm_seg += norm_off / 16;        norm_off %= 16;	if (norm_off != 0) return(ERR_SUP_LDADDR);        /* ensure that path name is not too long */        if ((strlen(dir_name) + strlen(prog_name) + 5)		 > MAX_PATH_SIZE) return(ERR_SUP_NAMLNG);	/* construct path name */	file_name[0] = NULCH;	if (dir_name[0] != NULCH) {		strcat(file_name, dir_name);	        strcat(file_name, "\\");	}        strcat(file_name, prog_name);	strcat(file_name, ".MPX");        /* get current segment regs */	segread(&segregs);        /* setup function codes */	inregs.h.ah = 0x4B;        /* EXEC function */	inregs.h.al = 0x03;        /* load only */        /* setup parameter block and name pointers */        segregs.ds = FP_SEG(&file_name);	inregs.x.dx = FP_OFF(&file_name);        segregs.es = FP_SEG(&p_block);	inregs.x.bx = FP_OFF(&p_block);        /* setup load segment -- must be normalized */	p_block.load_seg = norm_seg;	p_block.reloc_seg = p_block.load_seg;        /* call the MS-DOS loader */	errcode = intdosx(&inregs,&outregs,&segregs);        errcode = errcode;        /* check for error */	if (outregs.x.cflag) return(ERR_SUP_LDFAIL);	/* load successful */	return(OK);}/* END OF FILE */sys_get_date1,0
/***********************************************************************	MPX: The MultiProgramming eXecutive	Project to Accompany	A Practical Approach to Operating Systems	Malcolm G. Lane & James D. Mooney	Copyright 1993, P.W.S. Kent Publishing Co., Boston, MA.		File Name: mpx_supt.c	Authors: J.J. Patnesky, A. Ghosal, M. Lane, J. Mooney	Version: 2.1b	Date: 01/31/08	Purpose: Support routines for MPX-PC		Modules: all	Environment:      IBM-PC (XT, AT or PS/2)			MS-DOS 3.3 or later			TURBO-C 3.0 or TURBO-C++ 1.0 or later	Compile using the LARGE MODEL and SS NOT equal to DS.	All addresses and pointers are "far", and	CS, DS and SS are independent.	Procedures in this file:		sys_init		sys_exit		sys_set_vec		sys_req		sys_alloc_mem		sys_free_mem		sys_get_date		sys_set_date		sys_open_dir		sys_get_entry		sys_close_dir	       sys_check_program	       sys_load_program************************************************************************Change Log:	07/16/88  akg	added comments	02/25/92  jdm	full revision, UNIX version	04/14/92  jdm	Macintosh version	05/15/92  jdm	cleanup and documentation	07/14/92  jdm	update for revised specs        08/13/92  jdm 	revised IBM version; added private heap        10/14/92  jdm 	added check and load procedures        10/18/92  jdm 	revised sys_alloc_mem for alignment	11/17/92  jdm	true heap mgt, aligned, using calloc & free	11/19/92  jdm	enable device handling for final module	12/31/92  jdm	revised sys_req parameters	01/02/93  jdm	return count value after I/O	01/03/93  jdm	revised error names and codes	01/27/93  jdm	corrected count for line input in sys_req			fixed open_dir to handle null lines	02/24/93  jdm	changed sys_set_vec param to interrupt	03/08/93  jdm	corrections to sys_check & sys_load	03/20/93  jdm	stack switch in free, check, and load	04/22/93  jdm	corrected index conflict in sys_free_mem			added safety escape in alloc table search	07/28/93  jdm	conversion to large model	09/01/93  jdm	fixed allocation bug;  made date private	09/14/93  jdm	cleaned up memory allocation        09/16/93  jdm	adjusted program load for large model        09/30/93  jdm	modified for correct list of root directory	11/01/94  jdm	changed load file read to binary	09/18/95  jdm	fixed get_entry to default to current, not root	01/31/08  jdm   fixed possible overflow problem in get_entry************************************************************************/#include "mpx_supt.h"#include <stdlib.h>#include <dos.h>#include <dir.h>#include <errno.h>#include <conio.h>#include <alloc.h>#define VEC_ADDR (0x60L*4)#define MAX_ALLOC 200#define MAX_XPOS 79#define MAX_YPOS 24#define MAX_PATH_SIZE 50/*	System-dependent type definitions*/typedef unsigned char byte;typedef unsigned int word;typedef unsigned long longword;typedef byte *address;typedef struct params {	int      op_code;	int      device_id;	char     *buf_p;	int      *count_p;	} params;/*	Global variables accessed only by support routines*/	static longword vec_save;  /* saved interrupt vector */	static int mod_code;                /* module code */                                           	static struct date sys_date;        /* MPX system date */	/* data structures for directory access */        static char current_path[MAX_PATH_SIZE+1];        static int num_entries;        static struct ffblk file_block;        /* handler presence flags */	static flag sysc_hand;	static flag trm_hand;	static flag prt_hand;	static flag com_hand;        /* memory allocation table */	static struct {		void* original;		void* aligned;	} alloc_table[MAX_ALLOC];	static int alloc_ix;                /* current index */	static int num_alloc;               /* no. of allocated blocks *//*	Procedure: sys_init	Purpose: initialize mpx	Parameters: see prototype  	Return value: error code, or OK if no error	Calls: getdate    	Globals: mod_code		vec_save		sys_date		alloc_table, alloc_ix, num_alloc		sysc_hand, term_hand, prt_hand, com_hand	Errors: none*/int sys_init (    int      modules  /* module code */	     ){	mod_code = modules;        vec_save = 0L;        /* no handlers detected yet */	sysc_hand = FALSE;	trm_hand = FALSE;	prt_hand = FALSE;	com_hand = FALSE;	/* initialize allocation table */	for (alloc_ix=0; alloc_ix < MAX_ALLOC; alloc_ix++) {		alloc_table[alloc_ix].original = NULL;		alloc_table[alloc_ix].aligned = NULL;	}	alloc_ix = 0;	num_alloc = 0;	/* if we have reached Module R3, enable system call handling */	if (modules >= MODULE_R3) sysc_hand = TRUE;	/* if we have reached the final module, enable device handlers */	if (modules >= MODULE_F) {		trm_hand = TRUE;		prt_hand = TRUE;		com_hand = TRUE;	}	/* get system date */        getdate(&sys_date);	return (OK);}/*	Procedure: sys_exit	Purpose: terminate mpx	Parameters: none  	Return value: none	Calls: none       	Globals: vec_save*/void sys_exit(void){	longword *vec_p;	/* if trap vector changed, restore it */	if (vec_save != 0L) {		vec_p = (longword*) VEC_ADDR;		*vec_p = vec_save;	}	/* return to host with null error code */	exit(0);}/*	Procedure: sys_set_vec	Purpose: link trap vector to MPX system call handler	Parameters: handler: addr of handler         	Return value: error code; OK if no error	Calls: none       	Globals: vec_save	Errors: none*/int sys_set_vec   ( void interrupt (*handler)() /* system call handler */		){	longword *vec_p;			vec_p = (longword*) VEC_ADDR;		vec_save = *vec_p;		*vec_p = (longword) handler;	return (0);}/*	Procedure: sys_req	Purpose: Request a system service	Inputs:		op_code           operation code		device_id         device identifier		buf_p             addresso f data buffer		count_p           address of size of buffer	Returns: Result or error code, depending on service		Services supported:	IDLE     null operation				READ     input from a device				WRITE    output to a device				CLEAR    clear terminal screen				GOTOXY   absolute cursor position				EXIT     terminate the caller	Calls:   fgets		strlen			Globals: none		Errors:  ERR_SUP_INVDEV    invalid device		ERR_SUP_INVOPC    invalid operation code		ERR_SUP_INVPOS    invalid character position		ERR_SUP_RDFAIL    read failed		ERR_SUP_WRFAIL    write failed	Description:	For Modules R1 through R4,	this procedure is used only for terminal I/O.	Later modules support both reading and	writing for several devices.	For Modules R1 through R4,	sys_req uses the ANSI C function "fgets."	Later modules may use alternate functions and device drivers.*/int sys_req (   int      op_code, /* operation code */		int      device_id,        /* device id */		char*    buf_p,            /* I/O buffer */		int*     count_p           /* address of count */		){	int      rval;    /* result or error code */	char     *rp;     /* return pointer for fgets */	char     rc;      /* return char for fputc */        params    *param_p; /* pointer to parameter record in stack */	flag     docall;  /* true if system call interrupt wanted */	int      ix;      /* temporary index */	docall = FALSE;	rval = OK;	switch (op_code) {		case IDLE:		if (sysc_hand) docall = TRUE;		break; 				case READ:		switch (device_id) {				case TERMINAL:			if (trm_hand) docall = TRUE;			else {				rp = fgets(buf_p,*count_p,stdin);				if (rp==NULL) rval = ERR_SUP_RDFAIL;				else rval = strlen(buf_p);			}			break;					case COM_PORT:			if (com_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					default:			rval = ERR_SUP_INVDEV;					}		break;	case WRITE:		switch (device_id) {				case TERMINAL:			if (trm_hand) docall = TRUE;			else {				rval = *count_p;				for (ix=0; ix<*count_p; ix++) {					rc = fputc(buf_p[ix],stdout);					if (rc == EOF) {						rval = ERR_SUP_WRFAIL;						break;					}				}			}			break;					case COM_PORT:			if (com_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					case PRINTER:			if (prt_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					default:			rval = ERR_SUP_INVDEV;					}		break;	case CLEAR:		if (device_id==TERMINAL) {			if (trm_hand) docall = TRUE;			else {			     clrscr();				rval = 0;			}		}		else rval = ERR_SUP_INVDEV;		break;			case GOTOXY:		if (device_id==TERMINAL) {			if (trm_hand) docall = TRUE;			else {				if (*count_p != 2) rval = ERR_SUP_WRFAIL;				else if ((*buf_p<0)					|| (*buf_p > MAX_XPOS))					rval = ERR_SUP_WRFAIL;				else if ((*(buf_p+1)<0)					|| (*(buf_p+1) > MAX_YPOS))					rval = ERR_SUP_WRFAIL;				else {					gotoxy(*buf_p + 1,						*(buf_p+1) + 1);					rval = 0;				}			}		}		else rval = ERR_SUP_INVDEV;		break;			/* EXIT - terminate the calling process */	/* legal only when a system call handler is present */	case EXIT:		if (sysc_hand) docall = TRUE;		else rval = ERR_SUP_INVOPC;		break; 	default:		rval = ERR_SUP_INVOPC;			}		/* Invoke user's call handler if present.	   If the call is an IO request, return will occur	   only after the request is complete.	*/	if (docall && (rval==OK)) {		/* invoke the call handler */	_SP = _SP - sizeof(params);		param_p = (params*) MK_FP(_SS,_SP);	       param_p->op_code = op_code;	       param_p->device_id = device_id;	       param_p->buf_p = buf_p;	       param_p->count_p = count_p;	       geninterrupt(0x60);	       rval = _AX;	       _SP = _SP + sizeof(params);		/* for I/O operations, return count value */		switch(op_code) {		case READ:		case WRITE:		case CLEAR:		case GOTOXY:			rval = *count_p;		}	}	return(rval);}/*	Procedure: sys_alloc_mem	Purpose: Allocate a memory block	Parameters:			size_t size       No. of bytes to allocate	Returns: void* pointer to allocated block;		 null pointer in case of error		 	Calls: calloc		Globals: alloc_table, alloc_ix, num_alloc	For program loading (Module R-4), the blocks must be aligned.	This is achieved by requesting one extra paragraph and	returning the lowest aligned address as the base.  It is	necessary to keep a table of allocated address, original and	aligned, to support correct freeing.	It would seem simpler to use the Turbo-C function allocmem,	which always allocates aligned blocks.  However, allocmem	appears to conflict with the internal allocation of fopen	and other C library routines.*/void *sys_alloc_mem (      size_t   size     /* size in bytes to allocate */		    ){	int ix_save;      /* temp copy of table index */        void *addr;        /* addr returned by calloc (*void) */	word offset;      /* offset of unaligned address */	word seg;         /* segment addr of unaligned address */	void *addr_alig; /* aligned address */	int rem; /* temp for alignment computation */	/* ensure that allocation table is not full */	if (num_alloc >= MAX_ALLOC) {		return(NULL);	}	/* find free entry in allocation table */	ix_save = alloc_ix;	while (alloc_table[alloc_ix].original != NULL) {		alloc_ix++;		if (alloc_ix >= MAX_ALLOC) alloc_ix = 0;		/* safety check -- should never happen! */		if (alloc_ix == ix_save) return(NULL);	}	/* call allocation routine */	/* request 15 extra bytes to ensure alignment is possible */	addr = calloc(size + 15,1);	/* compute aligned base */	offset = FP_OFF(addr);        seg = FP_SEG(addr);	rem = offset % 16;	if (rem > 0) offset = offset + 16 - rem;	addr_alig = MK_FP(seg,offset);	/* insert entries in table */	alloc_table[alloc_ix].original = addr;	alloc_table[alloc_ix].aligned = addr_alig;	/* increment count */	num_alloc++;	return(addr_alig);}/*	Procedure: sys_free_mem	Purpose: free a memory block	Parameters:		void *ptr         ptr to block to allocate	Returns: integer error code; zero if OK		Calls:   free	Globals: alloc_table, num_alloc	Errors:  ERR_SUP_INVMEM    invalid memory block	This procedure receives an aligned address; it must	find and free the corresponding non-aligned one.*/int sys_free_mem (         void     *ptr     /* pointer to block */		 ){	void *free_addr;  /* true (unaligned) block address */	int free_ix;               /* temp table index */	/* ensure valid pointer */	if (ptr==NULL) return(ERR_SUP_INVMEM);	/* Look for the block in the allocation table */	free_addr = NULL;	for (free_ix=0; free_ix<MAX_ALLOC; free_ix++) {		if (alloc_table[free_ix].aligned == ptr) {			free_addr = alloc_table[free_ix].original;			break;		}	}	/* If the block wasn't found, report error */	if (free_addr == NULL) return(ERR_SUP_INVMEM);	/* free the block & clear the table entry */	alloc_table[free_ix].original = NULL;	alloc_table[free_ix].aligned = NULL;        free(free_addr);	/* decrement count */	num_alloc--;	return(OK);}        /*	Procedure: sys_get_date	Purpose: Returns the system date (month, day, year)	Parameters:		date_rec *date_p Pointer to structure of type date	Returns: void		Calls: none		Globals: sys_date        Errors: none*/void sys_get_date (  date_rec*      date_p   /* ptr to date record */		){	date_p->month = sys_date.da_mon;	date_p->day = sys_date.da_day;	date_p->year = sys_date.da_year;}/*	Procedure: sys_set_date	Purpose: Sets the system date (month, day, year)	Parameters:		date_rec *date_p ptr to structure of type date	Returns: error code; OK if no error	Calls:   none        Globals: sys_date	Errors: none*/int sys_set_date (  date_rec*       date_p   /* ptr to date record */		 ){	sys_date.da_mon = date_p->month;        sys_date.da_day = date_p->day;        sys_date.da_year = date_p->year;	return(OK);}/*	Procedure: sys_open_dir	Purpose: open a specified directory	Parameters: char dir_name[]            directory name	Returns: error code; zero if OK	Calls:   findfirst		strncpy  	Globals: current_path, file_block, num_entries	Errors:  ERR_SUP_DIROPN    directory open error		ERR_SUP_INVDIR    invalid directory*/int sys_open_dir (  char  path_name[]        /* directory name */		 ){        char temp_path[MAX_PATH_SIZE];	int res;        int len;        /* ensure there is no directory currently open */	if (current_path[0]!=NULCH) return(ERR_SUP_DIROPN);        /* check pathname for validity */        /* construct temporary search path name */	temp_path[0] = NULCH;	if (path_name != NULL) {		strncpy(temp_path,path_name,MAX_PATH_SIZE-4);	}	/* build wildcard search string */        len = strlen(temp_path);	/* if path is null, use current directory */        if (len==0) strcpy(temp_path,"*.*");	/* handle paths ending in backslash, including root */        else if (temp_path[len-1]=='\\') strcat(temp_path,"*.*");	/* handle paths not ending in backslash */        else strcat(temp_path,"\\*.*");	/* validate the directory by searching for either an ordinary	   file or a directory in it.  This should never fail; even	   empty directories contain the directories "." and ".."	*/		res = findfirst(temp_path, &file_block, FA_DIREC);	if (res!=0)  return(ERR_SUP_INVDIR);        /* save pathname as current, clear entry count */	current_path[0] = NULCH;	if (path_name != NULL) {		strncpy(current_path,path_name,MAX_PATH_SIZE-6);	}	num_entries = 0;	return(OK);}/*	Procedure: sys_get_entry	Purpose: get the next directory entry;	Parameters: char name_buf[]	name buffer		    int buf_size  	buffer capacity		    long *file_size_p	file length buffer         	Returns: error code, or zero if ok	Calls:	findfirst		findnext		strncpy, strcpy, strrchr, strcat    	Globals: current_path, num_entries, file_block	Errors:  ERR_SUP_NOENTR    no such entry*/int sys_get_entry (char    name_buf[],       /* buffer for entry */		   int   buf_size,         /* buffer size */		   long* file_size_p       /* buffer for size value */		  ){	char filename[MAX_PATH_SIZE+1];	int err;        int len;        char *cp;        /* find next MPX file entry, if any */        /* if this is the first call */	if (num_entries==0) {	       /* construct complete search path name */	       len = strlen(current_path);	       if (len==0) strcpy(current_path,"*.MPX");	       else if (current_path[len-1]=='\\') strcat(current_path,"*.MPX");	       else strcat(current_path,"\\*.MPX");	       /* find first entry */		err = findfirst (current_path,&file_block,0);        }        /* otherwise, find next entry */        else err = findnext(&file_block);        if (err<0) return(ERR_SUP_NOENTR);		/* ensure buf_size is not too large */		if (buf_size > MAX_PATH_SIZE) buf_size = MAX_PATH_SIZE;		      /* copy filename to buffer */	filename[buf_size] = NULCH;	strncpy (filename,file_block.ff_name,			 (size_t) buf_size);	/* remove ".MPX" from name */	cp = strrchr(filename, (int) '.');        *cp = NULCH;	/* copy name and size to caller's buffer */        strcpy (name_buf,filename);	*file_size_p = file_block.ff_fsize;        /* count entry */	num_entries++;	return(OK);}/*	Procedure: sys_close_dir	Purpose: close an open directory	Parameters: none	Returns: error code; zero if OK	Calls:   none	Globals: current_path	Errors:  none*/int sys_close_dir (void){	current_path[0] = NULCH;	return(OK);}/*	Procedure: sys_check_program	Purpose: locate and measure a program file	Parameters: see prototype	Returns: program size or error code	Calls:   strlen, strcat		fopen, fread	Globals: none	Errors:  ERR_SUP_NAMLNG    pathname too long		ERR_SUP_FILNFD    file not found		ERR_SUP_FILINV    file invalid*/#define HEADER_SIZE 32int sys_check_program(     char     dir_name[],       /* directory name */			char     prog_name[],      /* program name */			int*     prog_len_p,       /* ptr to prog length */			int*     start_offset_p    /* ptr to start offset */			){        /* buffer for full pathname */	char file_name[MAX_PATH_SIZE+1];        /* buffer for file header */        byte header[HEADER_SIZE];	FILE *file_p;     /* file pointer for C file routines */        int num_read;      /* number of header bytes read */	int file_size;    /* size of complete file */        int header_size;/* size of header */        int code_size;     /* size of program code */        int data_size;     /* size of program data */        int errcode;       /* error code */        /* ensure that path name is not too long */        if ((strlen(dir_name) + strlen(prog_name) + 5)		 > MAX_PATH_SIZE) return(ERR_SUP_NAMLNG);	/* construct path name */	file_name[0] = NULCH;	if (dir_name[0] != NULCH) {		strcat(file_name, dir_name);	        strcat(file_name, "\\");	}        strcat(file_name, prog_name);	strcat(file_name, ".MPX");        /* try to open the file */	errcode = OK;        file_p = fopen(file_name, "rb");        if (file_p == NULL) return(ERR_SUP_FILNFD);	/* read the header, check for EXE signature */        num_read = fread( (void*) header, 1, HEADER_SIZE, file_p);        if (num_read != HEADER_SIZE) {		errcode = ERR_SUP_FILINV;	}        else if ((header[0] != 0x4D) || (header[1] != 0x5A)) {		errcode = ERR_SUP_FILINV;	}        /* close the file, then return if error occurred */        fclose(file_p);	if (errcode!=OK) return(errcode);        /* compute allocation size needed */        file_size = (header[5]*256 + header[4] -1) * 512		+ (header[3]*256 + header[2]);        header_size =(header[9]*256 + header[8])*16;        code_size = file_size - header_size;        data_size = (header[11]*256 + header[10])*16;        /* return total length and starting offset */        *prog_len_p = code_size + data_size;	*start_offset_p = (header[23]*256 + header[22]) * 16;	return(OK);}/*	Procedure: sys_load_program	Purpose: load a program file	Parameters: see prototype	Returns: error code; zero if OK	Calls:   intdosx		segread		strlen, strcat	Globals: none 	Errors:  ERR_SUP_NAMLNG    name too long		ERR_SUP_FILNFD    file not found	       ERR_SUP_FILINV      file invalid		ERR_SUP_PROGSZ    program too large	       ERR_SUP_LDADDR      address not aligned		ERR_SUP_LDFAIL    load failed*/int sys_load_program (     void*    load_addr,        /* address for loading */			int      max_size,         /* memory size */			char     dir_name[],       /* directory name */			char     prog_name[]       /* program name */		      ){	int errcode;      /* error code */        int prog_len;      /* program length */	int offset;       /* offset for starting */	word norm_seg;    /* normalized load address segment */        word norm_off;     /* normalized load address offset */        /* full pathname for file to be loaded */	char file_name[MAX_PATH_SIZE+1];        /* parameter block for MSDOS EXEC function */	struct {		word load_seg;    /* segment address for loading */	       word reloc_seg;     /* segment address for relocation */        }p_block;	union REGS inregs;            /* input register structure */	union REGS outregs;           /* output register structure */	struct SREGS segregs;         /* segment register structure */        /* check program, get length and offset */	errcode = sys_check_program(dir_name, prog_name,					&prog_len, &offset);        if (errcode < 0) return(errcode);        /* ensure that allocated memory is large enough */        if (max_size < prog_len) return(ERR_SUP_PROGSZ);        /* get normalized segment and offset, check alignment */	norm_seg = FP_SEG(load_addr);	norm_off = FP_OFF(load_addr);	norm_seg += norm_off / 16;        norm_off %= 16;	if (norm_off != 0) return(ERR_SUP_LDADDR);        /* ensure that path name is not too long */        if ((strlen(dir_name) + strlen(prog_name) + 5)		 > MAX_PATH_SIZE) return(ERR_SUP_NAMLNG);	/* construct path name */	file_name[0] = NULCH;	if (dir_name[0] != NULCH) {		strcat(file_name, dir_name);	        strcat(file_name, "\\");	}        strcat(file_name, prog_name);	strcat(file_name, ".MPX");        /* get current segment regs */	segread(&segregs);        /* setup function codes */	inregs.h.ah = 0x4B;        /* EXEC function */	inregs.h.al = 0x03;        /* load only */        /* setup parameter block and name pointers */        segregs.ds = FP_SEG(&file_name);	inregs.x.dx = FP_OFF(&file_name);        segregs.es = FP_SEG(&p_block);	inregs.x.bx = FP_OFF(&p_block);        /* setup load segment -- must be normalized */	p_block.load_seg = norm_seg;	p_block.reloc_seg = p_block.load_seg;        /* call the MS-DOS loader */	errcode = intdosx(&inregs,&outregs,&segregs);        errcode = errcode;        /* check for error */	if (outregs.x.cflag) return(ERR_SUP_LDFAIL);	/* load successful */	return(OK);}/* END OF FILE */sys_set_date1,0
/***********************************************************************	MPX: The MultiProgramming eXecutive	Project to Accompany	A Practical Approach to Operating Systems	Malcolm G. Lane & James D. Mooney	Copyright 1993, P.W.S. Kent Publishing Co., Boston, MA.		File Name: mpx_supt.c	Authors: J.J. Patnesky, A. Ghosal, M. Lane, J. Mooney	Version: 2.1b	Date: 01/31/08	Purpose: Support routines for MPX-PC		Modules: all	Environment:      IBM-PC (XT, AT or PS/2)			MS-DOS 3.3 or later			TURBO-C 3.0 or TURBO-C++ 1.0 or later	Compile using the LARGE MODEL and SS NOT equal to DS.	All addresses and pointers are "far", and	CS, DS and SS are independent.	Procedures in this file:		sys_init		sys_exit		sys_set_vec		sys_req		sys_alloc_mem		sys_free_mem		sys_get_date		sys_set_date		sys_open_dir		sys_get_entry		sys_close_dir	       sys_check_program	       sys_load_program************************************************************************Change Log:	07/16/88  akg	added comments	02/25/92  jdm	full revision, UNIX version	04/14/92  jdm	Macintosh version	05/15/92  jdm	cleanup and documentation	07/14/92  jdm	update for revised specs        08/13/92  jdm 	revised IBM version; added private heap        10/14/92  jdm 	added check and load procedures        10/18/92  jdm 	revised sys_alloc_mem for alignment	11/17/92  jdm	true heap mgt, aligned, using calloc & free	11/19/92  jdm	enable device handling for final module	12/31/92  jdm	revised sys_req parameters	01/02/93  jdm	return count value after I/O	01/03/93  jdm	revised error names and codes	01/27/93  jdm	corrected count for line input in sys_req			fixed open_dir to handle null lines	02/24/93  jdm	changed sys_set_vec param to interrupt	03/08/93  jdm	corrections to sys_check & sys_load	03/20/93  jdm	stack switch in free, check, and load	04/22/93  jdm	corrected index conflict in sys_free_mem			added safety escape in alloc table search	07/28/93  jdm	conversion to large model	09/01/93  jdm	fixed allocation bug;  made date private	09/14/93  jdm	cleaned up memory allocation        09/16/93  jdm	adjusted program load for large model        09/30/93  jdm	modified for correct list of root directory	11/01/94  jdm	changed load file read to binary	09/18/95  jdm	fixed get_entry to default to current, not root	01/31/08  jdm   fixed possible overflow problem in get_entry************************************************************************/#include "mpx_supt.h"#include <stdlib.h>#include <dos.h>#include <dir.h>#include <errno.h>#include <conio.h>#include <alloc.h>#define VEC_ADDR (0x60L*4)#define MAX_ALLOC 200#define MAX_XPOS 79#define MAX_YPOS 24#define MAX_PATH_SIZE 50/*	System-dependent type definitions*/typedef unsigned char byte;typedef unsigned int word;typedef unsigned long longword;typedef byte *address;typedef struct params {	int      op_code;	int      device_id;	char     *buf_p;	int      *count_p;	} params;/*	Global variables accessed only by support routines*/	static longword vec_save;  /* saved interrupt vector */	static int mod_code;                /* module code */                                           	static struct date sys_date;        /* MPX system date */	/* data structures for directory access */        static char current_path[MAX_PATH_SIZE+1];        static int num_entries;        static struct ffblk file_block;        /* handler presence flags */	static flag sysc_hand;	static flag trm_hand;	static flag prt_hand;	static flag com_hand;        /* memory allocation table */	static struct {		void* original;		void* aligned;	} alloc_table[MAX_ALLOC];	static int alloc_ix;                /* current index */	static int num_alloc;               /* no. of allocated blocks *//*	Procedure: sys_init	Purpose: initialize mpx	Parameters: see prototype  	Return value: error code, or OK if no error	Calls: getdate    	Globals: mod_code		vec_save		sys_date		alloc_table, alloc_ix, num_alloc		sysc_hand, term_hand, prt_hand, com_hand	Errors: none*/int sys_init (    int      modules  /* module code */	     ){	mod_code = modules;        vec_save = 0L;        /* no handlers detected yet */	sysc_hand = FALSE;	trm_hand = FALSE;	prt_hand = FALSE;	com_hand = FALSE;	/* initialize allocation table */	for (alloc_ix=0; alloc_ix < MAX_ALLOC; alloc_ix++) {		alloc_table[alloc_ix].original = NULL;		alloc_table[alloc_ix].aligned = NULL;	}	alloc_ix = 0;	num_alloc = 0;	/* if we have reached Module R3, enable system call handling */	if (modules >= MODULE_R3) sysc_hand = TRUE;	/* if we have reached the final module, enable device handlers */	if (modules >= MODULE_F) {		trm_hand = TRUE;		prt_hand = TRUE;		com_hand = TRUE;	}	/* get system date */        getdate(&sys_date);	return (OK);}/*	Procedure: sys_exit	Purpose: terminate mpx	Parameters: none  	Return value: none	Calls: none       	Globals: vec_save*/void sys_exit(void){	longword *vec_p;	/* if trap vector changed, restore it */	if (vec_save != 0L) {		vec_p = (longword*) VEC_ADDR;		*vec_p = vec_save;	}	/* return to host with null error code */	exit(0);}/*	Procedure: sys_set_vec	Purpose: link trap vector to MPX system call handler	Parameters: handler: addr of handler         	Return value: error code; OK if no error	Calls: none       	Globals: vec_save	Errors: none*/int sys_set_vec   ( void interrupt (*handler)() /* system call handler */		){	longword *vec_p;			vec_p = (longword*) VEC_ADDR;		vec_save = *vec_p;		*vec_p = (longword) handler;	return (0);}/*	Procedure: sys_req	Purpose: Request a system service	Inputs:		op_code           operation code		device_id         device identifier		buf_p             addresso f data buffer		count_p           address of size of buffer	Returns: Result or error code, depending on service		Services supported:	IDLE     null operation				READ     input from a device				WRITE    output to a device				CLEAR    clear terminal screen				GOTOXY   absolute cursor position				EXIT     terminate the caller	Calls:   fgets		strlen			Globals: none		Errors:  ERR_SUP_INVDEV    invalid device		ERR_SUP_INVOPC    invalid operation code		ERR_SUP_INVPOS    invalid character position		ERR_SUP_RDFAIL    read failed		ERR_SUP_WRFAIL    write failed	Description:	For Modules R1 through R4,	this procedure is used only for terminal I/O.	Later modules support both reading and	writing for several devices.	For Modules R1 through R4,	sys_req uses the ANSI C function "fgets."	Later modules may use alternate functions and device drivers.*/int sys_req (   int      op_code, /* operation code */		int      device_id,        /* device id */		char*    buf_p,            /* I/O buffer */		int*     count_p           /* address of count */		){	int      rval;    /* result or error code */	char     *rp;     /* return pointer for fgets */	char     rc;      /* return char for fputc */        params    *param_p; /* pointer to parameter record in stack */	flag     docall;  /* true if system call interrupt wanted */	int      ix;      /* temporary index */	docall = FALSE;	rval = OK;	switch (op_code) {		case IDLE:		if (sysc_hand) docall = TRUE;		break; 				case READ:		switch (device_id) {				case TERMINAL:			if (trm_hand) docall = TRUE;			else {				rp = fgets(buf_p,*count_p,stdin);				if (rp==NULL) rval = ERR_SUP_RDFAIL;				else rval = strlen(buf_p);			}			break;					case COM_PORT:			if (com_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					default:			rval = ERR_SUP_INVDEV;					}		break;	case WRITE:		switch (device_id) {				case TERMINAL:			if (trm_hand) docall = TRUE;			else {				rval = *count_p;				for (ix=0; ix<*count_p; ix++) {					rc = fputc(buf_p[ix],stdout);					if (rc == EOF) {						rval = ERR_SUP_WRFAIL;						break;					}				}			}			break;					case COM_PORT:			if (com_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					case PRINTER:			if (prt_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					default:			rval = ERR_SUP_INVDEV;					}		break;	case CLEAR:		if (device_id==TERMINAL) {			if (trm_hand) docall = TRUE;			else {			     clrscr();				rval = 0;			}		}		else rval = ERR_SUP_INVDEV;		break;			case GOTOXY:		if (device_id==TERMINAL) {			if (trm_hand) docall = TRUE;			else {				if (*count_p != 2) rval = ERR_SUP_WRFAIL;				else if ((*buf_p<0)					|| (*buf_p > MAX_XPOS))					rval = ERR_SUP_WRFAIL;				else if ((*(buf_p+1)<0)					|| (*(buf_p+1) > MAX_YPOS))					rval = ERR_SUP_WRFAIL;				else {					gotoxy(*buf_p + 1,						*(buf_p+1) + 1);					rval = 0;				}			}		}		else rval = ERR_SUP_INVDEV;		break;			/* EXIT - terminate the calling process */	/* legal only when a system call handler is present */	case EXIT:		if (sysc_hand) docall = TRUE;		else rval = ERR_SUP_INVOPC;		break; 	default:		rval = ERR_SUP_INVOPC;			}		/* Invoke user's call handler if present.	   If the call is an IO request, return will occur	   only after the request is complete.	*/	if (docall && (rval==OK)) {		/* invoke the call handler */	_SP = _SP - sizeof(params);		param_p = (params*) MK_FP(_SS,_SP);	       param_p->op_code = op_code;	       param_p->device_id = device_id;	       param_p->buf_p = buf_p;	       param_p->count_p = count_p;	       geninterrupt(0x60);	       rval = _AX;	       _SP = _SP + sizeof(params);		/* for I/O operations, return count value */		switch(op_code) {		case READ:		case WRITE:		case CLEAR:		case GOTOXY:			rval = *count_p;		}	}	return(rval);}/*	Procedure: sys_alloc_mem	Purpose: Allocate a memory block	Parameters:			size_t size       No. of bytes to allocate	Returns: void* pointer to allocated block;		 null pointer in case of error		 	Calls: calloc		Globals: alloc_table, alloc_ix, num_alloc	For program loading (Module R-4), the blocks must be aligned.	This is achieved by requesting one extra paragraph and	returning the lowest aligned address as the base.  It is	necessary to keep a table of allocated address, original and	aligned, to support correct freeing.	It would seem simpler to use the Turbo-C function allocmem,	which always allocates aligned blocks.  However, allocmem	appears to conflict with the internal allocation of fopen	and other C library routines.*/void *sys_alloc_mem (      size_t   size     /* size in bytes to allocate */		    ){	int ix_save;      /* temp copy of table index */        void *addr;        /* addr returned by calloc (*void) */	word offset;      /* offset of unaligned address */	word seg;         /* segment addr of unaligned address */	void *addr_alig; /* aligned address */	int rem; /* temp for alignment computation */	/* ensure that allocation table is not full */	if (num_alloc >= MAX_ALLOC) {		return(NULL);	}	/* find free entry in allocation table */	ix_save = alloc_ix;	while (alloc_table[alloc_ix].original != NULL) {		alloc_ix++;		if (alloc_ix >= MAX_ALLOC) alloc_ix = 0;		/* safety check -- should never happen! */		if (alloc_ix == ix_save) return(NULL);	}	/* call allocation routine */	/* request 15 extra bytes to ensure alignment is possible */	addr = calloc(size + 15,1);	/* compute aligned base */	offset = FP_OFF(addr);        seg = FP_SEG(addr);	rem = offset % 16;	if (rem > 0) offset = offset + 16 - rem;	addr_alig = MK_FP(seg,offset);	/* insert entries in table */	alloc_table[alloc_ix].original = addr;	alloc_table[alloc_ix].aligned = addr_alig;	/* increment count */	num_alloc++;	return(addr_alig);}/*	Procedure: sys_free_mem	Purpose: free a memory block	Parameters:		void *ptr         ptr to block to allocate	Returns: integer error code; zero if OK		Calls:   free	Globals: alloc_table, num_alloc	Errors:  ERR_SUP_INVMEM    invalid memory block	This procedure receives an aligned address; it must	find and free the corresponding non-aligned one.*/int sys_free_mem (         void     *ptr     /* pointer to block */		 ){	void *free_addr;  /* true (unaligned) block address */	int free_ix;               /* temp table index */	/* ensure valid pointer */	if (ptr==NULL) return(ERR_SUP_INVMEM);	/* Look for the block in the allocation table */	free_addr = NULL;	for (free_ix=0; free_ix<MAX_ALLOC; free_ix++) {		if (alloc_table[free_ix].aligned == ptr) {			free_addr = alloc_table[free_ix].original;			break;		}	}	/* If the block wasn't found, report error */	if (free_addr == NULL) return(ERR_SUP_INVMEM);	/* free the block & clear the table entry */	alloc_table[free_ix].original = NULL;	alloc_table[free_ix].aligned = NULL;        free(free_addr);	/* decrement count */	num_alloc--;	return(OK);}        /*	Procedure: sys_get_date	Purpose: Returns the system date (month, day, year)	Parameters:		date_rec *date_p Pointer to structure of type date	Returns: void		Calls: none		Globals: sys_date        Errors: none*/void sys_get_date (  date_rec*      date_p   /* ptr to date record */		){	date_p->month = sys_date.da_mon;	date_p->day = sys_date.da_day;	date_p->year = sys_date.da_year;}/*	Procedure: sys_set_date	Purpose: Sets the system date (month, day, year)	Parameters:		date_rec *date_p ptr to structure of type date	Returns: error code; OK if no error	Calls:   none        Globals: sys_date	Errors: none*/int sys_set_date (  date_rec*       date_p   /* ptr to date record */		 ){	sys_date.da_mon = date_p->month;        sys_date.da_day = date_p->day;        sys_date.da_year = date_p->year;	return(OK);}/*	Procedure: sys_open_dir	Purpose: open a specified directory	Parameters: char dir_name[]            directory name	Returns: error code; zero if OK	Calls:   findfirst		strncpy  	Globals: current_path, file_block, num_entries	Errors:  ERR_SUP_DIROPN    directory open error		ERR_SUP_INVDIR    invalid directory*/int sys_open_dir (  char  path_name[]        /* directory name */		 ){        char temp_path[MAX_PATH_SIZE];	int res;        int len;        /* ensure there is no directory currently open */	if (current_path[0]!=NULCH) return(ERR_SUP_DIROPN);        /* check pathname for validity */        /* construct temporary search path name */	temp_path[0] = NULCH;	if (path_name != NULL) {		strncpy(temp_path,path_name,MAX_PATH_SIZE-4);	}	/* build wildcard search string */        len = strlen(temp_path);	/* if path is null, use current directory */        if (len==0) strcpy(temp_path,"*.*");	/* handle paths ending in backslash, including root */        else if (temp_path[len-1]=='\\') strcat(temp_path,"*.*");	/* handle paths not ending in backslash */        else strcat(temp_path,"\\*.*");	/* validate the directory by searching for either an ordinary	   file or a directory in it.  This should never fail; even	   empty directories contain the directories "." and ".."	*/		res = findfirst(temp_path, &file_block, FA_DIREC);	if (res!=0)  return(ERR_SUP_INVDIR);        /* save pathname as current, clear entry count */	current_path[0] = NULCH;	if (path_name != NULL) {		strncpy(current_path,path_name,MAX_PATH_SIZE-6);	}	num_entries = 0;	return(OK);}/*	Procedure: sys_get_entry	Purpose: get the next directory entry;	Parameters: char name_buf[]	name buffer		    int buf_size  	buffer capacity		    long *file_size_p	file length buffer         	Returns: error code, or zero if ok	Calls:	findfirst		findnext		strncpy, strcpy, strrchr, strcat    	Globals: current_path, num_entries, file_block	Errors:  ERR_SUP_NOENTR    no such entry*/int sys_get_entry (char    name_buf[],       /* buffer for entry */		   int   buf_size,         /* buffer size */		   long* file_size_p       /* buffer for size value */		  ){	char filename[MAX_PATH_SIZE+1];	int err;        int len;        char *cp;        /* find next MPX file entry, if any */        /* if this is the first call */	if (num_entries==0) {	       /* construct complete search path name */	       len = strlen(current_path);	       if (len==0) strcpy(current_path,"*.MPX");	       else if (current_path[len-1]=='\\') strcat(current_path,"*.MPX");	       else strcat(current_path,"\\*.MPX");	       /* find first entry */		err = findfirst (current_path,&file_block,0);        }        /* otherwise, find next entry */        else err = findnext(&file_block);        if (err<0) return(ERR_SUP_NOENTR);		/* ensure buf_size is not too large */		if (buf_size > MAX_PATH_SIZE) buf_size = MAX_PATH_SIZE;		      /* copy filename to buffer */	filename[buf_size] = NULCH;	strncpy (filename,file_block.ff_name,			 (size_t) buf_size);	/* remove ".MPX" from name */	cp = strrchr(filename, (int) '.');        *cp = NULCH;	/* copy name and size to caller's buffer */        strcpy (name_buf,filename);	*file_size_p = file_block.ff_fsize;        /* count entry */	num_entries++;	return(OK);}/*	Procedure: sys_close_dir	Purpose: close an open directory	Parameters: none	Returns: error code; zero if OK	Calls:   none	Globals: current_path	Errors:  none*/int sys_close_dir (void){	current_path[0] = NULCH;	return(OK);}/*	Procedure: sys_check_program	Purpose: locate and measure a program file	Parameters: see prototype	Returns: program size or error code	Calls:   strlen, strcat		fopen, fread	Globals: none	Errors:  ERR_SUP_NAMLNG    pathname too long		ERR_SUP_FILNFD    file not found		ERR_SUP_FILINV    file invalid*/#define HEADER_SIZE 32int sys_check_program(     char     dir_name[],       /* directory name */			char     prog_name[],      /* program name */			int*     prog_len_p,       /* ptr to prog length */			int*     start_offset_p    /* ptr to start offset */			){        /* buffer for full pathname */	char file_name[MAX_PATH_SIZE+1];        /* buffer for file header */        byte header[HEADER_SIZE];	FILE *file_p;     /* file pointer for C file routines */        int num_read;      /* number of header bytes read */	int file_size;    /* size of complete file */        int header_size;/* size of header */        int code_size;     /* size of program code */        int data_size;     /* size of program data */        int errcode;       /* error code */        /* ensure that path name is not too long */        if ((strlen(dir_name) + strlen(prog_name) + 5)		 > MAX_PATH_SIZE) return(ERR_SUP_NAMLNG);	/* construct path name */	file_name[0] = NULCH;	if (dir_name[0] != NULCH) {		strcat(file_name, dir_name);	        strcat(file_name, "\\");	}        strcat(file_name, prog_name);	strcat(file_name, ".MPX");        /* try to open the file */	errcode = OK;        file_p = fopen(file_name, "rb");        if (file_p == NULL) return(ERR_SUP_FILNFD);	/* read the header, check for EXE signature */        num_read = fread( (void*) header, 1, HEADER_SIZE, file_p);        if (num_read != HEADER_SIZE) {		errcode = ERR_SUP_FILINV;	}        else if ((header[0] != 0x4D) || (header[1] != 0x5A)) {		errcode = ERR_SUP_FILINV;	}        /* close the file, then return if error occurred */        fclose(file_p);	if (errcode!=OK) return(errcode);        /* compute allocation size needed */        file_size = (header[5]*256 + header[4] -1) * 512		+ (header[3]*256 + header[2]);        header_size =(header[9]*256 + header[8])*16;        code_size = file_size - header_size;        data_size = (header[11]*256 + header[10])*16;        /* return total length and starting offset */        *prog_len_p = code_size + data_size;	*start_offset_p = (header[23]*256 + header[22]) * 16;	return(OK);}/*	Procedure: sys_load_program	Purpose: load a program file	Parameters: see prototype	Returns: error code; zero if OK	Calls:   intdosx		segread		strlen, strcat	Globals: none 	Errors:  ERR_SUP_NAMLNG    name too long		ERR_SUP_FILNFD    file not found	       ERR_SUP_FILINV      file invalid		ERR_SUP_PROGSZ    program too large	       ERR_SUP_LDADDR      address not aligned		ERR_SUP_LDFAIL    load failed*/int sys_load_program (     void*    load_addr,        /* address for loading */			int      max_size,         /* memory size */			char     dir_name[],       /* directory name */			char     prog_name[]       /* program name */		      ){	int errcode;      /* error code */        int prog_len;      /* program length */	int offset;       /* offset for starting */	word norm_seg;    /* normalized load address segment */        word norm_off;     /* normalized load address offset */        /* full pathname for file to be loaded */	char file_name[MAX_PATH_SIZE+1];        /* parameter block for MSDOS EXEC function */	struct {		word load_seg;    /* segment address for loading */	       word reloc_seg;     /* segment address for relocation */        }p_block;	union REGS inregs;            /* input register structure */	union REGS outregs;           /* output register structure */	struct SREGS segregs;         /* segment register structure */        /* check program, get length and offset */	errcode = sys_check_program(dir_name, prog_name,					&prog_len, &offset);        if (errcode < 0) return(errcode);        /* ensure that allocated memory is large enough */        if (max_size < prog_len) return(ERR_SUP_PROGSZ);        /* get normalized segment and offset, check alignment */	norm_seg = FP_SEG(load_addr);	norm_off = FP_OFF(load_addr);	norm_seg += norm_off / 16;        norm_off %= 16;	if (norm_off != 0) return(ERR_SUP_LDADDR);        /* ensure that path name is not too long */        if ((strlen(dir_name) + strlen(prog_name) + 5)		 > MAX_PATH_SIZE) return(ERR_SUP_NAMLNG);	/* construct path name */	file_name[0] = NULCH;	if (dir_name[0] != NULCH) {		strcat(file_name, dir_name);	        strcat(file_name, "\\");	}        strcat(file_name, prog_name);	strcat(file_name, ".MPX");        /* get current segment regs */	segread(&segregs);        /* setup function codes */	inregs.h.ah = 0x4B;        /* EXEC function */	inregs.h.al = 0x03;        /* load only */        /* setup parameter block and name pointers */        segregs.ds = FP_SEG(&file_name);	inregs.x.dx = FP_OFF(&file_name);        segregs.es = FP_SEG(&p_block);	inregs.x.bx = FP_OFF(&p_block);        /* setup load segment -- must be normalized */	p_block.load_seg = norm_seg;	p_block.reloc_seg = p_block.load_seg;        /* call the MS-DOS loader */	errcode = intdosx(&inregs,&outregs,&segregs);        errcode = errcode;        /* check for error */	if (outregs.x.cflag) return(ERR_SUP_LDFAIL);	/* load successful */	return(OK);}/* END OF FILE */sys_open_dir1,0
/***********************************************************************	MPX: The MultiProgramming eXecutive	Project to Accompany	A Practical Approach to Operating Systems	Malcolm G. Lane & James D. Mooney	Copyright 1993, P.W.S. Kent Publishing Co., Boston, MA.		File Name: mpx_supt.c	Authors: J.J. Patnesky, A. Ghosal, M. Lane, J. Mooney	Version: 2.1b	Date: 01/31/08	Purpose: Support routines for MPX-PC		Modules: all	Environment:      IBM-PC (XT, AT or PS/2)			MS-DOS 3.3 or later			TURBO-C 3.0 or TURBO-C++ 1.0 or later	Compile using the LARGE MODEL and SS NOT equal to DS.	All addresses and pointers are "far", and	CS, DS and SS are independent.	Procedures in this file:		sys_init		sys_exit		sys_set_vec		sys_req		sys_alloc_mem		sys_free_mem		sys_get_date		sys_set_date		sys_open_dir		sys_get_entry		sys_close_dir	       sys_check_program	       sys_load_program************************************************************************Change Log:	07/16/88  akg	added comments	02/25/92  jdm	full revision, UNIX version	04/14/92  jdm	Macintosh version	05/15/92  jdm	cleanup and documentation	07/14/92  jdm	update for revised specs        08/13/92  jdm 	revised IBM version; added private heap        10/14/92  jdm 	added check and load procedures        10/18/92  jdm 	revised sys_alloc_mem for alignment	11/17/92  jdm	true heap mgt, aligned, using calloc & free	11/19/92  jdm	enable device handling for final module	12/31/92  jdm	revised sys_req parameters	01/02/93  jdm	return count value after I/O	01/03/93  jdm	revised error names and codes	01/27/93  jdm	corrected count for line input in sys_req			fixed open_dir to handle null lines	02/24/93  jdm	changed sys_set_vec param to interrupt	03/08/93  jdm	corrections to sys_check & sys_load	03/20/93  jdm	stack switch in free, check, and load	04/22/93  jdm	corrected index conflict in sys_free_mem			added safety escape in alloc table search	07/28/93  jdm	conversion to large model	09/01/93  jdm	fixed allocation bug;  made date private	09/14/93  jdm	cleaned up memory allocation        09/16/93  jdm	adjusted program load for large model        09/30/93  jdm	modified for correct list of root directory	11/01/94  jdm	changed load file read to binary	09/18/95  jdm	fixed get_entry to default to current, not root	01/31/08  jdm   fixed possible overflow problem in get_entry************************************************************************/#include "mpx_supt.h"#include <stdlib.h>#include <dos.h>#include <dir.h>#include <errno.h>#include <conio.h>#include <alloc.h>#define VEC_ADDR (0x60L*4)#define MAX_ALLOC 200#define MAX_XPOS 79#define MAX_YPOS 24#define MAX_PATH_SIZE 50/*	System-dependent type definitions*/typedef unsigned char byte;typedef unsigned int word;typedef unsigned long longword;typedef byte *address;typedef struct params {	int      op_code;	int      device_id;	char     *buf_p;	int      *count_p;	} params;/*	Global variables accessed only by support routines*/	static longword vec_save;  /* saved interrupt vector */	static int mod_code;                /* module code */                                           	static struct date sys_date;        /* MPX system date */	/* data structures for directory access */        static char current_path[MAX_PATH_SIZE+1];        static int num_entries;        static struct ffblk file_block;        /* handler presence flags */	static flag sysc_hand;	static flag trm_hand;	static flag prt_hand;	static flag com_hand;        /* memory allocation table */	static struct {		void* original;		void* aligned;	} alloc_table[MAX_ALLOC];	static int alloc_ix;                /* current index */	static int num_alloc;               /* no. of allocated blocks *//*	Procedure: sys_init	Purpose: initialize mpx	Parameters: see prototype  	Return value: error code, or OK if no error	Calls: getdate    	Globals: mod_code		vec_save		sys_date		alloc_table, alloc_ix, num_alloc		sysc_hand, term_hand, prt_hand, com_hand	Errors: none*/int sys_init (    int      modules  /* module code */	     ){	mod_code = modules;        vec_save = 0L;        /* no handlers detected yet */	sysc_hand = FALSE;	trm_hand = FALSE;	prt_hand = FALSE;	com_hand = FALSE;	/* initialize allocation table */	for (alloc_ix=0; alloc_ix < MAX_ALLOC; alloc_ix++) {		alloc_table[alloc_ix].original = NULL;		alloc_table[alloc_ix].aligned = NULL;	}	alloc_ix = 0;	num_alloc = 0;	/* if we have reached Module R3, enable system call handling */	if (modules >= MODULE_R3) sysc_hand = TRUE;	/* if we have reached the final module, enable device handlers */	if (modules >= MODULE_F) {		trm_hand = TRUE;		prt_hand = TRUE;		com_hand = TRUE;	}	/* get system date */        getdate(&sys_date);	return (OK);}/*	Procedure: sys_exit	Purpose: terminate mpx	Parameters: none  	Return value: none	Calls: none       	Globals: vec_save*/void sys_exit(void){	longword *vec_p;	/* if trap vector changed, restore it */	if (vec_save != 0L) {		vec_p = (longword*) VEC_ADDR;		*vec_p = vec_save;	}	/* return to host with null error code */	exit(0);}/*	Procedure: sys_set_vec	Purpose: link trap vector to MPX system call handler	Parameters: handler: addr of handler         	Return value: error code; OK if no error	Calls: none       	Globals: vec_save	Errors: none*/int sys_set_vec   ( void interrupt (*handler)() /* system call handler */		){	longword *vec_p;			vec_p = (longword*) VEC_ADDR;		vec_save = *vec_p;		*vec_p = (longword) handler;	return (0);}/*	Procedure: sys_req	Purpose: Request a system service	Inputs:		op_code           operation code		device_id         device identifier		buf_p             addresso f data buffer		count_p           address of size of buffer	Returns: Result or error code, depending on service		Services supported:	IDLE     null operation				READ     input from a device				WRITE    output to a device				CLEAR    clear terminal screen				GOTOXY   absolute cursor position				EXIT     terminate the caller	Calls:   fgets		strlen			Globals: none		Errors:  ERR_SUP_INVDEV    invalid device		ERR_SUP_INVOPC    invalid operation code		ERR_SUP_INVPOS    invalid character position		ERR_SUP_RDFAIL    read failed		ERR_SUP_WRFAIL    write failed	Description:	For Modules R1 through R4,	this procedure is used only for terminal I/O.	Later modules support both reading and	writing for several devices.	For Modules R1 through R4,	sys_req uses the ANSI C function "fgets."	Later modules may use alternate functions and device drivers.*/int sys_req (   int      op_code, /* operation code */		int      device_id,        /* device id */		char*    buf_p,            /* I/O buffer */		int*     count_p           /* address of count */		){	int      rval;    /* result or error code */	char     *rp;     /* return pointer for fgets */	char     rc;      /* return char for fputc */        params    *param_p; /* pointer to parameter record in stack */	flag     docall;  /* true if system call interrupt wanted */	int      ix;      /* temporary index */	docall = FALSE;	rval = OK;	switch (op_code) {		case IDLE:		if (sysc_hand) docall = TRUE;		break; 				case READ:		switch (device_id) {				case TERMINAL:			if (trm_hand) docall = TRUE;			else {				rp = fgets(buf_p,*count_p,stdin);				if (rp==NULL) rval = ERR_SUP_RDFAIL;				else rval = strlen(buf_p);			}			break;					case COM_PORT:			if (com_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					default:			rval = ERR_SUP_INVDEV;					}		break;	case WRITE:		switch (device_id) {				case TERMINAL:			if (trm_hand) docall = TRUE;			else {				rval = *count_p;				for (ix=0; ix<*count_p; ix++) {					rc = fputc(buf_p[ix],stdout);					if (rc == EOF) {						rval = ERR_SUP_WRFAIL;						break;					}				}			}			break;					case COM_PORT:			if (com_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					case PRINTER:			if (prt_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					default:			rval = ERR_SUP_INVDEV;					}		break;	case CLEAR:		if (device_id==TERMINAL) {			if (trm_hand) docall = TRUE;			else {			     clrscr();				rval = 0;			}		}		else rval = ERR_SUP_INVDEV;		break;			case GOTOXY:		if (device_id==TERMINAL) {			if (trm_hand) docall = TRUE;			else {				if (*count_p != 2) rval = ERR_SUP_WRFAIL;				else if ((*buf_p<0)					|| (*buf_p > MAX_XPOS))					rval = ERR_SUP_WRFAIL;				else if ((*(buf_p+1)<0)					|| (*(buf_p+1) > MAX_YPOS))					rval = ERR_SUP_WRFAIL;				else {					gotoxy(*buf_p + 1,						*(buf_p+1) + 1);					rval = 0;				}			}		}		else rval = ERR_SUP_INVDEV;		break;			/* EXIT - terminate the calling process */	/* legal only when a system call handler is present */	case EXIT:		if (sysc_hand) docall = TRUE;		else rval = ERR_SUP_INVOPC;		break; 	default:		rval = ERR_SUP_INVOPC;			}		/* Invoke user's call handler if present.	   If the call is an IO request, return will occur	   only after the request is complete.	*/	if (docall && (rval==OK)) {		/* invoke the call handler */	_SP = _SP - sizeof(params);		param_p = (params*) MK_FP(_SS,_SP);	       param_p->op_code = op_code;	       param_p->device_id = device_id;	       param_p->buf_p = buf_p;	       param_p->count_p = count_p;	       geninterrupt(0x60);	       rval = _AX;	       _SP = _SP + sizeof(params);		/* for I/O operations, return count value */		switch(op_code) {		case READ:		case WRITE:		case CLEAR:		case GOTOXY:			rval = *count_p;		}	}	return(rval);}/*	Procedure: sys_alloc_mem	Purpose: Allocate a memory block	Parameters:			size_t size       No. of bytes to allocate	Returns: void* pointer to allocated block;		 null pointer in case of error		 	Calls: calloc		Globals: alloc_table, alloc_ix, num_alloc	For program loading (Module R-4), the blocks must be aligned.	This is achieved by requesting one extra paragraph and	returning the lowest aligned address as the base.  It is	necessary to keep a table of allocated address, original and	aligned, to support correct freeing.	It would seem simpler to use the Turbo-C function allocmem,	which always allocates aligned blocks.  However, allocmem	appears to conflict with the internal allocation of fopen	and other C library routines.*/void *sys_alloc_mem (      size_t   size     /* size in bytes to allocate */		    ){	int ix_save;      /* temp copy of table index */        void *addr;        /* addr returned by calloc (*void) */	word offset;      /* offset of unaligned address */	word seg;         /* segment addr of unaligned address */	void *addr_alig; /* aligned address */	int rem; /* temp for alignment computation */	/* ensure that allocation table is not full */	if (num_alloc >= MAX_ALLOC) {		return(NULL);	}	/* find free entry in allocation table */	ix_save = alloc_ix;	while (alloc_table[alloc_ix].original != NULL) {		alloc_ix++;		if (alloc_ix >= MAX_ALLOC) alloc_ix = 0;		/* safety check -- should never happen! */		if (alloc_ix == ix_save) return(NULL);	}	/* call allocation routine */	/* request 15 extra bytes to ensure alignment is possible */	addr = calloc(size + 15,1);	/* compute aligned base */	offset = FP_OFF(addr);        seg = FP_SEG(addr);	rem = offset % 16;	if (rem > 0) offset = offset + 16 - rem;	addr_alig = MK_FP(seg,offset);	/* insert entries in table */	alloc_table[alloc_ix].original = addr;	alloc_table[alloc_ix].aligned = addr_alig;	/* increment count */	num_alloc++;	return(addr_alig);}/*	Procedure: sys_free_mem	Purpose: free a memory block	Parameters:		void *ptr         ptr to block to allocate	Returns: integer error code; zero if OK		Calls:   free	Globals: alloc_table, num_alloc	Errors:  ERR_SUP_INVMEM    invalid memory block	This procedure receives an aligned address; it must	find and free the corresponding non-aligned one.*/int sys_free_mem (         void     *ptr     /* pointer to block */		 ){	void *free_addr;  /* true (unaligned) block address */	int free_ix;               /* temp table index */	/* ensure valid pointer */	if (ptr==NULL) return(ERR_SUP_INVMEM);	/* Look for the block in the allocation table */	free_addr = NULL;	for (free_ix=0; free_ix<MAX_ALLOC; free_ix++) {		if (alloc_table[free_ix].aligned == ptr) {			free_addr = alloc_table[free_ix].original;			break;		}	}	/* If the block wasn't found, report error */	if (free_addr == NULL) return(ERR_SUP_INVMEM);	/* free the block & clear the table entry */	alloc_table[free_ix].original = NULL;	alloc_table[free_ix].aligned = NULL;        free(free_addr);	/* decrement count */	num_alloc--;	return(OK);}        /*	Procedure: sys_get_date	Purpose: Returns the system date (month, day, year)	Parameters:		date_rec *date_p Pointer to structure of type date	Returns: void		Calls: none		Globals: sys_date        Errors: none*/void sys_get_date (  date_rec*      date_p   /* ptr to date record */		){	date_p->month = sys_date.da_mon;	date_p->day = sys_date.da_day;	date_p->year = sys_date.da_year;}/*	Procedure: sys_set_date	Purpose: Sets the system date (month, day, year)	Parameters:		date_rec *date_p ptr to structure of type date	Returns: error code; OK if no error	Calls:   none        Globals: sys_date	Errors: none*/int sys_set_date (  date_rec*       date_p   /* ptr to date record */		 ){	sys_date.da_mon = date_p->month;        sys_date.da_day = date_p->day;        sys_date.da_year = date_p->year;	return(OK);}/*	Procedure: sys_open_dir	Purpose: open a specified directory	Parameters: char dir_name[]            directory name	Returns: error code; zero if OK	Calls:   findfirst		strncpy  	Globals: current_path, file_block, num_entries	Errors:  ERR_SUP_DIROPN    directory open error		ERR_SUP_INVDIR    invalid directory*/int sys_open_dir (  char  path_name[]        /* directory name */		 ){        char temp_path[MAX_PATH_SIZE];	int res;        int len;        /* ensure there is no directory currently open */	if (current_path[0]!=NULCH) return(ERR_SUP_DIROPN);        /* check pathname for validity */        /* construct temporary search path name */	temp_path[0] = NULCH;	if (path_name != NULL) {		strncpy(temp_path,path_name,MAX_PATH_SIZE-4);	}	/* build wildcard search string */        len = strlen(temp_path);	/* if path is null, use current directory */        if (len==0) strcpy(temp_path,"*.*");	/* handle paths ending in backslash, including root */        else if (temp_path[len-1]=='\\') strcat(temp_path,"*.*");	/* handle paths not ending in backslash */        else strcat(temp_path,"\\*.*");	/* validate the directory by searching for either an ordinary	   file or a directory in it.  This should never fail; even	   empty directories contain the directories "." and ".."	*/		res = findfirst(temp_path, &file_block, FA_DIREC);	if (res!=0)  return(ERR_SUP_INVDIR);        /* save pathname as current, clear entry count */	current_path[0] = NULCH;	if (path_name != NULL) {		strncpy(current_path,path_name,MAX_PATH_SIZE-6);	}	num_entries = 0;	return(OK);}/*	Procedure: sys_get_entry	Purpose: get the next directory entry;	Parameters: char name_buf[]	name buffer		    int buf_size  	buffer capacity		    long *file_size_p	file length buffer         	Returns: error code, or zero if ok	Calls:	findfirst		findnext		strncpy, strcpy, strrchr, strcat    	Globals: current_path, num_entries, file_block	Errors:  ERR_SUP_NOENTR    no such entry*/int sys_get_entry (char    name_buf[],       /* buffer for entry */		   int   buf_size,         /* buffer size */		   long* file_size_p       /* buffer for size value */		  ){	char filename[MAX_PATH_SIZE+1];	int err;        int len;        char *cp;        /* find next MPX file entry, if any */        /* if this is the first call */	if (num_entries==0) {	       /* construct complete search path name */	       len = strlen(current_path);	       if (len==0) strcpy(current_path,"*.MPX");	       else if (current_path[len-1]=='\\') strcat(current_path,"*.MPX");	       else strcat(current_path,"\\*.MPX");	       /* find first entry */		err = findfirst (current_path,&file_block,0);        }        /* otherwise, find next entry */        else err = findnext(&file_block);        if (err<0) return(ERR_SUP_NOENTR);		/* ensure buf_size is not too large */		if (buf_size > MAX_PATH_SIZE) buf_size = MAX_PATH_SIZE;		      /* copy filename to buffer */	filename[buf_size] = NULCH;	strncpy (filename,file_block.ff_name,			 (size_t) buf_size);	/* remove ".MPX" from name */	cp = strrchr(filename, (int) '.');        *cp = NULCH;	/* copy name and size to caller's buffer */        strcpy (name_buf,filename);	*file_size_p = file_block.ff_fsize;        /* count entry */	num_entries++;	return(OK);}/*	Procedure: sys_close_dir	Purpose: close an open directory	Parameters: none	Returns: error code; zero if OK	Calls:   none	Globals: current_path	Errors:  none*/int sys_close_dir (void){	current_path[0] = NULCH;	return(OK);}/*	Procedure: sys_check_program	Purpose: locate and measure a program file	Parameters: see prototype	Returns: program size or error code	Calls:   strlen, strcat		fopen, fread	Globals: none	Errors:  ERR_SUP_NAMLNG    pathname too long		ERR_SUP_FILNFD    file not found		ERR_SUP_FILINV    file invalid*/#define HEADER_SIZE 32int sys_check_program(     char     dir_name[],       /* directory name */			char     prog_name[],      /* program name */			int*     prog_len_p,       /* ptr to prog length */			int*     start_offset_p    /* ptr to start offset */			){        /* buffer for full pathname */	char file_name[MAX_PATH_SIZE+1];        /* buffer for file header */        byte header[HEADER_SIZE];	FILE *file_p;     /* file pointer for C file routines */        int num_read;      /* number of header bytes read */	int file_size;    /* size of complete file */        int header_size;/* size of header */        int code_size;     /* size of program code */        int data_size;     /* size of program data */        int errcode;       /* error code */        /* ensure that path name is not too long */        if ((strlen(dir_name) + strlen(prog_name) + 5)		 > MAX_PATH_SIZE) return(ERR_SUP_NAMLNG);	/* construct path name */	file_name[0] = NULCH;	if (dir_name[0] != NULCH) {		strcat(file_name, dir_name);	        strcat(file_name, "\\");	}        strcat(file_name, prog_name);	strcat(file_name, ".MPX");        /* try to open the file */	errcode = OK;        file_p = fopen(file_name, "rb");        if (file_p == NULL) return(ERR_SUP_FILNFD);	/* read the header, check for EXE signature */        num_read = fread( (void*) header, 1, HEADER_SIZE, file_p);        if (num_read != HEADER_SIZE) {		errcode = ERR_SUP_FILINV;	}        else if ((header[0] != 0x4D) || (header[1] != 0x5A)) {		errcode = ERR_SUP_FILINV;	}        /* close the file, then return if error occurred */        fclose(file_p);	if (errcode!=OK) return(errcode);        /* compute allocation size needed */        file_size = (header[5]*256 + header[4] -1) * 512		+ (header[3]*256 + header[2]);        header_size =(header[9]*256 + header[8])*16;        code_size = file_size - header_size;        data_size = (header[11]*256 + header[10])*16;        /* return total length and starting offset */        *prog_len_p = code_size + data_size;	*start_offset_p = (header[23]*256 + header[22]) * 16;	return(OK);}/*	Procedure: sys_load_program	Purpose: load a program file	Parameters: see prototype	Returns: error code; zero if OK	Calls:   intdosx		segread		strlen, strcat	Globals: none 	Errors:  ERR_SUP_NAMLNG    name too long		ERR_SUP_FILNFD    file not found	       ERR_SUP_FILINV      file invalid		ERR_SUP_PROGSZ    program too large	       ERR_SUP_LDADDR      address not aligned		ERR_SUP_LDFAIL    load failed*/int sys_load_program (     void*    load_addr,        /* address for loading */			int      max_size,         /* memory size */			char     dir_name[],       /* directory name */			char     prog_name[]       /* program name */		      ){	int errcode;      /* error code */        int prog_len;      /* program length */	int offset;       /* offset for starting */	word norm_seg;    /* normalized load address segment */        word norm_off;     /* normalized load address offset */        /* full pathname for file to be loaded */	char file_name[MAX_PATH_SIZE+1];        /* parameter block for MSDOS EXEC function */	struct {		word load_seg;    /* segment address for loading */	       word reloc_seg;     /* segment address for relocation */        }p_block;	union REGS inregs;            /* input register structure */	union REGS outregs;           /* output register structure */	struct SREGS segregs;         /* segment register structure */        /* check program, get length and offset */	errcode = sys_check_program(dir_name, prog_name,					&prog_len, &offset);        if (errcode < 0) return(errcode);        /* ensure that allocated memory is large enough */        if (max_size < prog_len) return(ERR_SUP_PROGSZ);        /* get normalized segment and offset, check alignment */	norm_seg = FP_SEG(load_addr);	norm_off = FP_OFF(load_addr);	norm_seg += norm_off / 16;        norm_off %= 16;	if (norm_off != 0) return(ERR_SUP_LDADDR);        /* ensure that path name is not too long */        if ((strlen(dir_name) + strlen(prog_name) + 5)		 > MAX_PATH_SIZE) return(ERR_SUP_NAMLNG);	/* construct path name */	file_name[0] = NULCH;	if (dir_name[0] != NULCH) {		strcat(file_name, dir_name);	        strcat(file_name, "\\");	}        strcat(file_name, prog_name);	strcat(file_name, ".MPX");        /* get current segment regs */	segread(&segregs);        /* setup function codes */	inregs.h.ah = 0x4B;        /* EXEC function */	inregs.h.al = 0x03;        /* load only */        /* setup parameter block and name pointers */        segregs.ds = FP_SEG(&file_name);	inregs.x.dx = FP_OFF(&file_name);        segregs.es = FP_SEG(&p_block);	inregs.x.bx = FP_OFF(&p_block);        /* setup load segment -- must be normalized */	p_block.load_seg = norm_seg;	p_block.reloc_seg = p_block.load_seg;        /* call the MS-DOS loader */	errcode = intdosx(&inregs,&outregs,&segregs);        errcode = errcode;        /* check for error */	if (outregs.x.cflag) return(ERR_SUP_LDFAIL);	/* load successful */	return(OK);}/* END OF FILE */sys_get_entry1,0
/***********************************************************************	MPX: The MultiProgramming eXecutive	Project to Accompany	A Practical Approach to Operating Systems	Malcolm G. Lane & James D. Mooney	Copyright 1993, P.W.S. Kent Publishing Co., Boston, MA.		File Name: mpx_supt.c	Authors: J.J. Patnesky, A. Ghosal, M. Lane, J. Mooney	Version: 2.1b	Date: 01/31/08	Purpose: Support routines for MPX-PC		Modules: all	Environment:      IBM-PC (XT, AT or PS/2)			MS-DOS 3.3 or later			TURBO-C 3.0 or TURBO-C++ 1.0 or later	Compile using the LARGE MODEL and SS NOT equal to DS.	All addresses and pointers are "far", and	CS, DS and SS are independent.	Procedures in this file:		sys_init		sys_exit		sys_set_vec		sys_req		sys_alloc_mem		sys_free_mem		sys_get_date		sys_set_date		sys_open_dir		sys_get_entry		sys_close_dir	       sys_check_program	       sys_load_program************************************************************************Change Log:	07/16/88  akg	added comments	02/25/92  jdm	full revision, UNIX version	04/14/92  jdm	Macintosh version	05/15/92  jdm	cleanup and documentation	07/14/92  jdm	update for revised specs        08/13/92  jdm 	revised IBM version; added private heap        10/14/92  jdm 	added check and load procedures        10/18/92  jdm 	revised sys_alloc_mem for alignment	11/17/92  jdm	true heap mgt, aligned, using calloc & free	11/19/92  jdm	enable device handling for final module	12/31/92  jdm	revised sys_req parameters	01/02/93  jdm	return count value after I/O	01/03/93  jdm	revised error names and codes	01/27/93  jdm	corrected count for line input in sys_req			fixed open_dir to handle null lines	02/24/93  jdm	changed sys_set_vec param to interrupt	03/08/93  jdm	corrections to sys_check & sys_load	03/20/93  jdm	stack switch in free, check, and load	04/22/93  jdm	corrected index conflict in sys_free_mem			added safety escape in alloc table search	07/28/93  jdm	conversion to large model	09/01/93  jdm	fixed allocation bug;  made date private	09/14/93  jdm	cleaned up memory allocation        09/16/93  jdm	adjusted program load for large model        09/30/93  jdm	modified for correct list of root directory	11/01/94  jdm	changed load file read to binary	09/18/95  jdm	fixed get_entry to default to current, not root	01/31/08  jdm   fixed possible overflow problem in get_entry************************************************************************/#include "mpx_supt.h"#include <stdlib.h>#include <dos.h>#include <dir.h>#include <errno.h>#include <conio.h>#include <alloc.h>#define VEC_ADDR (0x60L*4)#define MAX_ALLOC 200#define MAX_XPOS 79#define MAX_YPOS 24#define MAX_PATH_SIZE 50/*	System-dependent type definitions*/typedef unsigned char byte;typedef unsigned int word;typedef unsigned long longword;typedef byte *address;typedef struct params {	int      op_code;	int      device_id;	char     *buf_p;	int      *count_p;	} params;/*	Global variables accessed only by support routines*/	static longword vec_save;  /* saved interrupt vector */	static int mod_code;                /* module code */                                           	static struct date sys_date;        /* MPX system date */	/* data structures for directory access */        static char current_path[MAX_PATH_SIZE+1];        static int num_entries;        static struct ffblk file_block;        /* handler presence flags */	static flag sysc_hand;	static flag trm_hand;	static flag prt_hand;	static flag com_hand;        /* memory allocation table */	static struct {		void* original;		void* aligned;	} alloc_table[MAX_ALLOC];	static int alloc_ix;                /* current index */	static int num_alloc;               /* no. of allocated blocks *//*	Procedure: sys_init	Purpose: initialize mpx	Parameters: see prototype  	Return value: error code, or OK if no error	Calls: getdate    	Globals: mod_code		vec_save		sys_date		alloc_table, alloc_ix, num_alloc		sysc_hand, term_hand, prt_hand, com_hand	Errors: none*/int sys_init (    int      modules  /* module code */	     ){	mod_code = modules;        vec_save = 0L;        /* no handlers detected yet */	sysc_hand = FALSE;	trm_hand = FALSE;	prt_hand = FALSE;	com_hand = FALSE;	/* initialize allocation table */	for (alloc_ix=0; alloc_ix < MAX_ALLOC; alloc_ix++) {		alloc_table[alloc_ix].original = NULL;		alloc_table[alloc_ix].aligned = NULL;	}	alloc_ix = 0;	num_alloc = 0;	/* if we have reached Module R3, enable system call handling */	if (modules >= MODULE_R3) sysc_hand = TRUE;	/* if we have reached the final module, enable device handlers */	if (modules >= MODULE_F) {		trm_hand = TRUE;		prt_hand = TRUE;		com_hand = TRUE;	}	/* get system date */        getdate(&sys_date);	return (OK);}/*	Procedure: sys_exit	Purpose: terminate mpx	Parameters: none  	Return value: none	Calls: none       	Globals: vec_save*/void sys_exit(void){	longword *vec_p;	/* if trap vector changed, restore it */	if (vec_save != 0L) {		vec_p = (longword*) VEC_ADDR;		*vec_p = vec_save;	}	/* return to host with null error code */	exit(0);}/*	Procedure: sys_set_vec	Purpose: link trap vector to MPX system call handler	Parameters: handler: addr of handler         	Return value: error code; OK if no error	Calls: none       	Globals: vec_save	Errors: none*/int sys_set_vec   ( void interrupt (*handler)() /* system call handler */		){	longword *vec_p;			vec_p = (longword*) VEC_ADDR;		vec_save = *vec_p;		*vec_p = (longword) handler;	return (0);}/*	Procedure: sys_req	Purpose: Request a system service	Inputs:		op_code           operation code		device_id         device identifier		buf_p             addresso f data buffer		count_p           address of size of buffer	Returns: Result or error code, depending on service		Services supported:	IDLE     null operation				READ     input from a device				WRITE    output to a device				CLEAR    clear terminal screen				GOTOXY   absolute cursor position				EXIT     terminate the caller	Calls:   fgets		strlen			Globals: none		Errors:  ERR_SUP_INVDEV    invalid device		ERR_SUP_INVOPC    invalid operation code		ERR_SUP_INVPOS    invalid character position		ERR_SUP_RDFAIL    read failed		ERR_SUP_WRFAIL    write failed	Description:	For Modules R1 through R4,	this procedure is used only for terminal I/O.	Later modules support both reading and	writing for several devices.	For Modules R1 through R4,	sys_req uses the ANSI C function "fgets."	Later modules may use alternate functions and device drivers.*/int sys_req (   int      op_code, /* operation code */		int      device_id,        /* device id */		char*    buf_p,            /* I/O buffer */		int*     count_p           /* address of count */		){	int      rval;    /* result or error code */	char     *rp;     /* return pointer for fgets */	char     rc;      /* return char for fputc */        params    *param_p; /* pointer to parameter record in stack */	flag     docall;  /* true if system call interrupt wanted */	int      ix;      /* temporary index */	docall = FALSE;	rval = OK;	switch (op_code) {		case IDLE:		if (sysc_hand) docall = TRUE;		break; 				case READ:		switch (device_id) {				case TERMINAL:			if (trm_hand) docall = TRUE;			else {				rp = fgets(buf_p,*count_p,stdin);				if (rp==NULL) rval = ERR_SUP_RDFAIL;				else rval = strlen(buf_p);			}			break;					case COM_PORT:			if (com_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					default:			rval = ERR_SUP_INVDEV;					}		break;	case WRITE:		switch (device_id) {				case TERMINAL:			if (trm_hand) docall = TRUE;			else {				rval = *count_p;				for (ix=0; ix<*count_p; ix++) {					rc = fputc(buf_p[ix],stdout);					if (rc == EOF) {						rval = ERR_SUP_WRFAIL;						break;					}				}			}			break;					case COM_PORT:			if (com_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					case PRINTER:			if (prt_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					default:			rval = ERR_SUP_INVDEV;					}		break;	case CLEAR:		if (device_id==TERMINAL) {			if (trm_hand) docall = TRUE;			else {			     clrscr();				rval = 0;			}		}		else rval = ERR_SUP_INVDEV;		break;			case GOTOXY:		if (device_id==TERMINAL) {			if (trm_hand) docall = TRUE;			else {				if (*count_p != 2) rval = ERR_SUP_WRFAIL;				else if ((*buf_p<0)					|| (*buf_p > MAX_XPOS))					rval = ERR_SUP_WRFAIL;				else if ((*(buf_p+1)<0)					|| (*(buf_p+1) > MAX_YPOS))					rval = ERR_SUP_WRFAIL;				else {					gotoxy(*buf_p + 1,						*(buf_p+1) + 1);					rval = 0;				}			}		}		else rval = ERR_SUP_INVDEV;		break;			/* EXIT - terminate the calling process */	/* legal only when a system call handler is present */	case EXIT:		if (sysc_hand) docall = TRUE;		else rval = ERR_SUP_INVOPC;		break; 	default:		rval = ERR_SUP_INVOPC;			}		/* Invoke user's call handler if present.	   If the call is an IO request, return will occur	   only after the request is complete.	*/	if (docall && (rval==OK)) {		/* invoke the call handler */	_SP = _SP - sizeof(params);		param_p = (params*) MK_FP(_SS,_SP);	       param_p->op_code = op_code;	       param_p->device_id = device_id;	       param_p->buf_p = buf_p;	       param_p->count_p = count_p;	       geninterrupt(0x60);	       rval = _AX;	       _SP = _SP + sizeof(params);		/* for I/O operations, return count value */		switch(op_code) {		case READ:		case WRITE:		case CLEAR:		case GOTOXY:			rval = *count_p;		}	}	return(rval);}/*	Procedure: sys_alloc_mem	Purpose: Allocate a memory block	Parameters:			size_t size       No. of bytes to allocate	Returns: void* pointer to allocated block;		 null pointer in case of error		 	Calls: calloc		Globals: alloc_table, alloc_ix, num_alloc	For program loading (Module R-4), the blocks must be aligned.	This is achieved by requesting one extra paragraph and	returning the lowest aligned address as the base.  It is	necessary to keep a table of allocated address, original and	aligned, to support correct freeing.	It would seem simpler to use the Turbo-C function allocmem,	which always allocates aligned blocks.  However, allocmem	appears to conflict with the internal allocation of fopen	and other C library routines.*/void *sys_alloc_mem (      size_t   size     /* size in bytes to allocate */		    ){	int ix_save;      /* temp copy of table index */        void *addr;        /* addr returned by calloc (*void) */	word offset;      /* offset of unaligned address */	word seg;         /* segment addr of unaligned address */	void *addr_alig; /* aligned address */	int rem; /* temp for alignment computation */	/* ensure that allocation table is not full */	if (num_alloc >= MAX_ALLOC) {		return(NULL);	}	/* find free entry in allocation table */	ix_save = alloc_ix;	while (alloc_table[alloc_ix].original != NULL) {		alloc_ix++;		if (alloc_ix >= MAX_ALLOC) alloc_ix = 0;		/* safety check -- should never happen! */		if (alloc_ix == ix_save) return(NULL);	}	/* call allocation routine */	/* request 15 extra bytes to ensure alignment is possible */	addr = calloc(size + 15,1);	/* compute aligned base */	offset = FP_OFF(addr);        seg = FP_SEG(addr);	rem = offset % 16;	if (rem > 0) offset = offset + 16 - rem;	addr_alig = MK_FP(seg,offset);	/* insert entries in table */	alloc_table[alloc_ix].original = addr;	alloc_table[alloc_ix].aligned = addr_alig;	/* increment count */	num_alloc++;	return(addr_alig);}/*	Procedure: sys_free_mem	Purpose: free a memory block	Parameters:		void *ptr         ptr to block to allocate	Returns: integer error code; zero if OK		Calls:   free	Globals: alloc_table, num_alloc	Errors:  ERR_SUP_INVMEM    invalid memory block	This procedure receives an aligned address; it must	find and free the corresponding non-aligned one.*/int sys_free_mem (         void     *ptr     /* pointer to block */		 ){	void *free_addr;  /* true (unaligned) block address */	int free_ix;               /* temp table index */	/* ensure valid pointer */	if (ptr==NULL) return(ERR_SUP_INVMEM);	/* Look for the block in the allocation table */	free_addr = NULL;	for (free_ix=0; free_ix<MAX_ALLOC; free_ix++) {		if (alloc_table[free_ix].aligned == ptr) {			free_addr = alloc_table[free_ix].original;			break;		}	}	/* If the block wasn't found, report error */	if (free_addr == NULL) return(ERR_SUP_INVMEM);	/* free the block & clear the table entry */	alloc_table[free_ix].original = NULL;	alloc_table[free_ix].aligned = NULL;        free(free_addr);	/* decrement count */	num_alloc--;	return(OK);}        /*	Procedure: sys_get_date	Purpose: Returns the system date (month, day, year)	Parameters:		date_rec *date_p Pointer to structure of type date	Returns: void		Calls: none		Globals: sys_date        Errors: none*/void sys_get_date (  date_rec*      date_p   /* ptr to date record */		){	date_p->month = sys_date.da_mon;	date_p->day = sys_date.da_day;	date_p->year = sys_date.da_year;}/*	Procedure: sys_set_date	Purpose: Sets the system date (month, day, year)	Parameters:		date_rec *date_p ptr to structure of type date	Returns: error code; OK if no error	Calls:   none        Globals: sys_date	Errors: none*/int sys_set_date (  date_rec*       date_p   /* ptr to date record */		 ){	sys_date.da_mon = date_p->month;        sys_date.da_day = date_p->day;        sys_date.da_year = date_p->year;	return(OK);}/*	Procedure: sys_open_dir	Purpose: open a specified directory	Parameters: char dir_name[]            directory name	Returns: error code; zero if OK	Calls:   findfirst		strncpy  	Globals: current_path, file_block, num_entries	Errors:  ERR_SUP_DIROPN    directory open error		ERR_SUP_INVDIR    invalid directory*/int sys_open_dir (  char  path_name[]        /* directory name */		 ){        char temp_path[MAX_PATH_SIZE];	int res;        int len;        /* ensure there is no directory currently open */	if (current_path[0]!=NULCH) return(ERR_SUP_DIROPN);        /* check pathname for validity */        /* construct temporary search path name */	temp_path[0] = NULCH;	if (path_name != NULL) {		strncpy(temp_path,path_name,MAX_PATH_SIZE-4);	}	/* build wildcard search string */        len = strlen(temp_path);	/* if path is null, use current directory */        if (len==0) strcpy(temp_path,"*.*");	/* handle paths ending in backslash, including root */        else if (temp_path[len-1]=='\\') strcat(temp_path,"*.*");	/* handle paths not ending in backslash */        else strcat(temp_path,"\\*.*");	/* validate the directory by searching for either an ordinary	   file or a directory in it.  This should never fail; even	   empty directories contain the directories "." and ".."	*/		res = findfirst(temp_path, &file_block, FA_DIREC);	if (res!=0)  return(ERR_SUP_INVDIR);        /* save pathname as current, clear entry count */	current_path[0] = NULCH;	if (path_name != NULL) {		strncpy(current_path,path_name,MAX_PATH_SIZE-6);	}	num_entries = 0;	return(OK);}/*	Procedure: sys_get_entry	Purpose: get the next directory entry;	Parameters: char name_buf[]	name buffer		    int buf_size  	buffer capacity		    long *file_size_p	file length buffer         	Returns: error code, or zero if ok	Calls:	findfirst		findnext		strncpy, strcpy, strrchr, strcat    	Globals: current_path, num_entries, file_block	Errors:  ERR_SUP_NOENTR    no such entry*/int sys_get_entry (char    name_buf[],       /* buffer for entry */		   int   buf_size,         /* buffer size */		   long* file_size_p       /* buffer for size value */		  ){	char filename[MAX_PATH_SIZE+1];	int err;        int len;        char *cp;        /* find next MPX file entry, if any */        /* if this is the first call */	if (num_entries==0) {	       /* construct complete search path name */	       len = strlen(current_path);	       if (len==0) strcpy(current_path,"*.MPX");	       else if (current_path[len-1]=='\\') strcat(current_path,"*.MPX");	       else strcat(current_path,"\\*.MPX");	       /* find first entry */		err = findfirst (current_path,&file_block,0);        }        /* otherwise, find next entry */        else err = findnext(&file_block);        if (err<0) return(ERR_SUP_NOENTR);		/* ensure buf_size is not too large */		if (buf_size > MAX_PATH_SIZE) buf_size = MAX_PATH_SIZE;		      /* copy filename to buffer */	filename[buf_size] = NULCH;	strncpy (filename,file_block.ff_name,			 (size_t) buf_size);	/* remove ".MPX" from name */	cp = strrchr(filename, (int) '.');        *cp = NULCH;	/* copy name and size to caller's buffer */        strcpy (name_buf,filename);	*file_size_p = file_block.ff_fsize;        /* count entry */	num_entries++;	return(OK);}/*	Procedure: sys_close_dir	Purpose: close an open directory	Parameters: none	Returns: error code; zero if OK	Calls:   none	Globals: current_path	Errors:  none*/int sys_close_dir (void){	current_path[0] = NULCH;	return(OK);}/*	Procedure: sys_check_program	Purpose: locate and measure a program file	Parameters: see prototype	Returns: program size or error code	Calls:   strlen, strcat		fopen, fread	Globals: none	Errors:  ERR_SUP_NAMLNG    pathname too long		ERR_SUP_FILNFD    file not found		ERR_SUP_FILINV    file invalid*/#define HEADER_SIZE 32int sys_check_program(     char     dir_name[],       /* directory name */			char     prog_name[],      /* program name */			int*     prog_len_p,       /* ptr to prog length */			int*     start_offset_p    /* ptr to start offset */			){        /* buffer for full pathname */	char file_name[MAX_PATH_SIZE+1];        /* buffer for file header */        byte header[HEADER_SIZE];	FILE *file_p;     /* file pointer for C file routines */        int num_read;      /* number of header bytes read */	int file_size;    /* size of complete file */        int header_size;/* size of header */        int code_size;     /* size of program code */        int data_size;     /* size of program data */        int errcode;       /* error code */        /* ensure that path name is not too long */        if ((strlen(dir_name) + strlen(prog_name) + 5)		 > MAX_PATH_SIZE) return(ERR_SUP_NAMLNG);	/* construct path name */	file_name[0] = NULCH;	if (dir_name[0] != NULCH) {		strcat(file_name, dir_name);	        strcat(file_name, "\\");	}        strcat(file_name, prog_name);	strcat(file_name, ".MPX");        /* try to open the file */	errcode = OK;        file_p = fopen(file_name, "rb");        if (file_p == NULL) return(ERR_SUP_FILNFD);	/* read the header, check for EXE signature */        num_read = fread( (void*) header, 1, HEADER_SIZE, file_p);        if (num_read != HEADER_SIZE) {		errcode = ERR_SUP_FILINV;	}        else if ((header[0] != 0x4D) || (header[1] != 0x5A)) {		errcode = ERR_SUP_FILINV;	}        /* close the file, then return if error occurred */        fclose(file_p);	if (errcode!=OK) return(errcode);        /* compute allocation size needed */        file_size = (header[5]*256 + header[4] -1) * 512		+ (header[3]*256 + header[2]);        header_size =(header[9]*256 + header[8])*16;        code_size = file_size - header_size;        data_size = (header[11]*256 + header[10])*16;        /* return total length and starting offset */        *prog_len_p = code_size + data_size;	*start_offset_p = (header[23]*256 + header[22]) * 16;	return(OK);}/*	Procedure: sys_load_program	Purpose: load a program file	Parameters: see prototype	Returns: error code; zero if OK	Calls:   intdosx		segread		strlen, strcat	Globals: none 	Errors:  ERR_SUP_NAMLNG    name too long		ERR_SUP_FILNFD    file not found	       ERR_SUP_FILINV      file invalid		ERR_SUP_PROGSZ    program too large	       ERR_SUP_LDADDR      address not aligned		ERR_SUP_LDFAIL    load failed*/int sys_load_program (     void*    load_addr,        /* address for loading */			int      max_size,         /* memory size */			char     dir_name[],       /* directory name */			char     prog_name[]       /* program name */		      ){	int errcode;      /* error code */        int prog_len;      /* program length */	int offset;       /* offset for starting */	word norm_seg;    /* normalized load address segment */        word norm_off;     /* normalized load address offset */        /* full pathname for file to be loaded */	char file_name[MAX_PATH_SIZE+1];        /* parameter block for MSDOS EXEC function */	struct {		word load_seg;    /* segment address for loading */	       word reloc_seg;     /* segment address for relocation */        }p_block;	union REGS inregs;            /* input register structure */	union REGS outregs;           /* output register structure */	struct SREGS segregs;         /* segment register structure */        /* check program, get length and offset */	errcode = sys_check_program(dir_name, prog_name,					&prog_len, &offset);        if (errcode < 0) return(errcode);        /* ensure that allocated memory is large enough */        if (max_size < prog_len) return(ERR_SUP_PROGSZ);        /* get normalized segment and offset, check alignment */	norm_seg = FP_SEG(load_addr);	norm_off = FP_OFF(load_addr);	norm_seg += norm_off / 16;        norm_off %= 16;	if (norm_off != 0) return(ERR_SUP_LDADDR);        /* ensure that path name is not too long */        if ((strlen(dir_name) + strlen(prog_name) + 5)		 > MAX_PATH_SIZE) return(ERR_SUP_NAMLNG);	/* construct path name */	file_name[0] = NULCH;	if (dir_name[0] != NULCH) {		strcat(file_name, dir_name);	        strcat(file_name, "\\");	}        strcat(file_name, prog_name);	strcat(file_name, ".MPX");        /* get current segment regs */	segread(&segregs);        /* setup function codes */	inregs.h.ah = 0x4B;        /* EXEC function */	inregs.h.al = 0x03;        /* load only */        /* setup parameter block and name pointers */        segregs.ds = FP_SEG(&file_name);	inregs.x.dx = FP_OFF(&file_name);        segregs.es = FP_SEG(&p_block);	inregs.x.bx = FP_OFF(&p_block);        /* setup load segment -- must be normalized */	p_block.load_seg = norm_seg;	p_block.reloc_seg = p_block.load_seg;        /* call the MS-DOS loader */	errcode = intdosx(&inregs,&outregs,&segregs);        errcode = errcode;        /* check for error */	if (outregs.x.cflag) return(ERR_SUP_LDFAIL);	/* load successful */	return(OK);}/* END OF FILE */sys_close_dir1,0
/***********************************************************************	MPX: The MultiProgramming eXecutive	Project to Accompany	A Practical Approach to Operating Systems	Malcolm G. Lane & James D. Mooney	Copyright 1993, P.W.S. Kent Publishing Co., Boston, MA.		File Name: mpx_supt.c	Authors: J.J. Patnesky, A. Ghosal, M. Lane, J. Mooney	Version: 2.1b	Date: 01/31/08	Purpose: Support routines for MPX-PC		Modules: all	Environment:      IBM-PC (XT, AT or PS/2)			MS-DOS 3.3 or later			TURBO-C 3.0 or TURBO-C++ 1.0 or later	Compile using the LARGE MODEL and SS NOT equal to DS.	All addresses and pointers are "far", and	CS, DS and SS are independent.	Procedures in this file:		sys_init		sys_exit		sys_set_vec		sys_req		sys_alloc_mem		sys_free_mem		sys_get_date		sys_set_date		sys_open_dir		sys_get_entry		sys_close_dir	       sys_check_program	       sys_load_program************************************************************************Change Log:	07/16/88  akg	added comments	02/25/92  jdm	full revision, UNIX version	04/14/92  jdm	Macintosh version	05/15/92  jdm	cleanup and documentation	07/14/92  jdm	update for revised specs        08/13/92  jdm 	revised IBM version; added private heap        10/14/92  jdm 	added check and load procedures        10/18/92  jdm 	revised sys_alloc_mem for alignment	11/17/92  jdm	true heap mgt, aligned, using calloc & free	11/19/92  jdm	enable device handling for final module	12/31/92  jdm	revised sys_req parameters	01/02/93  jdm	return count value after I/O	01/03/93  jdm	revised error names and codes	01/27/93  jdm	corrected count for line input in sys_req			fixed open_dir to handle null lines	02/24/93  jdm	changed sys_set_vec param to interrupt	03/08/93  jdm	corrections to sys_check & sys_load	03/20/93  jdm	stack switch in free, check, and load	04/22/93  jdm	corrected index conflict in sys_free_mem			added safety escape in alloc table search	07/28/93  jdm	conversion to large model	09/01/93  jdm	fixed allocation bug;  made date private	09/14/93  jdm	cleaned up memory allocation        09/16/93  jdm	adjusted program load for large model        09/30/93  jdm	modified for correct list of root directory	11/01/94  jdm	changed load file read to binary	09/18/95  jdm	fixed get_entry to default to current, not root	01/31/08  jdm   fixed possible overflow problem in get_entry************************************************************************/#include "mpx_supt.h"#include <stdlib.h>#include <dos.h>#include <dir.h>#include <errno.h>#include <conio.h>#include <alloc.h>#define VEC_ADDR (0x60L*4)#define MAX_ALLOC 200#define MAX_XPOS 79#define MAX_YPOS 24#define MAX_PATH_SIZE 50/*	System-dependent type definitions*/typedef unsigned char byte;typedef unsigned int word;typedef unsigned long longword;typedef byte *address;typedef struct params {	int      op_code;	int      device_id;	char     *buf_p;	int      *count_p;	} params;/*	Global variables accessed only by support routines*/	static longword vec_save;  /* saved interrupt vector */	static int mod_code;                /* module code */                                           	static struct date sys_date;        /* MPX system date */	/* data structures for directory access */        static char current_path[MAX_PATH_SIZE+1];        static int num_entries;        static struct ffblk file_block;        /* handler presence flags */	static flag sysc_hand;	static flag trm_hand;	static flag prt_hand;	static flag com_hand;        /* memory allocation table */	static struct {		void* original;		void* aligned;	} alloc_table[MAX_ALLOC];	static int alloc_ix;                /* current index */	static int num_alloc;               /* no. of allocated blocks *//*	Procedure: sys_init	Purpose: initialize mpx	Parameters: see prototype  	Return value: error code, or OK if no error	Calls: getdate    	Globals: mod_code		vec_save		sys_date		alloc_table, alloc_ix, num_alloc		sysc_hand, term_hand, prt_hand, com_hand	Errors: none*/int sys_init (    int      modules  /* module code */	     ){	mod_code = modules;        vec_save = 0L;        /* no handlers detected yet */	sysc_hand = FALSE;	trm_hand = FALSE;	prt_hand = FALSE;	com_hand = FALSE;	/* initialize allocation table */	for (alloc_ix=0; alloc_ix < MAX_ALLOC; alloc_ix++) {		alloc_table[alloc_ix].original = NULL;		alloc_table[alloc_ix].aligned = NULL;	}	alloc_ix = 0;	num_alloc = 0;	/* if we have reached Module R3, enable system call handling */	if (modules >= MODULE_R3) sysc_hand = TRUE;	/* if we have reached the final module, enable device handlers */	if (modules >= MODULE_F) {		trm_hand = TRUE;		prt_hand = TRUE;		com_hand = TRUE;	}	/* get system date */        getdate(&sys_date);	return (OK);}/*	Procedure: sys_exit	Purpose: terminate mpx	Parameters: none  	Return value: none	Calls: none       	Globals: vec_save*/void sys_exit(void){	longword *vec_p;	/* if trap vector changed, restore it */	if (vec_save != 0L) {		vec_p = (longword*) VEC_ADDR;		*vec_p = vec_save;	}	/* return to host with null error code */	exit(0);}/*	Procedure: sys_set_vec	Purpose: link trap vector to MPX system call handler	Parameters: handler: addr of handler         	Return value: error code; OK if no error	Calls: none       	Globals: vec_save	Errors: none*/int sys_set_vec   ( void interrupt (*handler)() /* system call handler */		){	longword *vec_p;			vec_p = (longword*) VEC_ADDR;		vec_save = *vec_p;		*vec_p = (longword) handler;	return (0);}/*	Procedure: sys_req	Purpose: Request a system service	Inputs:		op_code           operation code		device_id         device identifier		buf_p             addresso f data buffer		count_p           address of size of buffer	Returns: Result or error code, depending on service		Services supported:	IDLE     null operation				READ     input from a device				WRITE    output to a device				CLEAR    clear terminal screen				GOTOXY   absolute cursor position				EXIT     terminate the caller	Calls:   fgets		strlen			Globals: none		Errors:  ERR_SUP_INVDEV    invalid device		ERR_SUP_INVOPC    invalid operation code		ERR_SUP_INVPOS    invalid character position		ERR_SUP_RDFAIL    read failed		ERR_SUP_WRFAIL    write failed	Description:	For Modules R1 through R4,	this procedure is used only for terminal I/O.	Later modules support both reading and	writing for several devices.	For Modules R1 through R4,	sys_req uses the ANSI C function "fgets."	Later modules may use alternate functions and device drivers.*/int sys_req (   int      op_code, /* operation code */		int      device_id,        /* device id */		char*    buf_p,            /* I/O buffer */		int*     count_p           /* address of count */		){	int      rval;    /* result or error code */	char     *rp;     /* return pointer for fgets */	char     rc;      /* return char for fputc */        params    *param_p; /* pointer to parameter record in stack */	flag     docall;  /* true if system call interrupt wanted */	int      ix;      /* temporary index */	docall = FALSE;	rval = OK;	switch (op_code) {		case IDLE:		if (sysc_hand) docall = TRUE;		break; 				case READ:		switch (device_id) {				case TERMINAL:			if (trm_hand) docall = TRUE;			else {				rp = fgets(buf_p,*count_p,stdin);				if (rp==NULL) rval = ERR_SUP_RDFAIL;				else rval = strlen(buf_p);			}			break;					case COM_PORT:			if (com_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					default:			rval = ERR_SUP_INVDEV;					}		break;	case WRITE:		switch (device_id) {				case TERMINAL:			if (trm_hand) docall = TRUE;			else {				rval = *count_p;				for (ix=0; ix<*count_p; ix++) {					rc = fputc(buf_p[ix],stdout);					if (rc == EOF) {						rval = ERR_SUP_WRFAIL;						break;					}				}			}			break;					case COM_PORT:			if (com_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					case PRINTER:			if (prt_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					default:			rval = ERR_SUP_INVDEV;					}		break;	case CLEAR:		if (device_id==TERMINAL) {			if (trm_hand) docall = TRUE;			else {			     clrscr();				rval = 0;			}		}		else rval = ERR_SUP_INVDEV;		break;			case GOTOXY:		if (device_id==TERMINAL) {			if (trm_hand) docall = TRUE;			else {				if (*count_p != 2) rval = ERR_SUP_WRFAIL;				else if ((*buf_p<0)					|| (*buf_p > MAX_XPOS))					rval = ERR_SUP_WRFAIL;				else if ((*(buf_p+1)<0)					|| (*(buf_p+1) > MAX_YPOS))					rval = ERR_SUP_WRFAIL;				else {					gotoxy(*buf_p + 1,						*(buf_p+1) + 1);					rval = 0;				}			}		}		else rval = ERR_SUP_INVDEV;		break;			/* EXIT - terminate the calling process */	/* legal only when a system call handler is present */	case EXIT:		if (sysc_hand) docall = TRUE;		else rval = ERR_SUP_INVOPC;		break; 	default:		rval = ERR_SUP_INVOPC;			}		/* Invoke user's call handler if present.	   If the call is an IO request, return will occur	   only after the request is complete.	*/	if (docall && (rval==OK)) {		/* invoke the call handler */	_SP = _SP - sizeof(params);		param_p = (params*) MK_FP(_SS,_SP);	       param_p->op_code = op_code;	       param_p->device_id = device_id;	       param_p->buf_p = buf_p;	       param_p->count_p = count_p;	       geninterrupt(0x60);	       rval = _AX;	       _SP = _SP + sizeof(params);		/* for I/O operations, return count value */		switch(op_code) {		case READ:		case WRITE:		case CLEAR:		case GOTOXY:			rval = *count_p;		}	}	return(rval);}/*	Procedure: sys_alloc_mem	Purpose: Allocate a memory block	Parameters:			size_t size       No. of bytes to allocate	Returns: void* pointer to allocated block;		 null pointer in case of error		 	Calls: calloc		Globals: alloc_table, alloc_ix, num_alloc	For program loading (Module R-4), the blocks must be aligned.	This is achieved by requesting one extra paragraph and	returning the lowest aligned address as the base.  It is	necessary to keep a table of allocated address, original and	aligned, to support correct freeing.	It would seem simpler to use the Turbo-C function allocmem,	which always allocates aligned blocks.  However, allocmem	appears to conflict with the internal allocation of fopen	and other C library routines.*/void *sys_alloc_mem (      size_t   size     /* size in bytes to allocate */		    ){	int ix_save;      /* temp copy of table index */        void *addr;        /* addr returned by calloc (*void) */	word offset;      /* offset of unaligned address */	word seg;         /* segment addr of unaligned address */	void *addr_alig; /* aligned address */	int rem; /* temp for alignment computation */	/* ensure that allocation table is not full */	if (num_alloc >= MAX_ALLOC) {		return(NULL);	}	/* find free entry in allocation table */	ix_save = alloc_ix;	while (alloc_table[alloc_ix].original != NULL) {		alloc_ix++;		if (alloc_ix >= MAX_ALLOC) alloc_ix = 0;		/* safety check -- should never happen! */		if (alloc_ix == ix_save) return(NULL);	}	/* call allocation routine */	/* request 15 extra bytes to ensure alignment is possible */	addr = calloc(size + 15,1);	/* compute aligned base */	offset = FP_OFF(addr);        seg = FP_SEG(addr);	rem = offset % 16;	if (rem > 0) offset = offset + 16 - rem;	addr_alig = MK_FP(seg,offset);	/* insert entries in table */	alloc_table[alloc_ix].original = addr;	alloc_table[alloc_ix].aligned = addr_alig;	/* increment count */	num_alloc++;	return(addr_alig);}/*	Procedure: sys_free_mem	Purpose: free a memory block	Parameters:		void *ptr         ptr to block to allocate	Returns: integer error code; zero if OK		Calls:   free	Globals: alloc_table, num_alloc	Errors:  ERR_SUP_INVMEM    invalid memory block	This procedure receives an aligned address; it must	find and free the corresponding non-aligned one.*/int sys_free_mem (         void     *ptr     /* pointer to block */		 ){	void *free_addr;  /* true (unaligned) block address */	int free_ix;               /* temp table index */	/* ensure valid pointer */	if (ptr==NULL) return(ERR_SUP_INVMEM);	/* Look for the block in the allocation table */	free_addr = NULL;	for (free_ix=0; free_ix<MAX_ALLOC; free_ix++) {		if (alloc_table[free_ix].aligned == ptr) {			free_addr = alloc_table[free_ix].original;			break;		}	}	/* If the block wasn't found, report error */	if (free_addr == NULL) return(ERR_SUP_INVMEM);	/* free the block & clear the table entry */	alloc_table[free_ix].original = NULL;	alloc_table[free_ix].aligned = NULL;        free(free_addr);	/* decrement count */	num_alloc--;	return(OK);}        /*	Procedure: sys_get_date	Purpose: Returns the system date (month, day, year)	Parameters:		date_rec *date_p Pointer to structure of type date	Returns: void		Calls: none		Globals: sys_date        Errors: none*/void sys_get_date (  date_rec*      date_p   /* ptr to date record */		){	date_p->month = sys_date.da_mon;	date_p->day = sys_date.da_day;	date_p->year = sys_date.da_year;}/*	Procedure: sys_set_date	Purpose: Sets the system date (month, day, year)	Parameters:		date_rec *date_p ptr to structure of type date	Returns: error code; OK if no error	Calls:   none        Globals: sys_date	Errors: none*/int sys_set_date (  date_rec*       date_p   /* ptr to date record */		 ){	sys_date.da_mon = date_p->month;        sys_date.da_day = date_p->day;        sys_date.da_year = date_p->year;	return(OK);}/*	Procedure: sys_open_dir	Purpose: open a specified directory	Parameters: char dir_name[]            directory name	Returns: error code; zero if OK	Calls:   findfirst		strncpy  	Globals: current_path, file_block, num_entries	Errors:  ERR_SUP_DIROPN    directory open error		ERR_SUP_INVDIR    invalid directory*/int sys_open_dir (  char  path_name[]        /* directory name */		 ){        char temp_path[MAX_PATH_SIZE];	int res;        int len;        /* ensure there is no directory currently open */	if (current_path[0]!=NULCH) return(ERR_SUP_DIROPN);        /* check pathname for validity */        /* construct temporary search path name */	temp_path[0] = NULCH;	if (path_name != NULL) {		strncpy(temp_path,path_name,MAX_PATH_SIZE-4);	}	/* build wildcard search string */        len = strlen(temp_path);	/* if path is null, use current directory */        if (len==0) strcpy(temp_path,"*.*");	/* handle paths ending in backslash, including root */        else if (temp_path[len-1]=='\\') strcat(temp_path,"*.*");	/* handle paths not ending in backslash */        else strcat(temp_path,"\\*.*");	/* validate the directory by searching for either an ordinary	   file or a directory in it.  This should never fail; even	   empty directories contain the directories "." and ".."	*/		res = findfirst(temp_path, &file_block, FA_DIREC);	if (res!=0)  return(ERR_SUP_INVDIR);        /* save pathname as current, clear entry count */	current_path[0] = NULCH;	if (path_name != NULL) {		strncpy(current_path,path_name,MAX_PATH_SIZE-6);	}	num_entries = 0;	return(OK);}/*	Procedure: sys_get_entry	Purpose: get the next directory entry;	Parameters: char name_buf[]	name buffer		    int buf_size  	buffer capacity		    long *file_size_p	file length buffer         	Returns: error code, or zero if ok	Calls:	findfirst		findnext		strncpy, strcpy, strrchr, strcat    	Globals: current_path, num_entries, file_block	Errors:  ERR_SUP_NOENTR    no such entry*/int sys_get_entry (char    name_buf[],       /* buffer for entry */		   int   buf_size,         /* buffer size */		   long* file_size_p       /* buffer for size value */		  ){	char filename[MAX_PATH_SIZE+1];	int err;        int len;        char *cp;        /* find next MPX file entry, if any */        /* if this is the first call */	if (num_entries==0) {	       /* construct complete search path name */	       len = strlen(current_path);	       if (len==0) strcpy(current_path,"*.MPX");	       else if (current_path[len-1]=='\\') strcat(current_path,"*.MPX");	       else strcat(current_path,"\\*.MPX");	       /* find first entry */		err = findfirst (current_path,&file_block,0);        }        /* otherwise, find next entry */        else err = findnext(&file_block);        if (err<0) return(ERR_SUP_NOENTR);		/* ensure buf_size is not too large */		if (buf_size > MAX_PATH_SIZE) buf_size = MAX_PATH_SIZE;		      /* copy filename to buffer */	filename[buf_size] = NULCH;	strncpy (filename,file_block.ff_name,			 (size_t) buf_size);	/* remove ".MPX" from name */	cp = strrchr(filename, (int) '.');        *cp = NULCH;	/* copy name and size to caller's buffer */        strcpy (name_buf,filename);	*file_size_p = file_block.ff_fsize;        /* count entry */	num_entries++;	return(OK);}/*	Procedure: sys_close_dir	Purpose: close an open directory	Parameters: none	Returns: error code; zero if OK	Calls:   none	Globals: current_path	Errors:  none*/int sys_close_dir (void){	current_path[0] = NULCH;	return(OK);}/*	Procedure: sys_check_program	Purpose: locate and measure a program file	Parameters: see prototype	Returns: program size or error code	Calls:   strlen, strcat		fopen, fread	Globals: none	Errors:  ERR_SUP_NAMLNG    pathname too long		ERR_SUP_FILNFD    file not found		ERR_SUP_FILINV    file invalid*/#define HEADER_SIZE 32int sys_check_program(     char     dir_name[],       /* directory name */			char     prog_name[],      /* program name */			int*     prog_len_p,       /* ptr to prog length */			int*     start_offset_p    /* ptr to start offset */			){        /* buffer for full pathname */	char file_name[MAX_PATH_SIZE+1];        /* buffer for file header */        byte header[HEADER_SIZE];	FILE *file_p;     /* file pointer for C file routines */        int num_read;      /* number of header bytes read */	int file_size;    /* size of complete file */        int header_size;/* size of header */        int code_size;     /* size of program code */        int data_size;     /* size of program data */        int errcode;       /* error code */        /* ensure that path name is not too long */        if ((strlen(dir_name) + strlen(prog_name) + 5)		 > MAX_PATH_SIZE) return(ERR_SUP_NAMLNG);	/* construct path name */	file_name[0] = NULCH;	if (dir_name[0] != NULCH) {		strcat(file_name, dir_name);	        strcat(file_name, "\\");	}        strcat(file_name, prog_name);	strcat(file_name, ".MPX");        /* try to open the file */	errcode = OK;        file_p = fopen(file_name, "rb");        if (file_p == NULL) return(ERR_SUP_FILNFD);	/* read the header, check for EXE signature */        num_read = fread( (void*) header, 1, HEADER_SIZE, file_p);        if (num_read != HEADER_SIZE) {		errcode = ERR_SUP_FILINV;	}        else if ((header[0] != 0x4D) || (header[1] != 0x5A)) {		errcode = ERR_SUP_FILINV;	}        /* close the file, then return if error occurred */        fclose(file_p);	if (errcode!=OK) return(errcode);        /* compute allocation size needed */        file_size = (header[5]*256 + header[4] -1) * 512		+ (header[3]*256 + header[2]);        header_size =(header[9]*256 + header[8])*16;        code_size = file_size - header_size;        data_size = (header[11]*256 + header[10])*16;        /* return total length and starting offset */        *prog_len_p = code_size + data_size;	*start_offset_p = (header[23]*256 + header[22]) * 16;	return(OK);}/*	Procedure: sys_load_program	Purpose: load a program file	Parameters: see prototype	Returns: error code; zero if OK	Calls:   intdosx		segread		strlen, strcat	Globals: none 	Errors:  ERR_SUP_NAMLNG    name too long		ERR_SUP_FILNFD    file not found	       ERR_SUP_FILINV      file invalid		ERR_SUP_PROGSZ    program too large	       ERR_SUP_LDADDR      address not aligned		ERR_SUP_LDFAIL    load failed*/int sys_load_program (     void*    load_addr,        /* address for loading */			int      max_size,         /* memory size */			char     dir_name[],       /* directory name */			char     prog_name[]       /* program name */		      ){	int errcode;      /* error code */        int prog_len;      /* program length */	int offset;       /* offset for starting */	word norm_seg;    /* normalized load address segment */        word norm_off;     /* normalized load address offset */        /* full pathname for file to be loaded */	char file_name[MAX_PATH_SIZE+1];        /* parameter block for MSDOS EXEC function */	struct {		word load_seg;    /* segment address for loading */	       word reloc_seg;     /* segment address for relocation */        }p_block;	union REGS inregs;            /* input register structure */	union REGS outregs;           /* output register structure */	struct SREGS segregs;         /* segment register structure */        /* check program, get length and offset */	errcode = sys_check_program(dir_name, prog_name,					&prog_len, &offset);        if (errcode < 0) return(errcode);        /* ensure that allocated memory is large enough */        if (max_size < prog_len) return(ERR_SUP_PROGSZ);        /* get normalized segment and offset, check alignment */	norm_seg = FP_SEG(load_addr);	norm_off = FP_OFF(load_addr);	norm_seg += norm_off / 16;        norm_off %= 16;	if (norm_off != 0) return(ERR_SUP_LDADDR);        /* ensure that path name is not too long */        if ((strlen(dir_name) + strlen(prog_name) + 5)		 > MAX_PATH_SIZE) return(ERR_SUP_NAMLNG);	/* construct path name */	file_name[0] = NULCH;	if (dir_name[0] != NULCH) {		strcat(file_name, dir_name);	        strcat(file_name, "\\");	}        strcat(file_name, prog_name);	strcat(file_name, ".MPX");        /* get current segment regs */	segread(&segregs);        /* setup function codes */	inregs.h.ah = 0x4B;        /* EXEC function */	inregs.h.al = 0x03;        /* load only */        /* setup parameter block and name pointers */        segregs.ds = FP_SEG(&file_name);	inregs.x.dx = FP_OFF(&file_name);        segregs.es = FP_SEG(&p_block);	inregs.x.bx = FP_OFF(&p_block);        /* setup load segment -- must be normalized */	p_block.load_seg = norm_seg;	p_block.reloc_seg = p_block.load_seg;        /* call the MS-DOS loader */	errcode = intdosx(&inregs,&outregs,&segregs);        errcode = errcode;        /* check for error */	if (outregs.x.cflag) return(ERR_SUP_LDFAIL);	/* load successful */	return(OK);}/* END OF FILE */sys_check_program1,0
/***********************************************************************	MPX: The MultiProgramming eXecutive	Project to Accompany	A Practical Approach to Operating Systems	Malcolm G. Lane & James D. Mooney	Copyright 1993, P.W.S. Kent Publishing Co., Boston, MA.		File Name: mpx_supt.c	Authors: J.J. Patnesky, A. Ghosal, M. Lane, J. Mooney	Version: 2.1b	Date: 01/31/08	Purpose: Support routines for MPX-PC		Modules: all	Environment:      IBM-PC (XT, AT or PS/2)			MS-DOS 3.3 or later			TURBO-C 3.0 or TURBO-C++ 1.0 or later	Compile using the LARGE MODEL and SS NOT equal to DS.	All addresses and pointers are "far", and	CS, DS and SS are independent.	Procedures in this file:		sys_init		sys_exit		sys_set_vec		sys_req		sys_alloc_mem		sys_free_mem		sys_get_date		sys_set_date		sys_open_dir		sys_get_entry		sys_close_dir	       sys_check_program	       sys_load_program************************************************************************Change Log:	07/16/88  akg	added comments	02/25/92  jdm	full revision, UNIX version	04/14/92  jdm	Macintosh version	05/15/92  jdm	cleanup and documentation	07/14/92  jdm	update for revised specs        08/13/92  jdm 	revised IBM version; added private heap        10/14/92  jdm 	added check and load procedures        10/18/92  jdm 	revised sys_alloc_mem for alignment	11/17/92  jdm	true heap mgt, aligned, using calloc & free	11/19/92  jdm	enable device handling for final module	12/31/92  jdm	revised sys_req parameters	01/02/93  jdm	return count value after I/O	01/03/93  jdm	revised error names and codes	01/27/93  jdm	corrected count for line input in sys_req			fixed open_dir to handle null lines	02/24/93  jdm	changed sys_set_vec param to interrupt	03/08/93  jdm	corrections to sys_check & sys_load	03/20/93  jdm	stack switch in free, check, and load	04/22/93  jdm	corrected index conflict in sys_free_mem			added safety escape in alloc table search	07/28/93  jdm	conversion to large model	09/01/93  jdm	fixed allocation bug;  made date private	09/14/93  jdm	cleaned up memory allocation        09/16/93  jdm	adjusted program load for large model        09/30/93  jdm	modified for correct list of root directory	11/01/94  jdm	changed load file read to binary	09/18/95  jdm	fixed get_entry to default to current, not root	01/31/08  jdm   fixed possible overflow problem in get_entry************************************************************************/#include "mpx_supt.h"#include <stdlib.h>#include <dos.h>#include <dir.h>#include <errno.h>#include <conio.h>#include <alloc.h>#define VEC_ADDR (0x60L*4)#define MAX_ALLOC 200#define MAX_XPOS 79#define MAX_YPOS 24#define MAX_PATH_SIZE 50/*	System-dependent type definitions*/typedef unsigned char byte;typedef unsigned int word;typedef unsigned long longword;typedef byte *address;typedef struct params {	int      op_code;	int      device_id;	char     *buf_p;	int      *count_p;	} params;/*	Global variables accessed only by support routines*/	static longword vec_save;  /* saved interrupt vector */	static int mod_code;                /* module code */                                           	static struct date sys_date;        /* MPX system date */	/* data structures for directory access */        static char current_path[MAX_PATH_SIZE+1];        static int num_entries;        static struct ffblk file_block;        /* handler presence flags */	static flag sysc_hand;	static flag trm_hand;	static flag prt_hand;	static flag com_hand;        /* memory allocation table */	static struct {		void* original;		void* aligned;	} alloc_table[MAX_ALLOC];	static int alloc_ix;                /* current index */	static int num_alloc;               /* no. of allocated blocks *//*	Procedure: sys_init	Purpose: initialize mpx	Parameters: see prototype  	Return value: error code, or OK if no error	Calls: getdate    	Globals: mod_code		vec_save		sys_date		alloc_table, alloc_ix, num_alloc		sysc_hand, term_hand, prt_hand, com_hand	Errors: none*/int sys_init (    int      modules  /* module code */	     ){	mod_code = modules;        vec_save = 0L;        /* no handlers detected yet */	sysc_hand = FALSE;	trm_hand = FALSE;	prt_hand = FALSE;	com_hand = FALSE;	/* initialize allocation table */	for (alloc_ix=0; alloc_ix < MAX_ALLOC; alloc_ix++) {		alloc_table[alloc_ix].original = NULL;		alloc_table[alloc_ix].aligned = NULL;	}	alloc_ix = 0;	num_alloc = 0;	/* if we have reached Module R3, enable system call handling */	if (modules >= MODULE_R3) sysc_hand = TRUE;	/* if we have reached the final module, enable device handlers */	if (modules >= MODULE_F) {		trm_hand = TRUE;		prt_hand = TRUE;		com_hand = TRUE;	}	/* get system date */        getdate(&sys_date);	return (OK);}/*	Procedure: sys_exit	Purpose: terminate mpx	Parameters: none  	Return value: none	Calls: none       	Globals: vec_save*/void sys_exit(void){	longword *vec_p;	/* if trap vector changed, restore it */	if (vec_save != 0L) {		vec_p = (longword*) VEC_ADDR;		*vec_p = vec_save;	}	/* return to host with null error code */	exit(0);}/*	Procedure: sys_set_vec	Purpose: link trap vector to MPX system call handler	Parameters: handler: addr of handler         	Return value: error code; OK if no error	Calls: none       	Globals: vec_save	Errors: none*/int sys_set_vec   ( void interrupt (*handler)() /* system call handler */		){	longword *vec_p;			vec_p = (longword*) VEC_ADDR;		vec_save = *vec_p;		*vec_p = (longword) handler;	return (0);}/*	Procedure: sys_req	Purpose: Request a system service	Inputs:		op_code           operation code		device_id         device identifier		buf_p             addresso f data buffer		count_p           address of size of buffer	Returns: Result or error code, depending on service		Services supported:	IDLE     null operation				READ     input from a device				WRITE    output to a device				CLEAR    clear terminal screen				GOTOXY   absolute cursor position				EXIT     terminate the caller	Calls:   fgets		strlen			Globals: none		Errors:  ERR_SUP_INVDEV    invalid device		ERR_SUP_INVOPC    invalid operation code		ERR_SUP_INVPOS    invalid character position		ERR_SUP_RDFAIL    read failed		ERR_SUP_WRFAIL    write failed	Description:	For Modules R1 through R4,	this procedure is used only for terminal I/O.	Later modules support both reading and	writing for several devices.	For Modules R1 through R4,	sys_req uses the ANSI C function "fgets."	Later modules may use alternate functions and device drivers.*/int sys_req (   int      op_code, /* operation code */		int      device_id,        /* device id */		char*    buf_p,            /* I/O buffer */		int*     count_p           /* address of count */		){	int      rval;    /* result or error code */	char     *rp;     /* return pointer for fgets */	char     rc;      /* return char for fputc */        params    *param_p; /* pointer to parameter record in stack */	flag     docall;  /* true if system call interrupt wanted */	int      ix;      /* temporary index */	docall = FALSE;	rval = OK;	switch (op_code) {		case IDLE:		if (sysc_hand) docall = TRUE;		break; 				case READ:		switch (device_id) {				case TERMINAL:			if (trm_hand) docall = TRUE;			else {				rp = fgets(buf_p,*count_p,stdin);				if (rp==NULL) rval = ERR_SUP_RDFAIL;				else rval = strlen(buf_p);			}			break;					case COM_PORT:			if (com_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					default:			rval = ERR_SUP_INVDEV;					}		break;	case WRITE:		switch (device_id) {				case TERMINAL:			if (trm_hand) docall = TRUE;			else {				rval = *count_p;				for (ix=0; ix<*count_p; ix++) {					rc = fputc(buf_p[ix],stdout);					if (rc == EOF) {						rval = ERR_SUP_WRFAIL;						break;					}				}			}			break;					case COM_PORT:			if (com_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					case PRINTER:			if (prt_hand) docall = TRUE;			else rval = ERR_SUP_INVDEV;			break;					default:			rval = ERR_SUP_INVDEV;					}		break;	case CLEAR:		if (device_id==TERMINAL) {			if (trm_hand) docall = TRUE;			else {			     clrscr();				rval = 0;			}		}		else rval = ERR_SUP_INVDEV;		break;			case GOTOXY:		if (device_id==TERMINAL) {			if (trm_hand) docall = TRUE;			else {				if (*count_p != 2) rval = ERR_SUP_WRFAIL;				else if ((*buf_p<0)					|| (*buf_p > MAX_XPOS))					rval = ERR_SUP_WRFAIL;				else if ((*(buf_p+1)<0)					|| (*(buf_p+1) > MAX_YPOS))					rval = ERR_SUP_WRFAIL;				else {					gotoxy(*buf_p + 1,						*(buf_p+1) + 1);					rval = 0;				}			}		}		else rval = ERR_SUP_INVDEV;		break;			/* EXIT - terminate the calling process */	/* legal only when a system call handler is present */	case EXIT:		if (sysc_hand) docall = TRUE;		else rval = ERR_SUP_INVOPC;		break; 	default:		rval = ERR_SUP_INVOPC;			}		/* Invoke user's call handler if present.	   If the call is an IO request, return will occur	   only after the request is complete.	*/	if (docall && (rval==OK)) {		/* invoke the call handler */	_SP = _SP - sizeof(params);		param_p = (params*) MK_FP(_SS,_SP);	       param_p->op_code = op_code;	       param_p->device_id = device_id;	       param_p->buf_p = buf_p;	       param_p->count_p = count_p;	       geninterrupt(0x60);	       rval = _AX;	       _SP = _SP + sizeof(params);		/* for I/O operations, return count value */		switch(op_code) {		case READ:		case WRITE:		case CLEAR:		case GOTOXY:			rval = *count_p;		}	}	return(rval);}/*	Procedure: sys_alloc_mem	Purpose: Allocate a memory block	Parameters:			size_t size       No. of bytes to allocate	Returns: void* pointer to allocated block;		 null pointer in case of error		 	Calls: calloc		Globals: alloc_table, alloc_ix, num_alloc	For program loading (Module R-4), the blocks must be aligned.	This is achieved by requesting one extra paragraph and	returning the lowest aligned address as the base.  It is	necessary to keep a table of allocated address, original and	aligned, to support correct freeing.	It would seem simpler to use the Turbo-C function allocmem,	which always allocates aligned blocks.  However, allocmem	appears to conflict with the internal allocation of fopen	and other C library routines.*/void *sys_alloc_mem (      size_t   size     /* size in bytes to allocate */		    ){	int ix_save;      /* temp copy of table index */        void *addr;        /* addr returned by calloc (*void) */	word offset;      /* offset of unaligned address */	word seg;         /* segment addr of unaligned address */	void *addr_alig; /* aligned address */	int rem; /* temp for alignment computation */	/* ensure that allocation table is not full */	if (num_alloc >= MAX_ALLOC) {		return(NULL);	}	/* find free entry in allocation table */	ix_save = alloc_ix;	while (alloc_table[alloc_ix].original != NULL) {		alloc_ix++;		if (alloc_ix >= MAX_ALLOC) alloc_ix = 0;		/* safety check -- should never happen! */		if (alloc_ix == ix_save) return(NULL);	}	/* call allocation routine */	/* request 15 extra bytes to ensure alignment is possible */	addr = calloc(size + 15,1);	/* compute aligned base */	offset = FP_OFF(addr);        seg = FP_SEG(addr);	rem = offset % 16;	if (rem > 0) offset = offset + 16 - rem;	addr_alig = MK_FP(seg,offset);	/* insert entries in table */	alloc_table[alloc_ix].original = addr;	alloc_table[alloc_ix].aligned = addr_alig;	/* increment count */	num_alloc++;	return(addr_alig);}/*	Procedure: sys_free_mem	Purpose: free a memory block	Parameters:		void *ptr         ptr to block to allocate	Returns: integer error code; zero if OK		Calls:   free	Globals: alloc_table, num_alloc	Errors:  ERR_SUP_INVMEM    invalid memory block	This procedure receives an aligned address; it must	find and free the corresponding non-aligned one.*/int sys_free_mem (         void     *ptr     /* pointer to block */		 ){	void *free_addr;  /* true (unaligned) block address */	int free_ix;               /* temp table index */	/* ensure valid pointer */	if (ptr==NULL) return(ERR_SUP_INVMEM);	/* Look for the block in the allocation table */	free_addr = NULL;	for (free_ix=0; free_ix<MAX_ALLOC; free_ix++) {		if (alloc_table[free_ix].aligned == ptr) {			free_addr = alloc_table[free_ix].original;			break;		}	}	/* If the block wasn't found, report error */	if (free_addr == NULL) return(ERR_SUP_INVMEM);	/* free the block & clear the table entry */	alloc_table[free_ix].original = NULL;	alloc_table[free_ix].aligned = NULL;        free(free_addr);	/* decrement count */	num_alloc--;	return(OK);}        /*	Procedure: sys_get_date	Purpose: Returns the system date (month, day, year)	Parameters:		date_rec *date_p Pointer to structure of type date	Returns: void		Calls: none		Globals: sys_date        Errors: none*/void sys_get_date (  date_rec*      date_p   /* ptr to date record */		){	date_p->month = sys_date.da_mon;	date_p->day = sys_date.da_day;	date_p->year = sys_date.da_year;}/*	Procedure: sys_set_date	Purpose: Sets the system date (month, day, year)	Parameters:		date_rec *date_p ptr to structure of type date	Returns: error code; OK if no error	Calls:   none        Globals: sys_date	Errors: none*/int sys_set_date (  date_rec*       date_p   /* ptr to date record */		 ){	sys_date.da_mon = date_p->month;        sys_date.da_day = date_p->day;        sys_date.da_year = date_p->year;	return(OK);}/*	Procedure: sys_open_dir	Purpose: open a specified directory	Parameters: char dir_name[]            directory name	Returns: error code; zero if OK	Calls:   findfirst		strncpy  	Globals: current_path, file_block, num_entries	Errors:  ERR_SUP_DIROPN    directory open error		ERR_SUP_INVDIR    invalid directory*/int sys_open_dir (  char  path_name[]        /* directory name */		 ){        char temp_path[MAX_PATH_SIZE];	int res;        int len;        /* ensure there is no directory currently open */	if (current_path[0]!=NULCH) return(ERR_SUP_DIROPN);        /* check pathname for validity */        /* construct temporary search path name */	temp_path[0] = NULCH;	if (path_name != NULL) {		strncpy(temp_path,path_name,MAX_PATH_SIZE-4);	}	/* build wildcard search string */        len = strlen(temp_path);	/* if path is null, use current directory */        if (len==0) strcpy(temp_path,"*.*");	/* handle paths ending in backslash, including root */        else if (temp_path[len-1]=='\\') strcat(temp_path,"*.*");	/* handle paths not ending in backslash */        else strcat(temp_path,"\\*.*");	/* validate the directory by searching for either an ordinary	   file or a directory in it.  This should never fail; even	   empty directories contain the directories "." and ".."	*/		res = findfirst(temp_path, &file_block, FA_DIREC);	if (res!=0)  return(ERR_SUP_INVDIR);        /* save pathname as current, clear entry count */	current_path[0] = NULCH;	if (path_name != NULL) {		strncpy(current_path,path_name,MAX_PATH_SIZE-6);	}	num_entries = 0;	return(OK);}/*	Procedure: sys_get_entry	Purpose: get the next directory entry;	Parameters: char name_buf[]	name buffer		    int buf_size  	buffer capacity		    long *file_size_p	file length buffer         	Returns: error code, or zero if ok	Calls:	findfirst		findnext		strncpy, strcpy, strrchr, strcat    	Globals: current_path, num_entries, file_block	Errors:  ERR_SUP_NOENTR    no such entry*/int sys_get_entry (char    name_buf[],       /* buffer for entry */		   int   buf_size,         /* buffer size */		   long* file_size_p       /* buffer for size value */		  ){	char filename[MAX_PATH_SIZE+1];	int err;        int len;        char *cp;        /* find next MPX file entry, if any */        /* if this is the first call */	if (num_entries==0) {	       /* construct complete search path name */	       len = strlen(current_path);	       if (len==0) strcpy(current_path,"*.MPX");	       else if (current_path[len-1]=='\\') strcat(current_path,"*.MPX");	       else strcat(current_path,"\\*.MPX");	       /* find first entry */		err = findfirst (current_path,&file_block,0);        }        /* otherwise, find next entry */        else err = findnext(&file_block);        if (err<0) return(ERR_SUP_NOENTR);		/* ensure buf_size is not too large */		if (buf_size > MAX_PATH_SIZE) buf_size = MAX_PATH_SIZE;		      /* copy filename to buffer */	filename[buf_size] = NULCH;	strncpy (filename,file_block.ff_name,			 (size_t) buf_size);	/* remove ".MPX" from name */	cp = strrchr(filename, (int) '.');        *cp = NULCH;	/* copy name and size to caller's buffer */        strcpy (name_buf,filename);	*file_size_p = file_block.ff_fsize;        /* count entry */	num_entries++;	return(OK);}/*	Procedure: sys_close_dir	Purpose: close an open directory	Parameters: none	Returns: error code; zero if OK	Calls:   none	Globals: current_path	Errors:  none*/int sys_close_dir (void){	current_path[0] = NULCH;	return(OK);}/*	Procedure: sys_check_program	Purpose: locate and measure a program file	Parameters: see prototype	Returns: program size or error code	Calls:   strlen, strcat		fopen, fread	Globals: none	Errors:  ERR_SUP_NAMLNG    pathname too long		ERR_SUP_FILNFD    file not found		ERR_SUP_FILINV    file invalid*/#define HEADER_SIZE 32int sys_check_program(     char     dir_name[],       /* directory name */			char     prog_name[],      /* program name */			int*     prog_len_p,       /* ptr to prog length */			int*     start_offset_p    /* ptr to start offset */			){        /* buffer for full pathname */	char file_name[MAX_PATH_SIZE+1];        /* buffer for file header */        byte header[HEADER_SIZE];	FILE *file_p;     /* file pointer for C file routines */        int num_read;      /* number of header bytes read */	int file_size;    /* size of complete file */        int header_size;/* size of header */        int code_size;     /* size of program code */        int data_size;     /* size of program data */        int errcode;       /* error code */        /* ensure that path name is not too long */        if ((strlen(dir_name) + strlen(prog_name) + 5)		 > MAX_PATH_SIZE) return(ERR_SUP_NAMLNG);	/* construct path name */	file_name[0] = NULCH;	if (dir_name[0] != NULCH) {		strcat(file_name, dir_name);	        strcat(file_name, "\\");	}        strcat(file_name, prog_name);	strcat(file_name, ".MPX");        /* try to open the file */	errcode = OK;        file_p = fopen(file_name, "rb");        if (file_p == NULL) return(ERR_SUP_FILNFD);	/* read the header, check for EXE signature */        num_read = fread( (void*) header, 1, HEADER_SIZE, file_p);        if (num_read != HEADER_SIZE) {		errcode = ERR_SUP_FILINV;	}        else if ((header[0] != 0x4D) || (header[1] != 0x5A)) {		errcode = ERR_SUP_FILINV;	}        /* close the file, then return if error occurred */        fclose(file_p);	if (errcode!=OK) return(errcode);        /* compute allocation size needed */        file_size = (header[5]*256 + header[4] -1) * 512		+ (header[3]*256 + header[2]);        header_size =(header[9]*256 + header[8])*16;        code_size = file_size - header_size;        data_size = (header[11]*256 + header[10])*16;        /* return total length and starting offset */        *prog_len_p = code_size + data_size;	*start_offset_p = (header[23]*256 + header[22]) * 16;	return(OK);}/*	Procedure: sys_load_program	Purpose: load a program file	Parameters: see prototype	Returns: error code; zero if OK	Calls:   intdosx		segread		strlen, strcat	Globals: none 	Errors:  ERR_SUP_NAMLNG    name too long		ERR_SUP_FILNFD    file not found	       ERR_SUP_FILINV      file invalid		ERR_SUP_PROGSZ    program too large	       ERR_SUP_LDADDR      address not aligned		ERR_SUP_LDFAIL    load failed*/int sys_load_program (     void*    load_addr,        /* address for loading */			int      max_size,         /* memory size */			char     dir_name[],       /* directory name */			char     prog_name[]       /* program name */		      ){	int errcode;      /* error code */        int prog_len;      /* program length */	int offset;       /* offset for starting */	word norm_seg;    /* normalized load address segment */        word norm_off;     /* normalized load address offset */        /* full pathname for file to be loaded */	char file_name[MAX_PATH_SIZE+1];        /* parameter block for MSDOS EXEC function */	struct {		word load_seg;    /* segment address for loading */	       word reloc_seg;     /* segment address for relocation */        }p_block;	union REGS inregs;            /* input register structure */	union REGS outregs;           /* output register structure */	struct SREGS segregs;         /* segment register structure */        /* check program, get length and offset */	errcode = sys_check_program(dir_name, prog_name,					&prog_len, &offset);        if (errcode < 0) return(errcode);        /* ensure that allocated memory is large enough */        if (max_size < prog_len) return(ERR_SUP_PROGSZ);        /* get normalized segment and offset, check alignment */	norm_seg = FP_SEG(load_addr);	norm_off = FP_OFF(load_addr);	norm_seg += norm_off / 16;        norm_off %= 16;	if (norm_off != 0) return(ERR_SUP_LDADDR);        /* ensure that path name is not too long */        if ((strlen(dir_name) + strlen(prog_name) + 5)		 > MAX_PATH_SIZE) return(ERR_SUP_NAMLNG);	/* construct path name */	file_name[0] = NULCH;	if (dir_name[0] != NULCH) {		strcat(file_name, dir_name);	        strcat(file_name, "\\");	}        strcat(file_name, prog_name);	strcat(file_name, ".MPX");        /* get current segment regs */	segread(&segregs);        /* setup function codes */	inregs.h.ah = 0x4B;        /* EXEC function */	inregs.h.al = 0x03;        /* load only */        /* setup parameter block and name pointers */        segregs.ds = FP_SEG(&file_name);	inregs.x.dx = FP_OFF(&file_name);        segregs.es = FP_SEG(&p_block);	inregs.x.bx = FP_OFF(&p_block);        /* setup load segment -- must be normalized */	p_block.load_seg = norm_seg;	p_block.reloc_seg = p_block.load_seg;        /* call the MS-DOS loader */	errcode = intdosx(&inregs,&outregs,&segregs);        errcode = errcode;        /* check for error */	if (outregs.x.cflag) return(ERR_SUP_LDFAIL);	/* load successful */	return(OK);}/* END OF FILE */sys_load_program1,0

PARSER.C,81
int parse_buffer(char *buffer, char *function, char *args) {parse_buffer30,870

PCB.C,607
PCBDLL *PCBDLL_alloc ()PCBDLL_alloc14,360
PCBDLL **PCBDLL_creation ( int queues )PCBDLL_creation29,660
int PCBDLL_print ( PCBDLL *printq )PCBDLL_print48,1049
PCB *PCB_alloc ()PCB_alloc93,2174
PCB *PCB_setup ( char *pname, int ppriority, int pclass, PCBDLL **allqueues )PCB_setup103,2314
PCB *PCB_find ( char *find, PCBDLL **loop_queues )PCB_find137,3043
int PCB_insert ( PCBDLL *queue, PCB *proc, int newstate )PCB_insert170,3745
int PCB_remove ( PCB *proc, PCBDLL **loop_queues )PCB_remove219,4795
int PCB_free ( PCB *proc )PCB_free271,5955
int PCB_print ( PCB *proc )PCB_print283,6136

PCBMAKE.C,133
int pcreate(char *name, PCBDLL **PRIORITY_QUEUES){pcreate25,517
int pdelete(char *name, PCBDLL **PRIORITY_QUEUES){pdelete86,2267

PCBMAN.C,343
int pblock(char *name, PCBDLL **PRIORITY_QUEUES){pblock24,497
int punblock(char *name, PCBDLL **PRIORITY_QUEUES){punblock76,2081
int psuspend(char *name, PCBDLL **PRIORITY_QUEUES){psuspend128,3704
int presume(char *name, PCBDLL **PRIORITY_QUEUES){presume180,5348
int psetprio(char *argstr, PCBDLL **PRIORITY_QUEUES){psetprio232,6872

PCBSHOW.C,230
int pshow(char *name, PCBDLL **PRIORITY_QUEUES){pshow25,478
int pshowall(PCBDLL **PRIORITY_QUEUES){pshowall46,904
int pshowrd(PCBDLL **PRIORITY_QUEUES){pshowrd61,1396
int pshowblk(PCBDLL **PRIORITY_QUEUES){pshowblk72,1692

PCBUTILS.C,137
int validPrio(int priority){validPrio23,455
int validState(int state){validState27,537
int validClass(int pclass){validClass31,606

SHELL.C,232
int shell() {shell28,582
void welcome_message() {welcome_message140,4236
void departing_message() {departing_message145,4408
void display_prompt() {display_prompt151,4580
int exit_confirmation() {exit_confirmation157,4666

TDF.C,48
int main ( int argc, char *argv[] )main11,160

VERSION.C,42
int version ( char *args )version11,174

include/DATE.H,27
#define DATE_HDATE_H2,15

include/DISPLAY.H,90
#define DISPLAY_HDISPLAY_H8,157
#define DISPLAY_BUFFER_SIZE DISPLAY_BUFFER_SIZE10,176

include/HELP.H,143
#define HELP_HHELP_H2,15
  char *name;name5,48
  char *description;description6,62
  char *usage;usage7,83
} HELP_OBJ;HELP_OBJ13,184

include/HISTORY.H,92
#define HISTORY_HHISTORY_H9,129
#define HBS HBS10,147
#define HIST_LEN HIST_LEN11,163

include/MPX_SUPT.H,30559
/***********************************************************************	MPX: The MultiProgramming eXecutive	Project to Accompany	A Practical Approach to Operating Systems	Malcolm G. Lane & James D. Mooney	Copyright 1993, P.W.S. Kent Publishing Co., Boston, MA.	File Name:	mpx_supt.h	Author:	J. Mooney	Version: 2.0	Date:  02/24/93	Purpose: Header file for MPX support		This file contains support declarations intended		to be visible to student modules.  It should be		included by these modules.			Environment: System Independent (header file only)************************************************************************ Change Log:	02/24/92  jdm	original version	04/06/92  jdm	Module-independent version	05/15/92  jdm	cleanup and documentation	07/14/92  jdm	further work	07/20/92  jdm	cnv flag to int for TURBO C problem	08/07/92  jdm	changed module codes        10/18/92  jdm	added load function and errors	11/17/92  jdm	added memory errors	12/31/92  jdm	added SET, RESET, and NUM_DEVS			removed non-ANSI declarations			changed sys_req params	01/03/93  jdm	revised error codes and names	02/24/93  jdm	changed sys_set_vec param to interrupt************************************************************************//* ANSI C Include Files */#include <stdio.h>#include <ctype.h>#include <string.h>/* logical constants */#define	TRUE	1#define	FALSE	0#define SET	1#define RESET	0#define	NULCH	('\0')/* status and error codes */#define OK	0#define ERR_SUP_INVDEV (-101) /* invalid device id */#define ERR_SUP_INVOPC (-102) /* invalid op code */#define ERR_SUP_INVPOS (-103) /* invalid character position */#define ERR_SUP_RDFAIL (-104) /* read failed */#define ERR_SUP_WRFAIL (-105) /* write failed */#define ERR_SUP_INVMEM (-106) /* invalid memory block pointer */#define ERR_SUP_FRFAIL (-107) /* free failed */#define ERR_SUP_INVDAT (-108) /* invalid date */#define ERR_SUP_DATNCH (-109) /* date not changed */#define ERR_SUP_INVDIR (-110) /* invalid directory name */#define ERR_SUP_DIROPN (-111) /* directory open error */#define ERR_SUP_DIRNOP (-112) /* no directory is open */#define ERR_SUP_NOENTR (-113) /* no more directory entries */#define ERR_SUP_NAMLNG (-114) /* name too long for buffer */#define ERR_SUP_DIRCLS (-115) /* directory close error */#define ERR_SUP_LDFAIL (-116) /* program load failed */#define ERR_SUP_FILNFD (-117) /* file not found */#define ERR_SUP_FILINV (-118) /* file invalid */#define ERR_SUP_PROGSZ (-119) /* program size error */#define ERR_SUP_LDADDR (-120) /* invalid load address */#define ERR_SUP_NOMEM  (-121) /* memory allocation error */#define ERR_SUP_MFREE  (-122) /* memory free error */#define ERR_SUP_INVHAN (-123) /* invalid handler address *//* Service operation codes */#define IDLE	0#define	READ	1#define	WRITE	2#define CLEAR	3#define GOTOXY	4#define EXIT	5/* Device ID codes */#define NO_DEV		0#define	TERMINAL	1#define	PRINTER		2#define	COM_PORT	3#define NUM_DEVS	3/* Module codes */#define BASE_MASK	0x700F#define OPT_MASK	0x0FF0#define MODULE_R1	0x0001#define MODULE_R2	0x0002#define MODULE_R3	0x0004#define MODULE_R4	0x0008#define MODULE_O1	0x0010#define MODULE_O2	0x0020#define MODULE_O3	0x0040#define MODULE_O4	0x0080#define MODULE_O5	0x0100#define MODULE_O6	0x0200#define MODULE_O7	0x0400#define MODULE_O8	0x0800#define MODULE_F	0x4000/* Type and structure definitions */typedef int flag;/* Date record */typedef struct {	int month;	int day;	int year;	} date_rec;/* Support function prototypes *//* Note that these are all "extern" by default */	/* sys_init: initialize MPX */	/*	RETURNS: integer error code; zero if ok */	int sys_init ( int modules /* module code */		);	/* sys_exit: exit to host OS */	void sys_exit (void);		/* sys_set_vec: set trap vector for system call handler */	/*	RETURNS: integer error code; zero if ok */	int sys_set_vec		( void interrupt (*handler)() /* system call handler */		);	/* sys_req: request system service */	/*	RETURNS: result or error code depending on service */	int sys_req  ( int op_code,	/* operation code */			int device_id,	/* device identifier */			char *buf_p,	/* string buffer */			int *count_p	/* ptr to transfer count */		      );	/* sys_alloc_mem: allocate memory */	/* RETURNS: pointer to allocated block */	void *sys_alloc_mem ( size_t size /* block size */		      );		      	/* sys_free_mem: free memory */	/* RETURNS: integer error code, or 0 if ok */	int sys_free_mem (	void *ptr /* ptr to memory to free */			);		      	/* sys_get_date: get system date */	void sys_get_date ( date_rec *date_p /* date record */		      );	/* sys_set_date: set system date */	/*	RETURNS: integer error code, zero if OK */	int sys_set_date ( date_rec *date_p /* date record */		      );	/* sys_open_dir: open a directory */	/*	RETURNS: integer error code, zero if OK */	int sys_open_dir (char dir_name[] /* directory name */		      );		      	/* sys_get_entry: get a directory entry */	/*	RETURNS: integer error code, zero if OK */	int sys_get_entry (char name_buf[], /* file name buffer */			   int buf_size, /* name buffer size */			   long *file_size_p /* file size variable */			   );		/* sys_close_dir: close a directory */	/*	RETURNS: integer error code, zero if OK */	int sys_close_dir (void);        /* sys_check_program; check and measure program file */        /* 	RETURNS: memory size needed, or error code */        int sys_check_program (char dir_name[], /* directory name */        		char prog_name[], /* program name */                        int *prog_len, /* program length */                        int *start_offset /* starting offset */                        );		      	/* sys_load_program: load an MPX program */	/*	RETURNS: success code or error */	int sys_load_program (	void *load_addr, /* load address */        		int max_size, /* maximum program size */                        char dir_name[], /* directory name */			char prog_name[] /* program name */			);/* END OF FILE */flag1,0
/***********************************************************************	MPX: The MultiProgramming eXecutive	Project to Accompany	A Practical Approach to Operating Systems	Malcolm G. Lane & James D. Mooney	Copyright 1993, P.W.S. Kent Publishing Co., Boston, MA.	File Name:	mpx_supt.h	Author:	J. Mooney	Version: 2.0	Date:  02/24/93	Purpose: Header file for MPX support		This file contains support declarations intended		to be visible to student modules.  It should be		included by these modules.			Environment: System Independent (header file only)************************************************************************ Change Log:	02/24/92  jdm	original version	04/06/92  jdm	Module-independent version	05/15/92  jdm	cleanup and documentation	07/14/92  jdm	further work	07/20/92  jdm	cnv flag to int for TURBO C problem	08/07/92  jdm	changed module codes        10/18/92  jdm	added load function and errors	11/17/92  jdm	added memory errors	12/31/92  jdm	added SET, RESET, and NUM_DEVS			removed non-ANSI declarations			changed sys_req params	01/03/93  jdm	revised error codes and names	02/24/93  jdm	changed sys_set_vec param to interrupt************************************************************************//* ANSI C Include Files */#include <stdio.h>#include <ctype.h>#include <string.h>/* logical constants */#define	TRUE	1#define	FALSE	0#define SET	1#define RESET	0#define	NULCH	('\0')/* status and error codes */#define OK	0#define ERR_SUP_INVDEV (-101) /* invalid device id */#define ERR_SUP_INVOPC (-102) /* invalid op code */#define ERR_SUP_INVPOS (-103) /* invalid character position */#define ERR_SUP_RDFAIL (-104) /* read failed */#define ERR_SUP_WRFAIL (-105) /* write failed */#define ERR_SUP_INVMEM (-106) /* invalid memory block pointer */#define ERR_SUP_FRFAIL (-107) /* free failed */#define ERR_SUP_INVDAT (-108) /* invalid date */#define ERR_SUP_DATNCH (-109) /* date not changed */#define ERR_SUP_INVDIR (-110) /* invalid directory name */#define ERR_SUP_DIROPN (-111) /* directory open error */#define ERR_SUP_DIRNOP (-112) /* no directory is open */#define ERR_SUP_NOENTR (-113) /* no more directory entries */#define ERR_SUP_NAMLNG (-114) /* name too long for buffer */#define ERR_SUP_DIRCLS (-115) /* directory close error */#define ERR_SUP_LDFAIL (-116) /* program load failed */#define ERR_SUP_FILNFD (-117) /* file not found */#define ERR_SUP_FILINV (-118) /* file invalid */#define ERR_SUP_PROGSZ (-119) /* program size error */#define ERR_SUP_LDADDR (-120) /* invalid load address */#define ERR_SUP_NOMEM  (-121) /* memory allocation error */#define ERR_SUP_MFREE  (-122) /* memory free error */#define ERR_SUP_INVHAN (-123) /* invalid handler address *//* Service operation codes */#define IDLE	0#define	READ	1#define	WRITE	2#define CLEAR	3#define GOTOXY	4#define EXIT	5/* Device ID codes */#define NO_DEV		0#define	TERMINAL	1#define	PRINTER		2#define	COM_PORT	3#define NUM_DEVS	3/* Module codes */#define BASE_MASK	0x700F#define OPT_MASK	0x0FF0#define MODULE_R1	0x0001#define MODULE_R2	0x0002#define MODULE_R3	0x0004#define MODULE_R4	0x0008#define MODULE_O1	0x0010#define MODULE_O2	0x0020#define MODULE_O3	0x0040#define MODULE_O4	0x0080#define MODULE_O5	0x0100#define MODULE_O6	0x0200#define MODULE_O7	0x0400#define MODULE_O8	0x0800#define MODULE_F	0x4000/* Type and structure definitions */typedef int flag;/* Date record */typedef struct {	int month;	int day;	int year;	} date_rec;/* Support function prototypes *//* Note that these are all "extern" by default */	/* sys_init: initialize MPX */	/*	RETURNS: integer error code; zero if ok */	int sys_init ( int modules /* module code */		);	/* sys_exit: exit to host OS */	void sys_exit (void);		/* sys_set_vec: set trap vector for system call handler */	/*	RETURNS: integer error code; zero if ok */	int sys_set_vec		( void interrupt (*handler)() /* system call handler */		);	/* sys_req: request system service */	/*	RETURNS: result or error code depending on service */	int sys_req  ( int op_code,	/* operation code */			int device_id,	/* device identifier */			char *buf_p,	/* string buffer */			int *count_p	/* ptr to transfer count */		      );	/* sys_alloc_mem: allocate memory */	/* RETURNS: pointer to allocated block */	void *sys_alloc_mem ( size_t size /* block size */		      );		      	/* sys_free_mem: free memory */	/* RETURNS: integer error code, or 0 if ok */	int sys_free_mem (	void *ptr /* ptr to memory to free */			);		      	/* sys_get_date: get system date */	void sys_get_date ( date_rec *date_p /* date record */		      );	/* sys_set_date: set system date */	/*	RETURNS: integer error code, zero if OK */	int sys_set_date ( date_rec *date_p /* date record */		      );	/* sys_open_dir: open a directory */	/*	RETURNS: integer error code, zero if OK */	int sys_open_dir (char dir_name[] /* directory name */		      );		      	/* sys_get_entry: get a directory entry */	/*	RETURNS: integer error code, zero if OK */	int sys_get_entry (char name_buf[], /* file name buffer */			   int buf_size, /* name buffer size */			   long *file_size_p /* file size variable */			   );		/* sys_close_dir: close a directory */	/*	RETURNS: integer error code, zero if OK */	int sys_close_dir (void);        /* sys_check_program; check and measure program file */        /* 	RETURNS: memory size needed, or error code */        int sys_check_program (char dir_name[], /* directory name */        		char prog_name[], /* program name */                        int *prog_len, /* program length */                        int *start_offset /* starting offset */                        );		      	/* sys_load_program: load an MPX program */	/*	RETURNS: success code or error */	int sys_load_program (	void *load_addr, /* load address */        		int max_size, /* maximum program size */                        char dir_name[], /* directory name */			char prog_name[] /* program name */			);/* END OF FILE */month1,0
/***********************************************************************	MPX: The MultiProgramming eXecutive	Project to Accompany	A Practical Approach to Operating Systems	Malcolm G. Lane & James D. Mooney	Copyright 1993, P.W.S. Kent Publishing Co., Boston, MA.	File Name:	mpx_supt.h	Author:	J. Mooney	Version: 2.0	Date:  02/24/93	Purpose: Header file for MPX support		This file contains support declarations intended		to be visible to student modules.  It should be		included by these modules.			Environment: System Independent (header file only)************************************************************************ Change Log:	02/24/92  jdm	original version	04/06/92  jdm	Module-independent version	05/15/92  jdm	cleanup and documentation	07/14/92  jdm	further work	07/20/92  jdm	cnv flag to int for TURBO C problem	08/07/92  jdm	changed module codes        10/18/92  jdm	added load function and errors	11/17/92  jdm	added memory errors	12/31/92  jdm	added SET, RESET, and NUM_DEVS			removed non-ANSI declarations			changed sys_req params	01/03/93  jdm	revised error codes and names	02/24/93  jdm	changed sys_set_vec param to interrupt************************************************************************//* ANSI C Include Files */#include <stdio.h>#include <ctype.h>#include <string.h>/* logical constants */#define	TRUE	1#define	FALSE	0#define SET	1#define RESET	0#define	NULCH	('\0')/* status and error codes */#define OK	0#define ERR_SUP_INVDEV (-101) /* invalid device id */#define ERR_SUP_INVOPC (-102) /* invalid op code */#define ERR_SUP_INVPOS (-103) /* invalid character position */#define ERR_SUP_RDFAIL (-104) /* read failed */#define ERR_SUP_WRFAIL (-105) /* write failed */#define ERR_SUP_INVMEM (-106) /* invalid memory block pointer */#define ERR_SUP_FRFAIL (-107) /* free failed */#define ERR_SUP_INVDAT (-108) /* invalid date */#define ERR_SUP_DATNCH (-109) /* date not changed */#define ERR_SUP_INVDIR (-110) /* invalid directory name */#define ERR_SUP_DIROPN (-111) /* directory open error */#define ERR_SUP_DIRNOP (-112) /* no directory is open */#define ERR_SUP_NOENTR (-113) /* no more directory entries */#define ERR_SUP_NAMLNG (-114) /* name too long for buffer */#define ERR_SUP_DIRCLS (-115) /* directory close error */#define ERR_SUP_LDFAIL (-116) /* program load failed */#define ERR_SUP_FILNFD (-117) /* file not found */#define ERR_SUP_FILINV (-118) /* file invalid */#define ERR_SUP_PROGSZ (-119) /* program size error */#define ERR_SUP_LDADDR (-120) /* invalid load address */#define ERR_SUP_NOMEM  (-121) /* memory allocation error */#define ERR_SUP_MFREE  (-122) /* memory free error */#define ERR_SUP_INVHAN (-123) /* invalid handler address *//* Service operation codes */#define IDLE	0#define	READ	1#define	WRITE	2#define CLEAR	3#define GOTOXY	4#define EXIT	5/* Device ID codes */#define NO_DEV		0#define	TERMINAL	1#define	PRINTER		2#define	COM_PORT	3#define NUM_DEVS	3/* Module codes */#define BASE_MASK	0x700F#define OPT_MASK	0x0FF0#define MODULE_R1	0x0001#define MODULE_R2	0x0002#define MODULE_R3	0x0004#define MODULE_R4	0x0008#define MODULE_O1	0x0010#define MODULE_O2	0x0020#define MODULE_O3	0x0040#define MODULE_O4	0x0080#define MODULE_O5	0x0100#define MODULE_O6	0x0200#define MODULE_O7	0x0400#define MODULE_O8	0x0800#define MODULE_F	0x4000/* Type and structure definitions */typedef int flag;/* Date record */typedef struct {	int month;	int day;	int year;	} date_rec;/* Support function prototypes *//* Note that these are all "extern" by default */	/* sys_init: initialize MPX */	/*	RETURNS: integer error code; zero if ok */	int sys_init ( int modules /* module code */		);	/* sys_exit: exit to host OS */	void sys_exit (void);		/* sys_set_vec: set trap vector for system call handler */	/*	RETURNS: integer error code; zero if ok */	int sys_set_vec		( void interrupt (*handler)() /* system call handler */		);	/* sys_req: request system service */	/*	RETURNS: result or error code depending on service */	int sys_req  ( int op_code,	/* operation code */			int device_id,	/* device identifier */			char *buf_p,	/* string buffer */			int *count_p	/* ptr to transfer count */		      );	/* sys_alloc_mem: allocate memory */	/* RETURNS: pointer to allocated block */	void *sys_alloc_mem ( size_t size /* block size */		      );		      	/* sys_free_mem: free memory */	/* RETURNS: integer error code, or 0 if ok */	int sys_free_mem (	void *ptr /* ptr to memory to free */			);		      	/* sys_get_date: get system date */	void sys_get_date ( date_rec *date_p /* date record */		      );	/* sys_set_date: set system date */	/*	RETURNS: integer error code, zero if OK */	int sys_set_date ( date_rec *date_p /* date record */		      );	/* sys_open_dir: open a directory */	/*	RETURNS: integer error code, zero if OK */	int sys_open_dir (char dir_name[] /* directory name */		      );		      	/* sys_get_entry: get a directory entry */	/*	RETURNS: integer error code, zero if OK */	int sys_get_entry (char name_buf[], /* file name buffer */			   int buf_size, /* name buffer size */			   long *file_size_p /* file size variable */			   );		/* sys_close_dir: close a directory */	/*	RETURNS: integer error code, zero if OK */	int sys_close_dir (void);        /* sys_check_program; check and measure program file */        /* 	RETURNS: memory size needed, or error code */        int sys_check_program (char dir_name[], /* directory name */        		char prog_name[], /* program name */                        int *prog_len, /* program length */                        int *start_offset /* starting offset */                        );		      	/* sys_load_program: load an MPX program */	/*	RETURNS: success code or error */	int sys_load_program (	void *load_addr, /* load address */        		int max_size, /* maximum program size */                        char dir_name[], /* directory name */			char prog_name[] /* program name */			);/* END OF FILE */day1,0
/***********************************************************************	MPX: The MultiProgramming eXecutive	Project to Accompany	A Practical Approach to Operating Systems	Malcolm G. Lane & James D. Mooney	Copyright 1993, P.W.S. Kent Publishing Co., Boston, MA.	File Name:	mpx_supt.h	Author:	J. Mooney	Version: 2.0	Date:  02/24/93	Purpose: Header file for MPX support		This file contains support declarations intended		to be visible to student modules.  It should be		included by these modules.			Environment: System Independent (header file only)************************************************************************ Change Log:	02/24/92  jdm	original version	04/06/92  jdm	Module-independent version	05/15/92  jdm	cleanup and documentation	07/14/92  jdm	further work	07/20/92  jdm	cnv flag to int for TURBO C problem	08/07/92  jdm	changed module codes        10/18/92  jdm	added load function and errors	11/17/92  jdm	added memory errors	12/31/92  jdm	added SET, RESET, and NUM_DEVS			removed non-ANSI declarations			changed sys_req params	01/03/93  jdm	revised error codes and names	02/24/93  jdm	changed sys_set_vec param to interrupt************************************************************************//* ANSI C Include Files */#include <stdio.h>#include <ctype.h>#include <string.h>/* logical constants */#define	TRUE	1#define	FALSE	0#define SET	1#define RESET	0#define	NULCH	('\0')/* status and error codes */#define OK	0#define ERR_SUP_INVDEV (-101) /* invalid device id */#define ERR_SUP_INVOPC (-102) /* invalid op code */#define ERR_SUP_INVPOS (-103) /* invalid character position */#define ERR_SUP_RDFAIL (-104) /* read failed */#define ERR_SUP_WRFAIL (-105) /* write failed */#define ERR_SUP_INVMEM (-106) /* invalid memory block pointer */#define ERR_SUP_FRFAIL (-107) /* free failed */#define ERR_SUP_INVDAT (-108) /* invalid date */#define ERR_SUP_DATNCH (-109) /* date not changed */#define ERR_SUP_INVDIR (-110) /* invalid directory name */#define ERR_SUP_DIROPN (-111) /* directory open error */#define ERR_SUP_DIRNOP (-112) /* no directory is open */#define ERR_SUP_NOENTR (-113) /* no more directory entries */#define ERR_SUP_NAMLNG (-114) /* name too long for buffer */#define ERR_SUP_DIRCLS (-115) /* directory close error */#define ERR_SUP_LDFAIL (-116) /* program load failed */#define ERR_SUP_FILNFD (-117) /* file not found */#define ERR_SUP_FILINV (-118) /* file invalid */#define ERR_SUP_PROGSZ (-119) /* program size error */#define ERR_SUP_LDADDR (-120) /* invalid load address */#define ERR_SUP_NOMEM  (-121) /* memory allocation error */#define ERR_SUP_MFREE  (-122) /* memory free error */#define ERR_SUP_INVHAN (-123) /* invalid handler address *//* Service operation codes */#define IDLE	0#define	READ	1#define	WRITE	2#define CLEAR	3#define GOTOXY	4#define EXIT	5/* Device ID codes */#define NO_DEV		0#define	TERMINAL	1#define	PRINTER		2#define	COM_PORT	3#define NUM_DEVS	3/* Module codes */#define BASE_MASK	0x700F#define OPT_MASK	0x0FF0#define MODULE_R1	0x0001#define MODULE_R2	0x0002#define MODULE_R3	0x0004#define MODULE_R4	0x0008#define MODULE_O1	0x0010#define MODULE_O2	0x0020#define MODULE_O3	0x0040#define MODULE_O4	0x0080#define MODULE_O5	0x0100#define MODULE_O6	0x0200#define MODULE_O7	0x0400#define MODULE_O8	0x0800#define MODULE_F	0x4000/* Type and structure definitions */typedef int flag;/* Date record */typedef struct {	int month;	int day;	int year;	} date_rec;/* Support function prototypes *//* Note that these are all "extern" by default */	/* sys_init: initialize MPX */	/*	RETURNS: integer error code; zero if ok */	int sys_init ( int modules /* module code */		);	/* sys_exit: exit to host OS */	void sys_exit (void);		/* sys_set_vec: set trap vector for system call handler */	/*	RETURNS: integer error code; zero if ok */	int sys_set_vec		( void interrupt (*handler)() /* system call handler */		);	/* sys_req: request system service */	/*	RETURNS: result or error code depending on service */	int sys_req  ( int op_code,	/* operation code */			int device_id,	/* device identifier */			char *buf_p,	/* string buffer */			int *count_p	/* ptr to transfer count */		      );	/* sys_alloc_mem: allocate memory */	/* RETURNS: pointer to allocated block */	void *sys_alloc_mem ( size_t size /* block size */		      );		      	/* sys_free_mem: free memory */	/* RETURNS: integer error code, or 0 if ok */	int sys_free_mem (	void *ptr /* ptr to memory to free */			);		      	/* sys_get_date: get system date */	void sys_get_date ( date_rec *date_p /* date record */		      );	/* sys_set_date: set system date */	/*	RETURNS: integer error code, zero if OK */	int sys_set_date ( date_rec *date_p /* date record */		      );	/* sys_open_dir: open a directory */	/*	RETURNS: integer error code, zero if OK */	int sys_open_dir (char dir_name[] /* directory name */		      );		      	/* sys_get_entry: get a directory entry */	/*	RETURNS: integer error code, zero if OK */	int sys_get_entry (char name_buf[], /* file name buffer */			   int buf_size, /* name buffer size */			   long *file_size_p /* file size variable */			   );		/* sys_close_dir: close a directory */	/*	RETURNS: integer error code, zero if OK */	int sys_close_dir (void);        /* sys_check_program; check and measure program file */        /* 	RETURNS: memory size needed, or error code */        int sys_check_program (char dir_name[], /* directory name */        		char prog_name[], /* program name */                        int *prog_len, /* program length */                        int *start_offset /* starting offset */                        );		      	/* sys_load_program: load an MPX program */	/*	RETURNS: success code or error */	int sys_load_program (	void *load_addr, /* load address */        		int max_size, /* maximum program size */                        char dir_name[], /* directory name */			char prog_name[] /* program name */			);/* END OF FILE */year1,0
/***********************************************************************	MPX: The MultiProgramming eXecutive	Project to Accompany	A Practical Approach to Operating Systems	Malcolm G. Lane & James D. Mooney	Copyright 1993, P.W.S. Kent Publishing Co., Boston, MA.	File Name:	mpx_supt.h	Author:	J. Mooney	Version: 2.0	Date:  02/24/93	Purpose: Header file for MPX support		This file contains support declarations intended		to be visible to student modules.  It should be		included by these modules.			Environment: System Independent (header file only)************************************************************************ Change Log:	02/24/92  jdm	original version	04/06/92  jdm	Module-independent version	05/15/92  jdm	cleanup and documentation	07/14/92  jdm	further work	07/20/92  jdm	cnv flag to int for TURBO C problem	08/07/92  jdm	changed module codes        10/18/92  jdm	added load function and errors	11/17/92  jdm	added memory errors	12/31/92  jdm	added SET, RESET, and NUM_DEVS			removed non-ANSI declarations			changed sys_req params	01/03/93  jdm	revised error codes and names	02/24/93  jdm	changed sys_set_vec param to interrupt************************************************************************//* ANSI C Include Files */#include <stdio.h>#include <ctype.h>#include <string.h>/* logical constants */#define	TRUE	1#define	FALSE	0#define SET	1#define RESET	0#define	NULCH	('\0')/* status and error codes */#define OK	0#define ERR_SUP_INVDEV (-101) /* invalid device id */#define ERR_SUP_INVOPC (-102) /* invalid op code */#define ERR_SUP_INVPOS (-103) /* invalid character position */#define ERR_SUP_RDFAIL (-104) /* read failed */#define ERR_SUP_WRFAIL (-105) /* write failed */#define ERR_SUP_INVMEM (-106) /* invalid memory block pointer */#define ERR_SUP_FRFAIL (-107) /* free failed */#define ERR_SUP_INVDAT (-108) /* invalid date */#define ERR_SUP_DATNCH (-109) /* date not changed */#define ERR_SUP_INVDIR (-110) /* invalid directory name */#define ERR_SUP_DIROPN (-111) /* directory open error */#define ERR_SUP_DIRNOP (-112) /* no directory is open */#define ERR_SUP_NOENTR (-113) /* no more directory entries */#define ERR_SUP_NAMLNG (-114) /* name too long for buffer */#define ERR_SUP_DIRCLS (-115) /* directory close error */#define ERR_SUP_LDFAIL (-116) /* program load failed */#define ERR_SUP_FILNFD (-117) /* file not found */#define ERR_SUP_FILINV (-118) /* file invalid */#define ERR_SUP_PROGSZ (-119) /* program size error */#define ERR_SUP_LDADDR (-120) /* invalid load address */#define ERR_SUP_NOMEM  (-121) /* memory allocation error */#define ERR_SUP_MFREE  (-122) /* memory free error */#define ERR_SUP_INVHAN (-123) /* invalid handler address *//* Service operation codes */#define IDLE	0#define	READ	1#define	WRITE	2#define CLEAR	3#define GOTOXY	4#define EXIT	5/* Device ID codes */#define NO_DEV		0#define	TERMINAL	1#define	PRINTER		2#define	COM_PORT	3#define NUM_DEVS	3/* Module codes */#define BASE_MASK	0x700F#define OPT_MASK	0x0FF0#define MODULE_R1	0x0001#define MODULE_R2	0x0002#define MODULE_R3	0x0004#define MODULE_R4	0x0008#define MODULE_O1	0x0010#define MODULE_O2	0x0020#define MODULE_O3	0x0040#define MODULE_O4	0x0080#define MODULE_O5	0x0100#define MODULE_O6	0x0200#define MODULE_O7	0x0400#define MODULE_O8	0x0800#define MODULE_F	0x4000/* Type and structure definitions */typedef int flag;/* Date record */typedef struct {	int month;	int day;	int year;	} date_rec;/* Support function prototypes *//* Note that these are all "extern" by default */	/* sys_init: initialize MPX */	/*	RETURNS: integer error code; zero if ok */	int sys_init ( int modules /* module code */		);	/* sys_exit: exit to host OS */	void sys_exit (void);		/* sys_set_vec: set trap vector for system call handler */	/*	RETURNS: integer error code; zero if ok */	int sys_set_vec		( void interrupt (*handler)() /* system call handler */		);	/* sys_req: request system service */	/*	RETURNS: result or error code depending on service */	int sys_req  ( int op_code,	/* operation code */			int device_id,	/* device identifier */			char *buf_p,	/* string buffer */			int *count_p	/* ptr to transfer count */		      );	/* sys_alloc_mem: allocate memory */	/* RETURNS: pointer to allocated block */	void *sys_alloc_mem ( size_t size /* block size */		      );		      	/* sys_free_mem: free memory */	/* RETURNS: integer error code, or 0 if ok */	int sys_free_mem (	void *ptr /* ptr to memory to free */			);		      	/* sys_get_date: get system date */	void sys_get_date ( date_rec *date_p /* date record */		      );	/* sys_set_date: set system date */	/*	RETURNS: integer error code, zero if OK */	int sys_set_date ( date_rec *date_p /* date record */		      );	/* sys_open_dir: open a directory */	/*	RETURNS: integer error code, zero if OK */	int sys_open_dir (char dir_name[] /* directory name */		      );		      	/* sys_get_entry: get a directory entry */	/*	RETURNS: integer error code, zero if OK */	int sys_get_entry (char name_buf[], /* file name buffer */			   int buf_size, /* name buffer size */			   long *file_size_p /* file size variable */			   );		/* sys_close_dir: close a directory */	/*	RETURNS: integer error code, zero if OK */	int sys_close_dir (void);        /* sys_check_program; check and measure program file */        /* 	RETURNS: memory size needed, or error code */        int sys_check_program (char dir_name[], /* directory name */        		char prog_name[], /* program name */                        int *prog_len, /* program length */                        int *start_offset /* starting offset */                        );		      	/* sys_load_program: load an MPX program */	/*	RETURNS: success code or error */	int sys_load_program (	void *load_addr, /* load address */        		int max_size, /* maximum program size */                        char dir_name[], /* directory name */			char prog_name[] /* program name */			);/* END OF FILE */date_rec1,0

include/PARSER.H,344
#define PARSER_HPARSER_H9,180
#define BUFFER_SIZE BUFFER_SIZE12,221
#define FNAME_SIZE FNAME_SIZE13,245
#define PARSER_FAIL_WHITESPACE PARSER_FAIL_WHITESPACE17,322
#define PARSER_FAIL_LONGNAME PARSER_FAIL_LONGNAME18,358
#define PARSER_WIN_SINGLETON PARSER_WIN_SINGLETON21,394
#define PARSER_WIN_HAS_ARGS PARSER_WIN_HAS_ARGS22,427

include/PCB.H,600
#define PCB_HPCB_H10,175
#define TDF_QUEUES TDF_QUEUES13,221
#define READY READY16,278
#define BLOCKED BLOCKED17,294
#define READYSUSPENDED READYSUSPENDED18,312
#define BLOCKEDSUSPENDED BLOCKEDSUSPENDED19,337
#define APPLICATION APPLICATION22,395
#define SYSTEM SYSTEM23,417
  char name[9];name26,452
  int pclass;pclass27,468
  int priority;priority28,482
  int state;state29,498
} PCB;PCB34,643
struct PCBDLL {PCBDLL36,651
  struct PCBDLL *prev;prev37,667
  struct PCBDLL *next;next38,690
  PCB *contents;contents39,713
typedef struct PCBDLL PCBDLL;PCBDLL41,733

include/PCBMAKE.H,33
#define PCBMAKE_HPCBMAKE_H2,18

include/PCBMAN.H,31
#define PCBMAN_HPCBMAN_H2,17

include/PCBSHOW.H,33
#define PCBSHOW_HPCBSHOW_H2,18

include/PCBUTILS.H,35
#define PCBUTILS_HPCBUTILS_H2,19

include/SHELL.H,655
#define SHELL_HSHELL_H8,143
#define BUFFER_SIZE BUFFER_SIZE11,187
#define FNAME_SIZE FNAME_SIZE12,211
#define SHELL_EXIT_CONFIRM SHELL_EXIT_CONFIRM15,294
#define SHELL_EXIT_DENY SHELL_EXIT_DENY16,324
int SYS_REQ_ERR;SYS_REQ_ERR18,352
int CLEAN_BUFFER_ERR;CLEAN_BUFFER_ERR19,369
int EXIT_PROMPT_LOOP;EXIT_PROMPT_LOOP20,391
int buffer_size;buffer_size21,413
char BUFFER[BUFFER_SIZE];BUFFER22,430
char ARGUMENTS[BUFFER_SIZE-FNAME_SIZE];ARGUMENTS23,456
char *PARSED_CMD[FNAME_SIZE];PARSED_CMD24,496
int err;err25,526
char EXIT_STRING[5];EXIT_STRING26,535
int PARSER_ERROR;PARSER_ERROR27,556
int EXIT_CONFIRM;EXIT_CONFIRM28,574

include/TDF.H,72
#define TDF_HTDF_H8,139
#define TDF_OS_VERSION TDF_OS_VERSION11,192

include/VERSION.H,58
#define VERSION_HVERSION_H8,128
#define VBS VBS10,147
